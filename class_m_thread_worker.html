<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MThreadWorker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_thread_worker.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_m_thread_worker-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MThreadWorker Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___m_c_o_r_e.html">MCORE</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract worker thread, the one optimized for doing work outside of the currently running thread.  
 <a href="class_m_thread_worker.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MThreadWorker:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_thread_worker__inherit__graph.png" border="0" usemap="#_m_thread_worker_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_thread_worker_inherit__map" id="_m_thread_worker_inherit__map">
<area shape="rect" id="node2" href="class_m_thread.html" title="Operating system independent abstract thread. " alt="" coords="27,5,99,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a63c373240caaec1852446f4db0678ba2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a63c373240caaec1852446f4db0678ba2">StaticRunFunctionType</a>) (<a class="el" href="class_m_thread_worker.html">MThreadWorker</a> *)</td></tr>
<tr class="memdesc:a63c373240caaec1852446f4db0678ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global user redefined function for thread execution.  <a href="#a63c373240caaec1852446f4db0678ba2">More...</a><br /></td></tr>
<tr class="separator:a63c373240caaec1852446f4db0678ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac25e5908cf16aae9c5fea5321fb66fc8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#ac25e5908cf16aae9c5fea5321fb66fc8">Start</a> ()</td></tr>
<tr class="memdesc:ac25e5908cf16aae9c5fea5321fb66fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and start the thread by execution of Run virtual function.  <a href="#ac25e5908cf16aae9c5fea5321fb66fc8">More...</a><br /></td></tr>
<tr class="separator:ac25e5908cf16aae9c5fea5321fb66fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272e49e9c7812e6c6eb9f032acc8dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#ac272e49e9c7812e6c6eb9f032acc8dba">WaitUntilFinished</a> (bool throwIfError=true, long timeout=-1)</td></tr>
<tr class="memdesc:ac272e49e9c7812e6c6eb9f032acc8dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A request of the thread client to wait until the thread finishes execution.  <a href="#ac272e49e9c7812e6c6eb9f032acc8dba">More...</a><br /></td></tr>
<tr class="separator:ac272e49e9c7812e6c6eb9f032acc8dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1916a3040a25259fadc7c049b1134"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a33a1916a3040a25259fadc7c049b1134">IsRunning</a> () const </td></tr>
<tr class="memdesc:a33a1916a3040a25259fadc7c049b1134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the background thread is currently running.  <a href="#a33a1916a3040a25259fadc7c049b1134">More...</a><br /></td></tr>
<tr class="separator:a33a1916a3040a25259fadc7c049b1134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b059641785e2fceec58132badd7904"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a32b059641785e2fceec58132badd7904">IsFinished</a> () const </td></tr>
<tr class="memdesc:a32b059641785e2fceec58132badd7904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy method that tells if the thread is not running.  <a href="#a32b059641785e2fceec58132badd7904">More...</a><br /></td></tr>
<tr class="separator:a32b059641785e2fceec58132badd7904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f10d73a902072f6968fbc994095741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_exception.html">MException</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a86f10d73a902072f6968fbc994095741">GetExitException</a> ()</td></tr>
<tr class="memdesc:a86f10d73a902072f6968fbc994095741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exception with which the thread was finished.  <a href="#a86f10d73a902072f6968fbc994095741">More...</a><br /></td></tr>
<tr class="separator:a86f10d73a902072f6968fbc994095741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1094f10d50df81984b04a824883eaacb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_exception.html">MException</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a1094f10d50df81984b04a824883eaacb">GetExitException</a> () const </td></tr>
<tr class="memdesc:a1094f10d50df81984b04a824883eaacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constant return exception after the thread is finished.  <a href="#a1094f10d50df81984b04a824883eaacb">More...</a><br /></td></tr>
<tr class="separator:a1094f10d50df81984b04a824883eaacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0842a503643a74173817628d79c53c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#ac0842a503643a74173817628d79c53c7">Run</a> ()=0</td></tr>
<tr class="memdesc:ac0842a503643a74173817628d79c53c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread abstract running function.  <a href="#ac0842a503643a74173817628d79c53c7">More...</a><br /></td></tr>
<tr class="separator:ac0842a503643a74173817628d79c53c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_thread"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_thread')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_thread.html">MThread</a></td></tr>
<tr class="memitem:a09d185667f27f25e322a0bf0212b755d inherit pub_methods_class_m_thread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09d185667f27f25e322a0bf0212b755d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread.html#a09d185667f27f25e322a0bf0212b755d">~MThread</a> ()</td></tr>
<tr class="memdesc:a09d185667f27f25e322a0bf0212b755d inherit pub_methods_class_m_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, destroys the thread object. <br /></td></tr>
<tr class="separator:a09d185667f27f25e322a0bf0212b755d inherit pub_methods_class_m_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d492612376f511f61a69f00169bd8 inherit pub_methods_class_m_thread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73d492612376f511f61a69f00169bd8"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread.html#ae73d492612376f511f61a69f00169bd8">GetThreadId</a> () const </td></tr>
<tr class="memdesc:ae73d492612376f511f61a69f00169bd8 inherit pub_methods_class_m_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread identifier, a number that is guaranteed to be unique per thread. <br /></td></tr>
<tr class="separator:ae73d492612376f511f61a69f00169bd8 inherit pub_methods_class_m_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3ba1b0eecb583f452c931ccff57df9 inherit pub_methods_class_m_thread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a3ba1b0eecb583f452c931ccff57df9"></a>
InternalHandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread.html#a4a3ba1b0eecb583f452c931ccff57df9">GetInternalHandle</a> () const  volatile</td></tr>
<tr class="memdesc:a4a3ba1b0eecb583f452c931ccff57df9 inherit pub_methods_class_m_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread handle, operating system dependent thread object manipulator. <br /></td></tr>
<tr class="separator:a4a3ba1b0eecb583f452c931ccff57df9 inherit pub_methods_class_m_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4a09b43d0c01fee642e7014daa826ad6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a4a09b43d0c01fee642e7014daa826ad6">StaticRun</a> (<a class="el" href="class_m_thread_worker.html">MThreadWorker</a> *thread)</td></tr>
<tr class="memdesc:a4a09b43d0c01fee642e7014daa826ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static runner of the thread that is called for thread execution.  <a href="#a4a09b43d0c01fee642e7014daa826ad6">More...</a><br /></td></tr>
<tr class="separator:a4a09b43d0c01fee642e7014daa826ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adbce246ad3fdb9deebba63a11c3b14b5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_thread_worker.html#a63c373240caaec1852446f4db0678ba2">StaticRunFunctionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#adbce246ad3fdb9deebba63a11c3b14b5">GetStaticRunFunction</a> ()</td></tr>
<tr class="separator:adbce246ad3fdb9deebba63a11c3b14b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bcbba295684ed2b58547ced68a8616"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#a23bcbba295684ed2b58547ced68a8616">SetStaticRunFunction</a> (<a class="el" href="class_m_thread_worker.html#a63c373240caaec1852446f4db0678ba2">StaticRunFunctionType</a> func)</td></tr>
<tr class="separator:a23bcbba295684ed2b58547ced68a8616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_thread"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_thread')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_thread.html">MThread</a></td></tr>
<tr class="memitem:a52f210ee32e508a9cd36fc65eecafd15 inherit pub_static_methods_class_m_thread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52f210ee32e508a9cd36fc65eecafd15"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread.html#a52f210ee32e508a9cd36fc65eecafd15">Relinquish</a> ()</td></tr>
<tr class="memdesc:a52f210ee32e508a9cd36fc65eecafd15 inherit pub_static_methods_class_m_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the rest of our time slice letting the other threads run. <br /></td></tr>
<tr class="separator:a52f210ee32e508a9cd36fc65eecafd15 inherit pub_static_methods_class_m_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acd9ce409121b42125dc0142fa22a7b8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#acd9ce409121b42125dc0142fa22a7b8f">MThreadWorker</a> ()</td></tr>
<tr class="memdesc:acd9ce409121b42125dc0142fa22a7b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread constructor.  <a href="#acd9ce409121b42125dc0142fa22a7b8f">More...</a><br /></td></tr>
<tr class="separator:acd9ce409121b42125dc0142fa22a7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02400a97be96923d0efe4ab899d0d9e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread_worker.html#ad02400a97be96923d0efe4ab899d0d9e">~MThreadWorker</a> ()</td></tr>
<tr class="memdesc:ad02400a97be96923d0efe4ab899d0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, destroys the thread object.  <a href="#ad02400a97be96923d0efe4ab899d0d9e">More...</a><br /></td></tr>
<tr class="separator:ad02400a97be96923d0efe4ab899d0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_thread"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_thread')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_thread.html">MThread</a></td></tr>
<tr class="memitem:aba56222ed8ad1d2baa67e61a5ffec088 inherit pro_methods_class_m_thread"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread.html#aba56222ed8ad1d2baa67e61a5ffec088">MThread</a> (InternalHandleType thread=0)</td></tr>
<tr class="memdesc:aba56222ed8ad1d2baa67e61a5ffec088 inherit pro_methods_class_m_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operating system dependent internal handle type.  <a href="#aba56222ed8ad1d2baa67e61a5ffec088">More...</a><br /></td></tr>
<tr class="separator:aba56222ed8ad1d2baa67e61a5ffec088 inherit pro_methods_class_m_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_m_thread"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_m_thread')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_m_thread.html">MThread</a></td></tr>
<tr class="memitem:a6aa30066c68e04d001c1fe3dec143de2 inherit pro_attribs_class_m_thread"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aa30066c68e04d001c1fe3dec143de2"></a>
volatile InternalHandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_thread.html#a6aa30066c68e04d001c1fe3dec143de2">m_thread</a></td></tr>
<tr class="memdesc:a6aa30066c68e04d001c1fe3dec143de2 inherit pro_attribs_class_m_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread handle. <br /></td></tr>
<tr class="separator:a6aa30066c68e04d001c1fe3dec143de2 inherit pro_attribs_class_m_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract worker thread, the one optimized for doing work outside of the currently running thread. </p>
<p>Every thread, child of this class will have to overload the function <a class="el" href="class_m_thread_worker.html#ac0842a503643a74173817628d79c53c7" title="Worker thread abstract running function. ">Run()</a> to specify what exactly the thread should be doing.</p>
<p>For every thread, standard C random number generator is seeded once. On Windows, and when COM support is enabled, COM is initialized. Also, there is a way of statically adding a user defined function to be called at every thread creation, see SetThreadStartFunction(). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a63c373240caaec1852446f4db0678ba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* MThreadWorker::StaticRunFunctionType) (<a class="el" href="class_m_thread_worker.html">MThreadWorker</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global user redefined function for thread execution. </p>
<p>This is a hook that can be used in place of default StaticRun function for executing any code that is specific to all threads created by the library. As an example, it can be used to set a per thread crash handler.</p>
<p>Typically, the user defined function will do some custom initialization and then call <a class="el" href="class_m_thread_worker.html#a4a09b43d0c01fee642e7014daa826ad6" title="Static runner of the thread that is called for thread execution. ">MThreadWorker::StaticRun</a>, which is the default implementation. It is not recommended to completely replace StaticRun. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acd9ce409121b42125dc0142fa22a7b8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MThreadWorker::MThreadWorker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread constructor. </p>
<p>The real worker threads will derive from <a class="el" href="class_m_thread_worker.html" title="Abstract worker thread, the one optimized for doing work outside of the currently running thread...">MThreadWorker</a>, this is why the constructor is protected. </p>

</div>
</div>
<a class="anchor" id="ad02400a97be96923d0efe4ab899d0d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MThreadWorker::~MThreadWorker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, destroys the thread object. </p>
<dl class="section pre"><dt>Precondition</dt><dd>There should be no thread running (the thread function should be exited). Otherwise the behavior is undefined, as the function might want to continue using its worker thread object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a86f10d73a902072f6968fbc994095741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_exception.html">MException</a>* MThreadWorker::GetExitException </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the exception with which the thread was finished. </p>
<p>If the thread was finished normally with return from Run, this is NULL. Note that the clients should not attempt to delete the returned exception.</p>
<dl class="section pre"><dt>Precondition</dt><dd>IsFinished is true, otherwise the exception will notify about improper usage. </dd></dl>

</div>
</div>
<a class="anchor" id="a1094f10d50df81984b04a824883eaacb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_exception.html">MException</a>* MThreadWorker::GetExitException </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the constant return exception after the thread is finished. </p>
<p>Note that the clients should not attempt to delete the returned exception.</p>
<dl class="section pre"><dt>Precondition</dt><dd>IsFinished is true, otherwise the exception will notify about improper usage. </dd></dl>

</div>
</div>
<a class="anchor" id="adbce246ad3fdb9deebba63a11c3b14b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_thread_worker.html#a63c373240caaec1852446f4db0678ba2">StaticRunFunctionType</a> MThreadWorker::GetStaticRunFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically defined function to call at thread execution.</p>
<p>By default, it is <a class="el" href="class_m_thread_worker.html#a4a09b43d0c01fee642e7014daa826ad6" title="Static runner of the thread that is called for thread execution. ">MThreadWorker::StaticRun</a>.</p>
<p>Having it global and static allows applications to employ a hook that alters all threads created by MeteringSDK, which is a convenience for cases such as installing per thread crash handlers.</p>
<p>There is no synchronization available for getting and setting of this function, therefore, the best place to call this method is prior to creation of any thread, such as the first few lines of main function.</p>
<p>Typically, the user defined function will do some custom initialization and then call <a class="el" href="class_m_thread_worker.html#a4a09b43d0c01fee642e7014daa826ad6" title="Static runner of the thread that is called for thread execution. ">MThreadWorker::StaticRun</a>, the default implementation. It is not recommended to completely replace StaticRun with the custom code. </p>

</div>
</div>
<a class="anchor" id="a32b059641785e2fceec58132badd7904"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MThreadWorker::IsFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Legacy method that tells if the thread is not running. </p>
<p>The name is somewhat misleading as it will return true even if the thread had not run at all. Because of it, use <a class="el" href="class_m_thread_worker.html#a33a1916a3040a25259fadc7c049b1134">IsRunning</a> instead.</p>
<p>This service can be called by both the worker thread, and its client. </p>

</div>
</div>
<a class="anchor" id="a33a1916a3040a25259fadc7c049b1134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MThreadWorker::IsRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if the background thread is currently running. </p>
<p>The service can be called by both the worker thread, and its client.</p>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>False : the thread has not run yet, or it has finished.</li>
<li>True : the worker thread is running </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac0842a503643a74173817628d79c53c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MThreadWorker::Run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread abstract running function. </p>
<p>User shall redefine this method to perform desired actions in a separate thread. This is called from StaticRun, or from a custom user defined global thread function in order to perform actions specific to thread. </p>

</div>
</div>
<a class="anchor" id="a23bcbba295684ed2b58547ced68a8616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MThreadWorker::SetStaticRunFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_thread_worker.html#a63c373240caaec1852446f4db0678ba2">StaticRunFunctionType</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically defined function to call at thread execution.</p>
<p>By default, it is <a class="el" href="class_m_thread_worker.html#a4a09b43d0c01fee642e7014daa826ad6" title="Static runner of the thread that is called for thread execution. ">MThreadWorker::StaticRun</a>.</p>
<p>Having it global and static allows applications to employ a hook that alters all threads created by MeteringSDK, which is a convenience for cases such as installing per thread crash handlers.</p>
<p>There is no synchronization available for getting and setting of this function, therefore, the best place to call this method is prior to creation of any thread, such as the first few lines of main function.</p>
<p>Typically, the user defined function will do some custom initialization and then call <a class="el" href="class_m_thread_worker.html#a4a09b43d0c01fee642e7014daa826ad6" title="Static runner of the thread that is called for thread execution. ">MThreadWorker::StaticRun</a>, the default implementation. It is not recommended to completely replace StaticRun with the custom code. </p>

</div>
</div>
<a class="anchor" id="ac25e5908cf16aae9c5fea5321fb66fc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MThreadWorker::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and start the thread by execution of Run virtual function. </p>
<p>This is a client thread call.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There is enough resources to create and start a thread, otherwise a system error is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a09b43d0c01fee642e7014daa826ad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MThreadWorker::StaticRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_thread_worker.html">MThreadWorker</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static runner of the thread that is called for thread execution. </p>
<p>There is a way of overriding this function globally by calling SetCustomStaticRunFunction(). The custom call will typically eventually call StaticRun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to thread object, self. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac272e49e9c7812e6c6eb9f032acc8dba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MThreadWorker::WaitUntilFinished </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwIfError</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A request of the thread client to wait until the thread finishes execution. </p>
<p>If the thread finished already, return immediately. If there was no thread created, or it was destroyed, WaitUntilFinished returns true immediately, a success.</p>
<p>This call should be made by the thread client, as it does not make any sense to be called by the worker thread itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">throwIfError</td><td>If true, and the worker raised an exception, this exception will be rethrown in the context of the caller of WaitUntilFinished. If the parameter is false, but the error is raised by the worker thread it will be available with <a class="el" href="class_m_thread_worker.html#a86f10d73a902072f6968fbc994095741" title="Get the exception with which the thread was finished. ">GetExitException()</a>/ </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds to wait for the thread to finish. NOTE: Some operating systems such as Android does not support timeout parameter, the value will be ignored and the thread will be waited for possibly an unlimited time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_thread_worker.html">MThreadWorker</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
