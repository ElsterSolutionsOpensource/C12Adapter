<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MProtocolC12 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_protocol_c12.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_m_protocol_c12-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MProtocolC12 Class Reference<div class="ingroups"><a class="el" href="group___m_c_o_m.html">MCOM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic ANSI C12 abstract protocol, base for C12.18, C12.21, and C12.22.  
 <a href="class_m_protocol_c12.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MProtocolC12:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_protocol_c12__inherit__graph.png" border="0" usemap="#_m_protocol_c12_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_protocol_c12_inherit__map" id="_m_protocol_c12_inherit__map">
<area shape="rect" id="node5" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. " alt="" coords="5,304,124,331"/>
<area shape="rect" id="node7" href="class_m_protocol_c1222.html" title="ANSI C12.22 protocol implementation. " alt="" coords="148,304,267,331"/>
<area shape="rect" id="node2" href="class_m_protocol.html" title="Abstraction of a communication protocol. " alt="" coords="95,155,176,181"/>
<area shape="rect" id="node3" href="class_m_c_o_m_object.html" title="Root communication object that defines default property handling and configuration location..." alt="" coords="85,80,186,107"/>
<area shape="rect" id="node4" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars..." alt="" coords="100,5,171,32"/>
<area shape="rect" id="node6" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. " alt="" coords="5,379,124,405"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a101a273254d6d1b343a7042ffe0d68bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a> { <br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bcab001c6956785d76f54c86fdcfb7d8831">ReadFunctionResponseWhenPresent</a> = 0, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bca5fb91c7616dbb0c1beada4b537fa8bb2">ReadFunctionResponseWhenDesired</a> = 1, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bca8c17152bb67546ee86b478376ce312f2">ReadFunctionResponseAlways</a> = 2
<br />
 }<tr class="memdesc:a101a273254d6d1b343a7042ffe0d68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logic of when ST8 has to be read during execution of function.  <a href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a101a273254d6d1b343a7042ffe0d68bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6db7136fb0112a71d300490bb5dc9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#ab1b6db7136fb0112a71d300490bb5dc9a1e3ae80bbb9f1ead7589eed8f0d5fbe6">READ_SERVICE_OVERHEAD</a> = 4, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#ab1b6db7136fb0112a71d300490bb5dc9a6e702878fd0384ba6715e15c73ca9d4c">WRITE_SERVICE_OVERHEAD</a> = 7, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#ab1b6db7136fb0112a71d300490bb5dc9ab50d26ac1350dfd7835640f8f7693872">PARTIAL_WRITE_SERVICE_OVERHEAD</a> = 9
<br />
 }</td></tr>
<tr class="separator:ab1b6db7136fb0112a71d300490bb5dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:acb2efd86856570ae339320ade2841e70 inherit pub_types_class_m_protocol"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a7df75f2423de285046975aa2c250fa06">MAXIMUM_NUMBER_STRING_SIZE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70acd2b89f18226e2b07f46691300abae70">MAXIMUM_SERVICE_NAME_STRING_SIZE</a> = MAXIMUM_NUMBER_STRING_SIZE + 64, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a> = 0x1000, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a7a2476e18495e7f0be160468bfea5d73">MAXIMUM_POSSIBLE_TABLE_OFFSET</a> = 0xFFFFFF, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a955afe7a1975e8484755ee30010fa6a1">MAXIMUM_POSSIBLE_TABLE_LENGTH</a> = 0xFFFFFF
<br />
 }</td></tr>
<tr class="separator:acb2efd86856570ae339320ade2841e70 inherit pub_types_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48fb8eb277613de30019f264fdeb271 inherit pub_types_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad48fb8eb277613de30019f264fdeb271"></a>
typedef std::vector&lt; <a class="el" href="struct_m_protocol_1_1_table_raw_data.html">TableRawData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a></td></tr>
<tr class="memdesc:ad48fb8eb277613de30019f264fdeb271 inherit pub_types_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of table raw data. <br /></td></tr>
<tr class="separator:ad48fb8eb277613de30019f264fdeb271 inherit pub_types_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a800259ba467f3410801e6c6b3504bb9b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a800259ba467f3410801e6c6b3504bb9b">~MProtocolC12</a> ()</td></tr>
<tr class="memdesc:a800259ba467f3410801e6c6b3504bb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the C12 protocol object.  <a href="#a800259ba467f3410801e6c6b3504bb9b">More...</a><br /></td></tr>
<tr class="separator:a800259ba467f3410801e6c6b3504bb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f2ed24daaec391fb5d71bed3f7c372"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a84f2ed24daaec391fb5d71bed3f7c372">ApplyChannelParameters</a> ()</td></tr>
<tr class="memdesc:a84f2ed24daaec391fb5d71bed3f7c372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the configuration of the channel in a way compatible with ANSI C12 protocol handshake sequence.  <a href="#a84f2ed24daaec391fb5d71bed3f7c372">More...</a><br /></td></tr>
<tr class="separator:a84f2ed24daaec391fb5d71bed3f7c372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca4e7b5d3ae6da1b160b520b2b1728e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a4ca4e7b5d3ae6da1b160b520b2b1728e">Logon</a> ()</td></tr>
<tr class="memdesc:a4ca4e7b5d3ae6da1b160b520b2b1728e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Logon service.  <a href="#a4ca4e7b5d3ae6da1b160b520b2b1728e">More...</a><br /></td></tr>
<tr class="separator:a4ca4e7b5d3ae6da1b160b520b2b1728e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fde8c7dc31790774993c984ea7b403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad6fde8c7dc31790774993c984ea7b403">Security</a> ()</td></tr>
<tr class="memdesc:ad6fde8c7dc31790774993c984ea7b403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Security service.  <a href="#ad6fde8c7dc31790774993c984ea7b403">More...</a><br /></td></tr>
<tr class="separator:ad6fde8c7dc31790774993c984ea7b403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2e3350005bee20e6ffd9bd39f875a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a87b2e3350005bee20e6ffd9bd39f875a">FullLogin</a> ()</td></tr>
<tr class="memdesc:a87b2e3350005bee20e6ffd9bd39f875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform whatever is required by the protocol to clear security with the meter.  <a href="#a87b2e3350005bee20e6ffd9bd39f875a">More...</a><br /></td></tr>
<tr class="separator:a87b2e3350005bee20e6ffd9bd39f875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeedd60972e30daaa70274dcab5dd33d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aeeedd60972e30daaa70274dcab5dd33d">Logoff</a> ()</td></tr>
<tr class="memdesc:aeeedd60972e30daaa70274dcab5dd33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Logoff service.  <a href="#aeeedd60972e30daaa70274dcab5dd33d">More...</a><br /></td></tr>
<tr class="separator:aeeedd60972e30daaa70274dcab5dd33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2037a107e2308035f797ec0c702a2428"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a2037a107e2308035f797ec0c702a2428">Wait</a> (unsigned seconds)</td></tr>
<tr class="memdesc:a2037a107e2308035f797ec0c702a2428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Wait service.  <a href="#a2037a107e2308035f797ec0c702a2428">More...</a><br /></td></tr>
<tr class="separator:a2037a107e2308035f797ec0c702a2428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee47d2594f1c05ba4d48334d77ec93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a47ee47d2594f1c05ba4d48334d77ec93">Terminate</a> ()</td></tr>
<tr class="memdesc:a47ee47d2594f1c05ba4d48334d77ec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Terminate service.  <a href="#a47ee47d2594f1c05ba4d48334d77ec93">More...</a><br /></td></tr>
<tr class="separator:a47ee47d2594f1c05ba4d48334d77ec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad781dfc93f91866eb9ac2865ce9c0e1c"><td class="memItemLeft" align="right" valign="top">virtual Muint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad781dfc93f91866eb9ac2865ce9c0e1c">CalculateCRC16FromBuffer</a> (const char *buffer, unsigned length) const </td></tr>
<tr class="memdesc:ad781dfc93f91866eb9ac2865ce9c0e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-byte CRC calculation procedure specific to C12 protocol.  <a href="#ad781dfc93f91866eb9ac2865ce9c0e1c">More...</a><br /></td></tr>
<tr class="separator:ad781dfc93f91866eb9ac2865ce9c0e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6781d4aa9fae4b507dd76b70a00f7ac3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a6781d4aa9fae4b507dd76b70a00f7ac3">GetMaximumReadTableSize</a> () const </td></tr>
<tr class="memdesc:a6781d4aa9fae4b507dd76b70a00f7ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum possible size of a table to read partially or fully in a single application layer packet.  <a href="#a6781d4aa9fae4b507dd76b70a00f7ac3">More...</a><br /></td></tr>
<tr class="separator:a6781d4aa9fae4b507dd76b70a00f7ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00383e3d04e77b0f4331efd1e1a7bc51"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a00383e3d04e77b0f4331efd1e1a7bc51">CalculateChecksumFromBuffer</a> (const char *buffer, unsigned length) const </td></tr>
<tr class="memdesc:a00383e3d04e77b0f4331efd1e1a7bc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent one-byte checksum calculation procedure that uses buffer and its size.  <a href="#a00383e3d04e77b0f4331efd1e1a7bc51">More...</a><br /></td></tr>
<tr class="separator:a00383e3d04e77b0f4331efd1e1a7bc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b6dceb2e6e519d524e03ef812d11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#add7b6dceb2e6e519d524e03ef812d11a">ApplicationLayerRequestResponse</a> (char command, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:add7b6dceb2e6e519d524e03ef812d11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the full application layer request and return a response.  <a href="#add7b6dceb2e6e519d524e03ef812d11a">More...</a><br /></td></tr>
<tr class="separator:add7b6dceb2e6e519d524e03ef812d11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e449f54f53f85ec3e86026d1f2f874"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a80e449f54f53f85ec3e86026d1f2f874">ReceiveServiceCode</a> ()</td></tr>
<tr class="memdesc:a80e449f54f53f85ec3e86026d1f2f874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a code of the incoming application layer data packet.  <a href="#a80e449f54f53f85ec3e86026d1f2f874">More...</a><br /></td></tr>
<tr class="separator:a80e449f54f53f85ec3e86026d1f2f874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c52d5cf88970f3d7b9af93329c4afd"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a03c52d5cf88970f3d7b9af93329c4afd">ReceiveServiceByte</a> ()</td></tr>
<tr class="memdesc:a03c52d5cf88970f3d7b9af93329c4afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte from the incoming application layer data packet.  <a href="#a03c52d5cf88970f3d7b9af93329c4afd">More...</a><br /></td></tr>
<tr class="separator:a03c52d5cf88970f3d7b9af93329c4afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf12a9c3e16baf235353f449be5b77ab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#adf12a9c3e16baf235353f449be5b77ab">ReceiveServiceUInt</a> (unsigned size)</td></tr>
<tr class="memdesc:adf12a9c3e16baf235353f449be5b77ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several bytes from the incoming application layer data packet.  <a href="#adf12a9c3e16baf235353f449be5b77ab">More...</a><br /></td></tr>
<tr class="separator:adf12a9c3e16baf235353f449be5b77ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b92f863b59fcac9b865a39b41a66dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad6b92f863b59fcac9b865a39b41a66dd">ReceiveServiceBytes</a> (unsigned length)</td></tr>
<tr class="memdesc:ad6b92f863b59fcac9b865a39b41a66dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several bytes of the incoming application layer data packet.  <a href="#ad6b92f863b59fcac9b865a39b41a66dd">More...</a><br /></td></tr>
<tr class="separator:ad6b92f863b59fcac9b865a39b41a66dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5602d36bc610094386de8122b4d9f05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a5602d36bc610094386de8122b4d9f05f">ReceiveServiceRemainingBytes</a> ()</td></tr>
<tr class="memdesc:a5602d36bc610094386de8122b4d9f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes of the incoming application layer data packet.  <a href="#a5602d36bc610094386de8122b4d9f05f">More...</a><br /></td></tr>
<tr class="separator:a5602d36bc610094386de8122b4d9f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a83cbf50c3fe4c8b5f882d3d6c41f860c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a83cbf50c3fe4c8b5f882d3d6c41f860c">GetLinkLayerRetries</a> () const </td></tr>
<tr class="separator:a83cbf50c3fe4c8b5f882d3d6c41f860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081e76c597fce9b27afb371dcb196397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a081e76c597fce9b27afb371dcb196397">SetLinkLayerRetries</a> (unsigned retries)</td></tr>
<tr class="separator:a081e76c597fce9b27afb371dcb196397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac72abca6518a456402fddb87c57cc1dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ac72abca6518a456402fddb87c57cc1dc">GetIssueSecurityOnStartSession</a> () const </td></tr>
<tr class="separator:ac72abca6518a456402fddb87c57cc1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ba7c99bbbe38cb5ba6775b4f2bfe96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ae4ba7c99bbbe38cb5ba6775b4f2bfe96">SetIssueSecurityOnStartSession</a> (bool)</td></tr>
<tr class="separator:ae4ba7c99bbbe38cb5ba6775b4f2bfe96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6315b81d46343250904f858044458d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a6315b81d46343250904f858044458d76">GetAlwaysReadFunctionResponse</a> () const </td></tr>
<tr class="separator:a6315b81d46343250904f858044458d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a414d2e935e1a733fc0422a26cc59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad40a414d2e935e1a733fc0422a26cc59">SetAlwaysReadFunctionResponse</a> (<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a> value)</td></tr>
<tr class="separator:ad40a414d2e935e1a733fc0422a26cc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1e53a70a87fd5762faa9343d94e90651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a1e53a70a87fd5762faa9343d94e90651">GetAlwaysUsePartial</a> () const </td></tr>
<tr class="separator:a1e53a70a87fd5762faa9343d94e90651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e1a04ca84321239b78e4b77e748950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a94e1a04ca84321239b78e4b77e748950">SetAlwaysUsePartial</a> (bool yes)</td></tr>
<tr class="separator:a94e1a04ca84321239b78e4b77e748950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a146ef42e1040bd735fa82bb97d7f893b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a146ef42e1040bd735fa82bb97d7f893b">GetUseReadInKeepSessionAlive</a> () const </td></tr>
<tr class="separator:a146ef42e1040bd735fa82bb97d7f893b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a43f1026237f4b14d8e2b553123b53b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a9a43f1026237f4b14d8e2b553123b53b">SetUseReadInKeepSessionAlive</a> (bool yes)</td></tr>
<tr class="separator:a9a43f1026237f4b14d8e2b553123b53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02e79193a4c47c45f7d70fb6f4e824a3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a02e79193a4c47c45f7d70fb6f4e824a3">GetUserId</a> () const </td></tr>
<tr class="separator:a02e79193a4c47c45f7d70fb6f4e824a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a00abedf0f78c28ca860e7e4b7eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#abd0a00abedf0f78c28ca860e7e4b7eb2">SetUserId</a> (unsigned userId)</td></tr>
<tr class="separator:abd0a00abedf0f78c28ca860e7e4b7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab743cbb677afa0790653f03698b9850e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ab743cbb677afa0790653f03698b9850e">GetUser</a> () const </td></tr>
<tr class="separator:ab743cbb677afa0790653f03698b9850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c52a6b797045c8fb739a2d512ad3d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad6c52a6b797045c8fb739a2d512ad3d6">SetUser</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;userName)</td></tr>
<tr class="separator:ad6c52a6b797045c8fb739a2d512ad3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aba17f8b403b824f484d56872640ceb83"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aba17f8b403b824f484d56872640ceb83">GetTurnAroundDelay</a> () const </td></tr>
<tr class="separator:aba17f8b403b824f484d56872640ceb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364147a8f5d419e7555dccda9ae8c0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a364147a8f5d419e7555dccda9ae8c0eb">SetTurnAroundDelay</a> (unsigned delay)</td></tr>
<tr class="separator:a364147a8f5d419e7555dccda9ae8c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a68720d1a83fe953d500e259cd3c25f37"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a68720d1a83fe953d500e259cd3c25f37">GetApplicationLayerRetries</a> () const </td></tr>
<tr class="separator:a68720d1a83fe953d500e259cd3c25f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1492dc4303aaba34492ae85f7b9f2098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a1492dc4303aaba34492ae85f7b9f2098">SetApplicationLayerRetries</a> (unsigned retries)</td></tr>
<tr class="separator:a1492dc4303aaba34492ae85f7b9f2098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ade7c2380742033d82f2f2a73a5cbb3fb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ade7c2380742033d82f2f2a73a5cbb3fb">GetApplicationLayerRetryDelay</a> () const </td></tr>
<tr class="separator:ade7c2380742033d82f2f2a73a5cbb3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bceb67a0c9486070dbb02b9b3f6982c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a6bceb67a0c9486070dbb02b9b3f6982c">SetApplicationLayerRetryDelay</a> (unsigned milliseconds)</td></tr>
<tr class="separator:a6bceb67a0c9486070dbb02b9b3f6982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af584c3e57c6bc43ef22ea6ec4307d237"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#af584c3e57c6bc43ef22ea6ec4307d237">GetApplicationLayerProcedureRetries</a> () const </td></tr>
<tr class="separator:af584c3e57c6bc43ef22ea6ec4307d237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb6a66e89731e89b4c812f78e4d2c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a4eb6a66e89731e89b4c812f78e4d2c57">SetApplicationLayerProcedureRetries</a> (unsigned retries)</td></tr>
<tr class="separator:a4eb6a66e89731e89b4c812f78e4d2c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67ca720e8642357c5ea508438699883b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a67ca720e8642357c5ea508438699883b">GetApplicationLayerProcedureRetryDelay</a> () const </td></tr>
<tr class="separator:a67ca720e8642357c5ea508438699883b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca28f4ac408b77fc27c7b2b9b88422d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aca28f4ac408b77fc27c7b2b9b88422d5">SetApplicationLayerProcedureRetryDelay</a> (unsigned milliseconds)</td></tr>
<tr class="separator:aca28f4ac408b77fc27c7b2b9b88422d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d19806287de5f72638af728763bb2ed"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a1d19806287de5f72638af728763bb2ed">GetProcedureSequenceNumber</a> () const </td></tr>
<tr class="separator:a1d19806287de5f72638af728763bb2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711c67714f108b262fe7c5de9021311e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a711c67714f108b262fe7c5de9021311e">SetProcedureSequenceNumber</a> (unsigned number)</td></tr>
<tr class="separator:a711c67714f108b262fe7c5de9021311e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abd1a5e69e3c698e7e0f232191513eb79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#abd1a5e69e3c698e7e0f232191513eb79">SetEndSessionOnApplicationLayerError</a> (bool endSessionOnApplicationLayerError)</td></tr>
<tr class="separator:abd1a5e69e3c698e7e0f232191513eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf83a00802dc74fc07448f43daa944d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a9cf83a00802dc74fc07448f43daa944d">GetEndSessionOnApplicationLayerError</a> () const </td></tr>
<tr class="separator:a9cf83a00802dc74fc07448f43daa944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:a2c41fddbb0e3418dc453981c6136028a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_protocol.html">MProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2c41fddbb0e3418dc453981c6136028a">CreateClone</a> () const </td></tr>
<tr class="memdesc:a2c41fddbb0e3418dc453981c6136028a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual copy constructor, creates the protocol which is a clone of current.  <a href="#a2c41fddbb0e3418dc453981c6136028a">More...</a><br /></td></tr>
<tr class="separator:a2c41fddbb0e3418dc453981c6136028a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86685e09ca825849a21b6818c0d2115e inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a86685e09ca825849a21b6818c0d2115e">~MProtocol</a> ()=0</td></tr>
<tr class="memdesc:a86685e09ca825849a21b6818c0d2115e inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the protocol object.  <a href="#a86685e09ca825849a21b6818c0d2115e">More...</a><br /></td></tr>
<tr class="separator:a86685e09ca825849a21b6818c0d2115e inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6479689e3e13a1a11a34b64da99f51 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a3a6479689e3e13a1a11a34b64da99f51">Finalize</a> ()</td></tr>
<tr class="memdesc:a3a6479689e3e13a1a11a34b64da99f51 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute this method as first action in the destructor of any child protocol.  <a href="#a3a6479689e3e13a1a11a34b64da99f51">More...</a><br /></td></tr>
<tr class="separator:a3a6479689e3e13a1a11a34b64da99f51 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367a451ecf3e98ef7363fa98e53e6add inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a367a451ecf3e98ef7363fa98e53e6add">GetCountApplicationLayerServicesSuccessful</a> () const </td></tr>
<tr class="memdesc:a367a451ecf3e98ef7363fa98e53e6add inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have been successfully processed.  <a href="#a367a451ecf3e98ef7363fa98e53e6add">More...</a><br /></td></tr>
<tr class="separator:a367a451ecf3e98ef7363fa98e53e6add inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25fc291953561e4eb248174bc07856e inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af25fc291953561e4eb248174bc07856e">IncrementCountApplicationLayerServicesSuccessful</a> ()</td></tr>
<tr class="memdesc:af25fc291953561e4eb248174bc07856e inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services successfully processed.  <a href="#af25fc291953561e4eb248174bc07856e">More...</a><br /></td></tr>
<tr class="separator:af25fc291953561e4eb248174bc07856e inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab290272e66fd881e1d67010d44451376 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab290272e66fd881e1d67010d44451376">GetCountApplicationLayerServicesRetried</a> () const </td></tr>
<tr class="memdesc:ab290272e66fd881e1d67010d44451376 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have been retried.  <a href="#ab290272e66fd881e1d67010d44451376">More...</a><br /></td></tr>
<tr class="separator:ab290272e66fd881e1d67010d44451376 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c110d281bbb7779b7bbbfc12b5b1d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae57c110d281bbb7779b7bbbfc12b5b1d">IncrementCountApplicationLayerServicesRetried</a> ()</td></tr>
<tr class="memdesc:ae57c110d281bbb7779b7bbbfc12b5b1d inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services retried.  <a href="#ae57c110d281bbb7779b7bbbfc12b5b1d">More...</a><br /></td></tr>
<tr class="separator:ae57c110d281bbb7779b7bbbfc12b5b1d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ad7accc31c929f4a4b8ff4fbc13549 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a17ad7accc31c929f4a4b8ff4fbc13549">GetCountApplicationLayerServicesFailed</a> () const </td></tr>
<tr class="memdesc:a17ad7accc31c929f4a4b8ff4fbc13549 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have failed.  <a href="#a17ad7accc31c929f4a4b8ff4fbc13549">More...</a><br /></td></tr>
<tr class="separator:a17ad7accc31c929f4a4b8ff4fbc13549 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bffec5063153017e67fdd4d667f5cb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a60bffec5063153017e67fdd4d667f5cb">IncrementCountApplicationLayerServicesFailed</a> ()</td></tr>
<tr class="memdesc:a60bffec5063153017e67fdd4d667f5cb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services failed.  <a href="#a60bffec5063153017e67fdd4d667f5cb">More...</a><br /></td></tr>
<tr class="separator:a60bffec5063153017e67fdd4d667f5cb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ba7737c1a7033a784e732539fd442 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a425ba7737c1a7033a784e732539fd442">GetCountLinkLayerPacketsSuccessful</a> () const </td></tr>
<tr class="memdesc:a425ba7737c1a7033a784e732539fd442 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Link Layer packets that have been successfully processed.  <a href="#a425ba7737c1a7033a784e732539fd442">More...</a><br /></td></tr>
<tr class="separator:a425ba7737c1a7033a784e732539fd442 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735e02e29d2dd177059a8cdc15eb6a71 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a735e02e29d2dd177059a8cdc15eb6a71">IncrementCountLinkLayerPacketsSuccessful</a> ()</td></tr>
<tr class="memdesc:a735e02e29d2dd177059a8cdc15eb6a71 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets successfully processed.  <a href="#a735e02e29d2dd177059a8cdc15eb6a71">More...</a><br /></td></tr>
<tr class="separator:a735e02e29d2dd177059a8cdc15eb6a71 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab563dd4909235f42bf80bd5a7d77e05b inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab563dd4909235f42bf80bd5a7d77e05b">GetCountLinkLayerPacketsRetried</a> () const </td></tr>
<tr class="memdesc:ab563dd4909235f42bf80bd5a7d77e05b inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Link Layer packets that have been retried.  <a href="#ab563dd4909235f42bf80bd5a7d77e05b">More...</a><br /></td></tr>
<tr class="separator:ab563dd4909235f42bf80bd5a7d77e05b inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970a90af9476866a8e6b39dbef89c627 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a970a90af9476866a8e6b39dbef89c627">IncrementCountLinkLayerPacketsRetried</a> ()</td></tr>
<tr class="memdesc:a970a90af9476866a8e6b39dbef89c627 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets retried.  <a href="#a970a90af9476866a8e6b39dbef89c627">More...</a><br /></td></tr>
<tr class="separator:a970a90af9476866a8e6b39dbef89c627 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d9dd2722b89549334dbf3ea785052a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80d9dd2722b89549334dbf3ea785052a">GetCountLinkLayerPacketsFailed</a> () const </td></tr>
<tr class="memdesc:a80d9dd2722b89549334dbf3ea785052a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of data link layer packets failed.  <a href="#a80d9dd2722b89549334dbf3ea785052a">More...</a><br /></td></tr>
<tr class="separator:a80d9dd2722b89549334dbf3ea785052a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c162f21b2b82300532288a630238cbd inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0c162f21b2b82300532288a630238cbd">IncrementCountLinkLayerPacketsFailed</a> ()</td></tr>
<tr class="memdesc:a0c162f21b2b82300532288a630238cbd inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets failed.  <a href="#a0c162f21b2b82300532288a630238cbd">More...</a><br /></td></tr>
<tr class="separator:a0c162f21b2b82300532288a630238cbd inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86283365bd46d047e5dbc0048b7b00cd inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a> () const </td></tr>
<tr class="memdesc:a86283365bd46d047e5dbc0048b7b00cd inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum measured approximate packet round trip time over the link layer.  <a href="#a86283365bd46d047e5dbc0048b7b00cd">More...</a><br /></td></tr>
<tr class="separator:a86283365bd46d047e5dbc0048b7b00cd inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1d46c353f5e4f8cac3bf8ed8dc7a2 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a> () const </td></tr>
<tr class="memdesc:af1d1d46c353f5e4f8cac3bf8ed8dc7a2 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum measured approximate packet round trip time over the link layer.  <a href="#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">More...</a><br /></td></tr>
<tr class="separator:af1d1d46c353f5e4f8cac3bf8ed8dc7a2 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45ec72043fe42c32b414d1448fab12 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a> () const </td></tr>
<tr class="memdesc:a9b45ec72043fe42c32b414d1448fab12 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the average measured approximate packet round trip time over the link layer.  <a href="#a9b45ec72043fe42c32b414d1448fab12">More...</a><br /></td></tr>
<tr class="separator:a9b45ec72043fe42c32b414d1448fab12 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d5080403580f3317fc9eade19882d4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a02d5080403580f3317fc9eade19882d4">ClearPasswordList</a> ()</td></tr>
<tr class="memdesc:a02d5080403580f3317fc9eade19882d4 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the password list for the protocol to none, so the <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> property is used.  <a href="#a02d5080403580f3317fc9eade19882d4">More...</a><br /></td></tr>
<tr class="separator:a02d5080403580f3317fc9eade19882d4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5483f327ca2dcb745fdb14494848fa01 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5483f327ca2dcb745fdb14494848fa01">AddToPasswordList</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;password)</td></tr>
<tr class="memdesc:a5483f327ca2dcb745fdb14494848fa01 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a password to the password list.  <a href="#a5483f327ca2dcb745fdb14494848fa01">More...</a><br /></td></tr>
<tr class="separator:a5483f327ca2dcb745fdb14494848fa01 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b038b23f879820284d27f3ecc3768 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a699b038b23f879820284d27f3ecc3768">GetPasswordListSuccessfulEntry</a> () const </td></tr>
<tr class="memdesc:a699b038b23f879820284d27f3ecc3768 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry, which was successfully tried with the meter.  <a href="#a699b038b23f879820284d27f3ecc3768">More...</a><br /></td></tr>
<tr class="separator:a699b038b23f879820284d27f3ecc3768 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb502e0b67a62153f70d818e0fec138a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> ()</td></tr>
<tr class="memdesc:adb502e0b67a62153f70d818e0fec138a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the statistical data for the channel.  <a href="#adb502e0b67a62153f70d818e0fec138a">More...</a><br /></td></tr>
<tr class="separator:adb502e0b67a62153f70d818e0fec138a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb24a5372b721c343add6ae803287e94 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94">Connect</a> ()</td></tr>
<tr class="memdesc:adb24a5372b721c343add6ae803287e94 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the channel and establishes the connection with the peer.  <a href="#adb24a5372b721c343add6ae803287e94">More...</a><br /></td></tr>
<tr class="separator:adb24a5372b721c343add6ae803287e94 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c328afee944e7e977092b8da2887f8 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8">Disconnect</a> ()</td></tr>
<tr class="memdesc:a72c328afee944e7e977092b8da2887f8 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Severs the connection between the computer and the end device.  <a href="#a72c328afee944e7e977092b8da2887f8">More...</a><br /></td></tr>
<tr class="separator:a72c328afee944e7e977092b8da2887f8 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c53c968bd097ffaddee8fb679a3f9d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a26c53c968bd097ffaddee8fb679a3f9d">IsConnected</a> () const </td></tr>
<tr class="memdesc:a26c53c968bd097ffaddee8fb679a3f9d inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the protocol is currently connected.  <a href="#a26c53c968bd097ffaddee8fb679a3f9d">More...</a><br /></td></tr>
<tr class="separator:a26c53c968bd097ffaddee8fb679a3f9d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290983a74af9495c1a5f66d7e1d4b823 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a> () const </td></tr>
<tr class="memdesc:a290983a74af9495c1a5f66d7e1d4b823 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the protocol is in session.  <a href="#a290983a74af9495c1a5f66d7e1d4b823">More...</a><br /></td></tr>
<tr class="separator:a290983a74af9495c1a5f66d7e1d4b823 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1a1eeb1e19a54b2061e276d7248556 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_action.html">MProgressAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5f1a1eeb1e19a54b2061e276d7248556">CreateRootProgressAction</a> ()</td></tr>
<tr class="memdesc:a5f1a1eeb1e19a54b2061e276d7248556 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create root of the progress actions hierarchy.  <a href="#a5f1a1eeb1e19a54b2061e276d7248556">More...</a><br /></td></tr>
<tr class="separator:a5f1a1eeb1e19a54b2061e276d7248556 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace692f1af6dbb0a33512f5582adec430 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_action.html">MProgressAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ace692f1af6dbb0a33512f5582adec430">GetLocalProgressAction</a> ()</td></tr>
<tr class="memdesc:ace692f1af6dbb0a33512f5582adec430 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the currently preset local action in progress monitor.  <a href="#ace692f1af6dbb0a33512f5582adec430">More...</a><br /></td></tr>
<tr class="separator:ace692f1af6dbb0a33512f5582adec430 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73d91a5b3aeec57221ca2ee0cdbef00 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> () const </td></tr>
<tr class="memdesc:ac73d91a5b3aeec57221ca2ee0cdbef00 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not it is time to call QCommit(true) in order to sync with the background thread.  <a href="#ac73d91a5b3aeec57221ca2ee0cdbef00">More...</a><br /></td></tr>
<tr class="separator:ac73d91a5b3aeec57221ca2ee0cdbef00 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002f961375678606b6e281a624db996 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6002f961375678606b6e281a624db996">QIsBackgroundCommunicationProgressing</a> () const </td></tr>
<tr class="memdesc:a6002f961375678606b6e281a624db996 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the background communication is still progressing.  <a href="#a6002f961375678606b6e281a624db996">More...</a><br /></td></tr>
<tr class="separator:a6002f961375678606b6e281a624db996 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35ae0e64619dfc237c154a44ec578c1 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> ()</td></tr>
<tr class="memdesc:ac35ae0e64619dfc237c154a44ec578c1 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines <a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> with the following <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> in case all commands in the queue have been sent.  <a href="#ac35ae0e64619dfc237c154a44ec578c1">More...</a><br /></td></tr>
<tr class="separator:ac35ae0e64619dfc237c154a44ec578c1 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918229482eba7cf7a7901dae6c3796cb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> ()</td></tr>
<tr class="memdesc:a918229482eba7cf7a7901dae6c3796cb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the commands in the queue, or cancel the ongoing background communication.  <a href="#a918229482eba7cf7a7901dae6c3796cb">More...</a><br /></td></tr>
<tr class="separator:a918229482eba7cf7a7901dae6c3796cb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7480f82e6934a8535760cf325af5bb35 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7480f82e6934a8535760cf325af5bb35">QWriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a7480f82e6934a8535760cf325af5bb35 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the message to write to the Monitor log file to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a7480f82e6934a8535760cf325af5bb35">More...</a><br /></td></tr>
<tr class="separator:a7480f82e6934a8535760cf325af5bb35 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ade785b2e4da0b69c4aadeffc82942 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">QConnect</a> ()</td></tr>
<tr class="memdesc:a68ade785b2e4da0b69c4aadeffc82942 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a Connect command in the queue.  <a href="#a68ade785b2e4da0b69c4aadeffc82942">More...</a><br /></td></tr>
<tr class="separator:a68ade785b2e4da0b69c4aadeffc82942 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474d3857824f0fa028644556d0a09ca0 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a474d3857824f0fa028644556d0a09ca0">QDisconnect</a> ()</td></tr>
<tr class="memdesc:a474d3857824f0fa028644556d0a09ca0 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a Disconnect command in the queue.  <a href="#a474d3857824f0fa028644556d0a09ca0">More...</a><br /></td></tr>
<tr class="separator:a474d3857824f0fa028644556d0a09ca0 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c0c4e13e1a1a616be8ad1e4793290 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ace4c0c4e13e1a1a616be8ad1e4793290">QIdentifyMeter</a> ()</td></tr>
<tr class="memdesc:ace4c0c4e13e1a1a616be8ad1e4793290 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an IdentifyMeter task in the queue.  <a href="#ace4c0c4e13e1a1a616be8ad1e4793290">More...</a><br /></td></tr>
<tr class="separator:ace4c0c4e13e1a1a616be8ad1e4793290 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc217114a8b4928f6d62e13ebf826e7f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afc217114a8b4928f6d62e13ebf826e7f">QStartSession</a> ()</td></tr>
<tr class="memdesc:afc217114a8b4928f6d62e13ebf826e7f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a start session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#afc217114a8b4928f6d62e13ebf826e7f">More...</a><br /></td></tr>
<tr class="separator:afc217114a8b4928f6d62e13ebf826e7f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fc80e08ae3337deac67b5503ae7b77 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a> ()</td></tr>
<tr class="memdesc:aa1fc80e08ae3337deac67b5503ae7b77 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an end session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#aa1fc80e08ae3337deac67b5503ae7b77">More...</a><br /></td></tr>
<tr class="separator:aa1fc80e08ae3337deac67b5503ae7b77 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99c12375946ef53645de3b3807aa24 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9b99c12375946ef53645de3b3807aa24">QEndSessionNoThrow</a> ()</td></tr>
<tr class="memdesc:a9b99c12375946ef53645de3b3807aa24 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">EndSessionNoThrow request is queued.  <a href="#a9b99c12375946ef53645de3b3807aa24">More...</a><br /></td></tr>
<tr class="separator:a9b99c12375946ef53645de3b3807aa24 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08880e3f2b73a5b0a099514b0a71c93f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a08880e3f2b73a5b0a099514b0a71c93f">QTableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, unsigned expectedSize, int id)</td></tr>
<tr class="memdesc:a08880e3f2b73a5b0a099514b0a71c93f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a ReadTable command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a08880e3f2b73a5b0a099514b0a71c93f">More...</a><br /></td></tr>
<tr class="separator:a08880e3f2b73a5b0a099514b0a71c93f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71251f6cbda5a70e1072e4cf78fcea5c inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a71251f6cbda5a70e1072e4cf78fcea5c">QTableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:a71251f6cbda5a70e1072e4cf78fcea5c inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a71251f6cbda5a70e1072e4cf78fcea5c">More...</a><br /></td></tr>
<tr class="separator:a71251f6cbda5a70e1072e4cf78fcea5c inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a88700905af18de1934453c800ae9d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a36a88700905af18de1934453c800ae9d">QTableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, int size, int id)</td></tr>
<tr class="memdesc:a36a88700905af18de1934453c800ae9d inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a partial table read command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a36a88700905af18de1934453c800ae9d">More...</a><br /></td></tr>
<tr class="separator:a36a88700905af18de1934453c800ae9d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1568dcd0e0af9c30043f9179fc527632 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1568dcd0e0af9c30043f9179fc527632">QTableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a1568dcd0e0af9c30043f9179fc527632 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a partial table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a1568dcd0e0af9c30043f9179fc527632">More...</a><br /></td></tr>
<tr class="separator:a1568dcd0e0af9c30043f9179fc527632 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63adc1ca9487420d0f0d4f397892a6c0 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a63adc1ca9487420d0f0d4f397892a6c0">QFunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a63adc1ca9487420d0f0d4f397892a6c0 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function without data request in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a> command queue.  <a href="#a63adc1ca9487420d0f0d4f397892a6c0">More...</a><br /></td></tr>
<tr class="separator:a63adc1ca9487420d0f0d4f397892a6c0 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ccc940c3f27964397d8fb2072a4cf inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a144ccc940c3f27964397d8fb2072a4cf">QFunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:a144ccc940c3f27964397d8fb2072a4cf inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with request data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a144ccc940c3f27964397d8fb2072a4cf">More...</a><br /></td></tr>
<tr class="separator:a144ccc940c3f27964397d8fb2072a4cf inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df65accadd116253feed8a730c8664 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac8df65accadd116253feed8a730c8664">QFunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id, unsigned estimatedResponseSize=<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a>)</td></tr>
<tr class="memdesc:ac8df65accadd116253feed8a730c8664 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#ac8df65accadd116253feed8a730c8664">More...</a><br /></td></tr>
<tr class="separator:ac8df65accadd116253feed8a730c8664 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0c9d99fb75dc21283a5d3fcdabb68 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af4a0c9d99fb75dc21283a5d3fcdabb68">QFunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request, int id, unsigned estimatedResponseSize=<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a>)</td></tr>
<tr class="memdesc:af4a0c9d99fb75dc21283a5d3fcdabb68 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with request and response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#af4a0c9d99fb75dc21283a5d3fcdabb68">More...</a><br /></td></tr>
<tr class="separator:af4a0c9d99fb75dc21283a5d3fcdabb68 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad16d887101c1e2ef14894201aa75a17 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> (bool asynchronously=false)</td></tr>
<tr class="memdesc:aad16d887101c1e2ef14894201aa75a17 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all operations in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#aad16d887101c1e2ef14894201aa75a17">More...</a><br /></td></tr>
<tr class="separator:aad16d887101c1e2ef14894201aa75a17 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4db8b1de02405df260fbeea22f22d9 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aeb4db8b1de02405df260fbeea22f22d9">QGetTableData</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id=-1)</td></tr>
<tr class="memdesc:aeb4db8b1de02405df260fbeea22f22d9 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the table data after the table read has been successfully performed by QCommit.  <a href="#aeb4db8b1de02405df260fbeea22f22d9">More...</a><br /></td></tr>
<tr class="separator:aeb4db8b1de02405df260fbeea22f22d9 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bdb2f1cfd7ec87d68a588dfeaa58a2 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">QGetFunctionData</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id=-1)</td></tr>
<tr class="memdesc:ac5bdb2f1cfd7ec87d68a588dfeaa58a2 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the function response data after the function has been successfully executed in QCommit.  <a href="#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">More...</a><br /></td></tr>
<tr class="separator:ac5bdb2f1cfd7ec87d68a588dfeaa58a2 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cb0e39b25f7450228ce092b358bf55 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a81cb0e39b25f7450228ce092b358bf55">QGetIdentifyMeterData</a> ()</td></tr>
<tr class="memdesc:a81cb0e39b25f7450228ce092b358bf55 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the identify meter string after the QIdentifyMeter has been successfully performed in QCommit.  <a href="#a81cb0e39b25f7450228ce092b358bf55">More...</a><br /></td></tr>
<tr class="separator:a81cb0e39b25f7450228ce092b358bf55 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4ac84c215dbf8aa29be17a897b2e4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9fb4ac84c215dbf8aa29be17a897b2e4">WriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a9fb4ac84c215dbf8aa29be17a897b2e4 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write a message to the monitor, if it is connected.  <a href="#a9fb4ac84c215dbf8aa29be17a897b2e4">More...</a><br /></td></tr>
<tr class="separator:a9fb4ac84c215dbf8aa29be17a897b2e4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1c1a9ec69a7b146af846d0b4555cc3 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aad1c1a9ec69a7b146af846d0b4555cc3">WriteCountsToMonitor</a> ()</td></tr>
<tr class="memdesc:aad1c1a9ec69a7b146af846d0b4555cc3 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write running values of communication quality counters to monitor.  <a href="#aad1c1a9ec69a7b146af846d0b4555cc3">More...</a><br /></td></tr>
<tr class="separator:aad1c1a9ec69a7b146af846d0b4555cc3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c0bf42b3e983e64f0d47856d9e10d8 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">StartSession</a> ()</td></tr>
<tr class="memdesc:ac9c0bf42b3e983e64f0d47856d9e10d8 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously start the session.  <a href="#ac9c0bf42b3e983e64f0d47856d9e10d8">More...</a><br /></td></tr>
<tr class="separator:ac9c0bf42b3e983e64f0d47856d9e10d8 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c406f96f58b3c72411924f085e0f1 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a614c406f96f58b3c72411924f085e0f1">EndSession</a> ()</td></tr>
<tr class="memdesc:a614c406f96f58b3c72411924f085e0f1 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously end the session.  <a href="#a614c406f96f58b3c72411924f085e0f1">More...</a><br /></td></tr>
<tr class="separator:a614c406f96f58b3c72411924f085e0f1 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061f6255815a1b2bc982bbcb28ac4df4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a061f6255815a1b2bc982bbcb28ac4df4">EndSessionNoThrow</a> ()</td></tr>
<tr class="memdesc:a061f6255815a1b2bc982bbcb28ac4df4 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the session, but do not throw errors.  <a href="#a061f6255815a1b2bc982bbcb28ac4df4">More...</a><br /></td></tr>
<tr class="separator:a061f6255815a1b2bc982bbcb28ac4df4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a325cbf5b8a9df536131dc7aeeb2fb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae0a325cbf5b8a9df536131dc7aeeb2fb">ReadStartByte</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;setOfValidStartBytes, unsigned trafficTimeout)</td></tr>
<tr class="memdesc:ae0a325cbf5b8a9df536131dc7aeeb2fb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the start byte of the packet in a proper way, taking into consideration timeouts and ignoring garbage.  <a href="#ae0a325cbf5b8a9df536131dc7aeeb2fb">More...</a><br /></td></tr>
<tr class="separator:ae0a325cbf5b8a9df536131dc7aeeb2fb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9f1af7c99107d64f498f4b2b3a04cb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0b9f1af7c99107d64f498f4b2b3a04cb">TableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:a0b9f1af7c99107d64f498f4b2b3a04cb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter.  <a href="#a0b9f1af7c99107d64f498f4b2b3a04cb">More...</a><br /></td></tr>
<tr class="separator:a0b9f1af7c99107d64f498f4b2b3a04cb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ceef5e13fc8328e914f3a85fa3a4b6 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a97ceef5e13fc8328e914f3a85fa3a4b6">TableReadBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, void *buff, unsigned size)</td></tr>
<tr class="memdesc:a97ceef5e13fc8328e914f3a85fa3a4b6 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadTable, but instead of returning a byte string, read table into a given buffer.  <a href="#a97ceef5e13fc8328e914f3a85fa3a4b6">More...</a><br /></td></tr>
<tr class="separator:a97ceef5e13fc8328e914f3a85fa3a4b6 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac626edc816da38de4579137d15088420">TableReadBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, T &amp;table)</td></tr>
<tr class="memdesc:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadTable, but instead of returning a byte string, read table into a given template variable.  <a href="#ac626edc816da38de4579137d15088420">More...</a><br /></td></tr>
<tr class="separator:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6e3cb40e08cc7a1928f424235e12a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad5b6e3cb40e08cc7a1928f424235e12a">TableReadNoThrow</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="class_m_exception.html">MException</a> **exception, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:ad5b6e3cb40e08cc7a1928f424235e12a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter, do not throw an exception, but rather return it.  <a href="#ad5b6e3cb40e08cc7a1928f424235e12a">More...</a><br /></td></tr>
<tr class="separator:ad5b6e3cb40e08cc7a1928f424235e12a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40474bd501a7a79eaa8a858db378818 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae40474bd501a7a79eaa8a858db378818">TableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:ae40474bd501a7a79eaa8a858db378818 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write the whole table with number given as parameter.  <a href="#ae40474bd501a7a79eaa8a858db378818">More...</a><br /></td></tr>
<tr class="separator:ae40474bd501a7a79eaa8a858db378818 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25225dab2e96159a2e87ccf4a3f98ff5 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a25225dab2e96159a2e87ccf4a3f98ff5">TableWriteBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const void *data, unsigned size)</td></tr>
<tr class="memdesc:a25225dab2e96159a2e87ccf4a3f98ff5 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWrite, but uses buffer, given as data and size parameters.  <a href="#a25225dab2e96159a2e87ccf4a3f98ff5">More...</a><br /></td></tr>
<tr class="separator:a25225dab2e96159a2e87ccf4a3f98ff5 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a70c91ea9cb634f292ba182dfad1eb67c">TableWriteBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const T &amp;table)</td></tr>
<tr class="memdesc:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as WriteTable, but uses variable of some specific template class or structure.  <a href="#a70c91ea9cb634f292ba182dfad1eb67c">More...</a><br /></td></tr>
<tr class="separator:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07064801f4387790bc0aa0ec8a4fbb21 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a07064801f4387790bc0aa0ec8a4fbb21">TableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, int size)</td></tr>
<tr class="memdesc:a07064801f4387790bc0aa0ec8a4fbb21 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read part of the table with number given as parameter.  <a href="#a07064801f4387790bc0aa0ec8a4fbb21">More...</a><br /></td></tr>
<tr class="separator:a07064801f4387790bc0aa0ec8a4fbb21 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7d366d9d1f297b52e7baf2bc7ac24b inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#acf7d366d9d1f297b52e7baf2bc7ac24b">TableReadPartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, void *buff, unsigned size)</td></tr>
<tr class="memdesc:acf7d366d9d1f297b52e7baf2bc7ac24b inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableReadPartial, but instead of returning a byte string, read table into a given buffer.  <a href="#acf7d366d9d1f297b52e7baf2bc7ac24b">More...</a><br /></td></tr>
<tr class="separator:acf7d366d9d1f297b52e7baf2bc7ac24b inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2f275facac5ad95bb8ce4e6df7044008">TableReadPartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, T &amp;table, int offset)</td></tr>
<tr class="memdesc:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableReadPartial, but instead of returning a byte string, partially read table into a given template variable.  <a href="#a2f275facac5ad95bb8ce4e6df7044008">More...</a><br /></td></tr>
<tr class="separator:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d15c7e39f18cc7d77067ecb5aa0d020 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7d15c7e39f18cc7d77067ecb5aa0d020">TableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a7d15c7e39f18cc7d77067ecb5aa0d020 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write part of the table with number given as parameter.  <a href="#a7d15c7e39f18cc7d77067ecb5aa0d020">More...</a><br /></td></tr>
<tr class="separator:a7d15c7e39f18cc7d77067ecb5aa0d020 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582cc6901f859085d97ae69aca60ac7 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1582cc6901f859085d97ae69aca60ac7">TableWritePartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, const void *buff, unsigned size)</td></tr>
<tr class="memdesc:a1582cc6901f859085d97ae69aca60ac7 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWritePartial, but instead of using a byte string, write table using a given buffer.  <a href="#a1582cc6901f859085d97ae69aca60ac7">More...</a><br /></td></tr>
<tr class="separator:a1582cc6901f859085d97ae69aca60ac7 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af8010cabbebd86ff8775a5f7d82711d3">TableWritePartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const T &amp;table, int offset)</td></tr>
<tr class="memdesc:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWritePartial, but instead of using a byte string, write table using a given template class contents.  <a href="#af8010cabbebd86ff8775a5f7d82711d3">More...</a><br /></td></tr>
<tr class="separator:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a528fb6f70b4baba1485062c74f3523 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7a528fb6f70b4baba1485062c74f3523">FunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a7a528fb6f70b4baba1485062c74f3523 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with no parameters, the number of the function is given as parameter.  <a href="#a7a528fb6f70b4baba1485062c74f3523">More...</a><br /></td></tr>
<tr class="separator:a7a528fb6f70b4baba1485062c74f3523 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12a2ba50f66f04f0d509b95be684e14 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad12a2ba50f66f04f0d509b95be684e14">FunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:ad12a2ba50f66f04f0d509b95be684e14 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request data, the number of the function is given as parameter.  <a href="#ad12a2ba50f66f04f0d509b95be684e14">More...</a><br /></td></tr>
<tr class="separator:ad12a2ba50f66f04f0d509b95be684e14 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b90e2cd8076ffa77c7c3684fb3b580 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a24b90e2cd8076ffa77c7c3684fb3b580">FunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a24b90e2cd8076ffa77c7c3684fb3b580 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with response data, the number of the function is given as parameter.  <a href="#a24b90e2cd8076ffa77c7c3684fb3b580">More...</a><br /></td></tr>
<tr class="separator:a24b90e2cd8076ffa77c7c3684fb3b580 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda3777c6b76d297bcde7e97ea960623 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afda3777c6b76d297bcde7e97ea960623">FunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:afda3777c6b76d297bcde7e97ea960623 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request and response data, the number of the function is given as parameter.  <a href="#afda3777c6b76d297bcde7e97ea960623">More...</a><br /></td></tr>
<tr class="separator:afda3777c6b76d297bcde7e97ea960623 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1fa960c9550b02aa815a4cc2ec1f5a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6a1fa960c9550b02aa815a4cc2ec1f5a">GetNumberOfDataLinkPackets</a> (MCommunicationCommand::CommandType typeOfRequest, unsigned applicationLayerDataSize=0)</td></tr>
<tr class="memdesc:a6a1fa960c9550b02aa815a4cc2ec1f5a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of data link packets that are required for a given request, provided an optional size of the application data.  <a href="#a6a1fa960c9550b02aa815a4cc2ec1f5a">More...</a><br /></td></tr>
<tr class="separator:a6a1fa960c9550b02aa815a4cc2ec1f5a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153d408f472c69796e0653a3d6aa8a88 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a153d408f472c69796e0653a3d6aa8a88">IdentifyMeterWithContext</a> (bool sessionIsStarted=false, <a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *tablesRead=NULL)</td></tr>
<tr class="memdesc:a153d408f472c69796e0653a3d6aa8a88 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command).  <a href="#a153d408f472c69796e0653a3d6aa8a88">More...</a><br /></td></tr>
<tr class="separator:a153d408f472c69796e0653a3d6aa8a88 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133e349c1e8797a95c6adacfe1aa763 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa133e349c1e8797a95c6adacfe1aa763">CalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer) const </td></tr>
<tr class="memdesc:aa133e349c1e8797a95c6adacfe1aa763 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent one-byte checksum calculation procedure that uses byte string.  <a href="#aa133e349c1e8797a95c6adacfe1aa763">More...</a><br /></td></tr>
<tr class="separator:aa133e349c1e8797a95c6adacfe1aa763 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb755fa8d912240ffd69553930ea114 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6bb755fa8d912240ffd69553930ea114">CalculateCRC16</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer) const </td></tr>
<tr class="memdesc:a6bb755fa8d912240ffd69553930ea114 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent two-byte CRC calculation procedure that accepts the byte string.  <a href="#a6bb755fa8d912240ffd69553930ea114">More...</a><br /></td></tr>
<tr class="separator:a6bb755fa8d912240ffd69553930ea114 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f966b2e9889aa5111130cc2a96ce27f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a3f966b2e9889aa5111130cc2a96ce27f">Sleep</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:a3f966b2e9889aa5111130cc2a96ce27f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls channel's Sleep method if the channel is present.  <a href="#a3f966b2e9889aa5111130cc2a96ce27f">More...</a><br /></td></tr>
<tr class="separator:a3f966b2e9889aa5111130cc2a96ce27f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85938b8449e0ec4f2d8ccbe0b07e6d07 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a85938b8449e0ec4f2d8ccbe0b07e6d07">GetMeterIsLittleEndian</a> () const </td></tr>
<tr class="separator:a85938b8449e0ec4f2d8ccbe0b07e6d07 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a903d399462a1c758ee69a409ca0a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#acf7a903d399462a1c758ee69a409ca0a">SetMeterIsLittleEndian</a> (bool isLittleEndian)</td></tr>
<tr class="separator:acf7a903d399462a1c758ee69a409ca0a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1f3716f3a56c3d652dcd856d4b2afb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7c1f3716f3a56c3d652dcd856d4b2afb">GetChannel</a> () const </td></tr>
<tr class="separator:a7c1f3716f3a56c3d652dcd856d4b2afb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742a84d23ad0eb514b1438877caaf546 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a742a84d23ad0eb514b1438877caaf546">SetChannel</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel)</td></tr>
<tr class="separator:a742a84d23ad0eb514b1438877caaf546 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159f02566ad282534dca1cc48ca6a9be inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a159f02566ad282534dca1cc48ca6a9be">IsChannelOwned</a> () const </td></tr>
<tr class="separator:a159f02566ad282534dca1cc48ca6a9be inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4244ee4024965a0ccdc5e374a4f4ce4b inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a4244ee4024965a0ccdc5e374a4f4ce4b">SetIsChannelOwned</a> (bool yes)</td></tr>
<tr class="separator:a4244ee4024965a0ccdc5e374a4f4ce4b inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada79d1deee2f2b2c57f4c0733f9c5670 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ada79d1deee2f2b2c57f4c0733f9c5670">GetKeepSessionAlive</a> () const </td></tr>
<tr class="separator:ada79d1deee2f2b2c57f4c0733f9c5670 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17855be033587c380defb411ca4a169 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab17855be033587c380defb411ca4a169">SetKeepSessionAlive</a> (bool alive)</td></tr>
<tr class="separator:ab17855be033587c380defb411ca4a169 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eb073d8a88ba1a5f741e5ba5ef35e3 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab7eb073d8a88ba1a5f741e5ba5ef35e3">GetPassword</a> () const </td></tr>
<tr class="separator:ab7eb073d8a88ba1a5f741e5ba5ef35e3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad711cb25a0c60e1789391e8398d670 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;password)</td></tr>
<tr class="separator:abad711cb25a0c60e1789391e8398d670 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5d6a64af11464ea5e932188affd950 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aff5d6a64af11464ea5e932188affd950">GetPasswordList</a> () const </td></tr>
<tr class="separator:aff5d6a64af11464ea5e932188affd950 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbfdbdb3cbeb2809e0aa18de682decd inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5fbfdbdb3cbeb2809e0aa18de682decd">SetPasswordList</a> (const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;passwordList)</td></tr>
<tr class="separator:a5fbfdbdb3cbeb2809e0aa18de682decd inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04125b705921153a4bde750649a9ecc3 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a04125b705921153a4bde750649a9ecc3">GetProgressMonitor</a> () const </td></tr>
<tr class="separator:a04125b705921153a4bde750649a9ecc3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc702f61befdd1b58b7186d457e3789 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2cc702f61befdd1b58b7186d457e3789">SetProgressMonitor</a> (<a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *p)</td></tr>
<tr class="separator:a2cc702f61befdd1b58b7186d457e3789 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c81486925491e60e7c6beb86e603b7 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">MCommunicationQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80c81486925491e60e7c6beb86e603b7">GetCommandQueue</a> ()</td></tr>
<tr class="memdesc:a80c81486925491e60e7c6beb86e603b7 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">M_NO_PROGRESS_MONITOR.  <a href="#a80c81486925491e60e7c6beb86e603b7">More...</a><br /></td></tr>
<tr class="separator:a80c81486925491e60e7c6beb86e603b7 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850a893c89d0336264c7a67c0a6cdf2f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">const MCommunicationQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a850a893c89d0336264c7a67c0a6cdf2f">GetCommandQueue</a> () const </td></tr>
<tr class="memdesc:a850a893c89d0336264c7a67c0a6cdf2f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">M_NO_PROGRESS_MONITOR.  <a href="#a850a893c89d0336264c7a67c0a6cdf2f">More...</a><br /></td></tr>
<tr class="separator:a850a893c89d0336264c7a67c0a6cdf2f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb127ad977cc65921c71f65c56bc427d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abb127ad977cc65921c71f65c56bc427d">IdentifyMeter</a> (bool sessionIsStarted=false)</td></tr>
<tr class="separator:abb127ad977cc65921c71f65c56bc427d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78587773f355c611188b78b6fd1be3e4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a78587773f355c611188b78b6fd1be3e4">DoIdentifyMeter0</a> ()</td></tr>
<tr class="separator:a78587773f355c611188b78b6fd1be3e4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d9454ddf99ec17a57e738b7a4c9924"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a21d9454ddf99ec17a57e738b7a4c9924">~MCOMObject</a> ()</td></tr>
<tr class="memdesc:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a035721a745792a3acf0d4b274f1357f7">GetAllPropertyNames</a> () const </td></tr>
<tr class="memdesc:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available properties in MCOM syntax.  <a href="#a035721a745792a3acf0d4b274f1357f7">More...</a><br /></td></tr>
<tr class="separator:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a49655583da819ff86d7798a28537c6a8">GetAllPersistentPropertyNames</a> () const </td></tr>
<tr class="memdesc:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available persistent properties in MCOM syntax.  <a href="#a49655583da819ff86d7798a28537c6a8">More...</a><br /></td></tr>
<tr class="separator:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ae29a16d367eb0adb13332f8ac5fb888c">GetPersistentPropertyValues</a> (bool onlyNondefaults=false, bool excludeSecurityRelated=false) const </td></tr>
<tr class="memdesc:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#ae29a16d367eb0adb13332f8ac5fb888c">More...</a><br /></td></tr>
<tr class="separator:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#acc4469513dd44b58e00cec24dbb6d8a3">SetPersistentPropertyValues</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;values)</td></tr>
<tr class="memdesc:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties for the object using the string with the following format:  <a href="#acc4469513dd44b58e00cec24dbb6d8a3">More...</a><br /></td></tr>
<tr class="separator:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ac1d0975664316b3009c6f4f1822cfa75">SetPropertyValues</a> (const <a class="el" href="class_m_dictionary.html">MDictionary</a> &amp;values)</td></tr>
<tr class="memdesc:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the properties for the object using the property list object.  <a href="#ac1d0975664316b3009c6f4f1822cfa75">More...</a><br /></td></tr>
<tr class="separator:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a7f7d1bbe083159dca4bd92e5d8268ad2">WritePropertiesToMonitor</a> ()</td></tr>
<tr class="memdesc:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all non-default values of protocol properties into monitor.  <a href="#a7f7d1bbe083159dca4bd92e5d8268ad2">More...</a><br /></td></tr>
<tr class="separator:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a74dc8ffe0afce73e590f2206c890a0f2">DoGetPersistentPropertyValues0</a> () const </td></tr>
<tr class="memdesc:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the whole list of persistent property names and their values.  <a href="#a74dc8ffe0afce73e590f2206c890a0f2">More...</a><br /></td></tr>
<tr class="separator:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a68f6f34b5bf5ad5b6cba05aae222bf58">DoGetPersistentPropertyValues1</a> (bool onlyNondefaults) const </td></tr>
<tr class="memdesc:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#a68f6f34b5bf5ad5b6cba05aae222bf58">More...</a><br /></td></tr>
<tr class="separator:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44959297f429d05d4408c88d7596afc4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a44959297f429d05d4408c88d7596afc4">~MObject</a> ()</td></tr>
<tr class="memdesc:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a297127a242f90a602d4ba24243591b52">GetClass</a> () const  =0</td></tr>
<tr class="memdesc:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final class of the object.  <a href="#a297127a242f90a602d4ba24243591b52">More...</a><br /></td></tr>
<tr class="separator:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a87705dec46a625badd4ceda29547b338">GetEmbeddedSizeof</a> () const </td></tr>
<tr class="memdesc:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">For embedded object types, return the size of the class.  <a href="#a87705dec46a625badd4ceda29547b338">More...</a><br /></td></tr>
<tr class="separator:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a203c3127403741b20df02335c1015532">IsEmbeddedObject</a> () const </td></tr>
<tr class="memdesc:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the object is of embedded kind.  <a href="#a203c3127403741b20df02335c1015532">More...</a><br /></td></tr>
<tr class="separator:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">SHOW_INTERNAL <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad752a5e3b6800212e453481287e28067">Call</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;params)</td></tr>
<tr class="memdesc:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant.  <a href="#ad752a5e3b6800212e453481287e28067">More...</a><br /></td></tr>
<tr class="separator:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a62a3a6bb2e0e64a644b0be916a502492">Call0</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with no parameters.  <a href="#a62a3a6bb2e0e64a644b0be916a502492">More...</a><br /></td></tr>
<tr class="separator:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3dafe0a11416dd435a4384678f9fe010">Call1</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1)</td></tr>
<tr class="memdesc:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with one parameter.  <a href="#a3dafe0a11416dd435a4384678f9fe010">More...</a><br /></td></tr>
<tr class="separator:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a47cced5e73d0558ac761367380efde52">Call2</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2)</td></tr>
<tr class="memdesc:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with two parameter.  <a href="#a47cced5e73d0558ac761367380efde52">More...</a><br /></td></tr>
<tr class="separator:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad5b38fa7d1eedf7640183ce1bf750479">Call3</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3)</td></tr>
<tr class="memdesc:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with three parameter.  <a href="#ad5b38fa7d1eedf7640183ce1bf750479">More...</a><br /></td></tr>
<tr class="separator:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#abac65416662f68d208674270c4fc2a95">Call4</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4)</td></tr>
<tr class="memdesc:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with four parameter.  <a href="#abac65416662f68d208674270c4fc2a95">More...</a><br /></td></tr>
<tr class="separator:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a72636f3f379105f9b98eb4644464c96c">Call5</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5)</td></tr>
<tr class="memdesc:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with five parameter.  <a href="#a72636f3f379105f9b98eb4644464c96c">More...</a><br /></td></tr>
<tr class="separator:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3634a9b8b7927122ec3b7e9f08f15be9">Call6</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p6)</td></tr>
<tr class="memdesc:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with six parameter.  <a href="#a3634a9b8b7927122ec3b7e9f08f15be9">More...</a><br /></td></tr>
<tr class="separator:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae7a3f18267d3af7513242e7247c8c40e">CallV</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">MVariant::VariantVector</a> &amp;params)</td></tr>
<tr class="memdesc:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant vector.  <a href="#ae7a3f18267d3af7513242e7247c8c40e">More...</a><br /></td></tr>
<tr class="separator:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99063368f3e5fb4189bcbd13339e47c0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a99063368f3e5fb4189bcbd13339e47c0">IsPropertyPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the property with the given name exists. <br /></td></tr>
<tr class="separator:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d10a068500c82809fcb6d97ea9611da"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a6d10a068500c82809fcb6d97ea9611da">IsServicePresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the service with the given name exists. <br /></td></tr>
<tr class="separator:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a0e84b79fc7c435e2b338f0f9a6239b45">GetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property value using name of the property.  <a href="#a0e84b79fc7c435e2b338f0f9a6239b45">More...</a><br /></td></tr>
<tr class="separator:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a4c04b41d6114e57b12447bd0e07e6af5">SetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="memdesc:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property using name of the property, and value.  <a href="#a4c04b41d6114e57b12447bd0e07e6af5">More...</a><br /></td></tr>
<tr class="separator:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a65eb2f14c14157a7aeead3d68550092f">SetPersistentPropertiesToDefault</a> ()</td></tr>
<tr class="memdesc:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties of the object to their default values.  <a href="#a65eb2f14c14157a7aeead3d68550092f">More...</a><br /></td></tr>
<tr class="separator:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a14384d8101f49cb7616bddd06fe6ecbd">GetPersistentPropertyDefaultValue</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default value of persistent property with the name given.  <a href="#a14384d8101f49cb7616bddd06fe6ecbd">More...</a><br /></td></tr>
<tr class="separator:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a76f62e685cf1f638da5aef8c41ca8586">SetPersistentPropertyToDefault</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent property with the name given to default value.  <a href="#a76f62e685cf1f638da5aef8c41ca8586">More...</a><br /></td></tr>
<tr class="separator:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03324a7bc9b626fe2860beb4b84b6bcc"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a03324a7bc9b626fe2860beb4b84b6bcc">GetType</a> () const </td></tr>
<tr class="memdesc:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the type for the object (could be the same as class name). <br /></td></tr>
<tr class="separator:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a164dbf0ffa4e8c65b9ceffbf1d6fb391">SetType</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;)</td></tr>
<tr class="memdesc:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally, it will set the name of the type for the object, but the service will not allow setting the name to anything other than the current name.  <a href="#a164dbf0ffa4e8c65b9ceffbf1d6fb391">More...</a><br /></td></tr>
<tr class="separator:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#af929f6afc9295557a8c5ead74c6c0b6a">Validate</a> ()</td></tr>
<tr class="memdesc:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate internal structures of the object.  <a href="#af929f6afc9295557a8c5ead74c6c0b6a">More...</a><br /></td></tr>
<tr class="separator:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad085c2bdd954e2075edfa6bdb214c06f"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad085c2bdd954e2075edfa6bdb214c06f">StaticCalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buff)</td></tr>
<tr class="memdesc:ad085c2bdd954e2075edfa6bdb214c06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the byte string given as parameters.  <a href="#ad085c2bdd954e2075edfa6bdb214c06f">More...</a><br /></td></tr>
<tr class="separator:ad085c2bdd954e2075edfa6bdb214c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6d64fb1f68e579d2d91556be61b81a"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aff6d64fb1f68e579d2d91556be61b81a">StaticCalculateChecksumFromBuffer</a> (const char *data, unsigned size)</td></tr>
<tr class="memdesc:aff6d64fb1f68e579d2d91556be61b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the buffer and length given as parameters.  <a href="#aff6d64fb1f68e579d2d91556be61b81a">More...</a><br /></td></tr>
<tr class="separator:aff6d64fb1f68e579d2d91556be61b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b5cbe42994ff3f5983f2f0eebfe561"><td class="memItemLeft" align="right" valign="top">static Muint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a76b5cbe42994ff3f5983f2f0eebfe561">StaticCalculateCRC16FromBuffer</a> (const char *buffer, unsigned length)</td></tr>
<tr class="memdesc:a76b5cbe42994ff3f5983f2f0eebfe561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-byte CRC calculation static procedure specific to C12 protocol.  <a href="#a76b5cbe42994ff3f5983f2f0eebfe561">More...</a><br /></td></tr>
<tr class="separator:a76b5cbe42994ff3f5983f2f0eebfe561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac651a5b76f9a8cef7198219810db5843"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ac651a5b76f9a8cef7198219810db5843">CRC16</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer)</td></tr>
<tr class="memdesc:ac651a5b76f9a8cef7198219810db5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but taking byte string, reflected.  <a href="#ac651a5b76f9a8cef7198219810db5843">More...</a><br /></td></tr>
<tr class="separator:ac651a5b76f9a8cef7198219810db5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:aa87779c70f4bc9e1208066509d618203 inherit pub_static_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa87779c70f4bc9e1208066509d618203">StaticCalculateChecksumFromBuffer</a> (const char *buff, unsigned size)</td></tr>
<tr class="memdesc:aa87779c70f4bc9e1208066509d618203 inherit pub_static_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most popular one-byte checksum calculation procedure, a sum of all bytes.  <a href="#aa87779c70f4bc9e1208066509d618203">More...</a><br /></td></tr>
<tr class="separator:aa87779c70f4bc9e1208066509d618203 inherit pub_static_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a677751b4d8150a1b6236d3f699adf2 inherit pub_static_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6a677751b4d8150a1b6236d3f699adf2">StaticCalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer)</td></tr>
<tr class="memdesc:a6a677751b4d8150a1b6236d3f699adf2 inherit pub_static_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the byte string given as parameters.  <a href="#a6a677751b4d8150a1b6236d3f699adf2">More...</a><br /></td></tr>
<tr class="separator:a6a677751b4d8150a1b6236d3f699adf2 inherit pub_static_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#aeba892081e500e981d22a2c54b6a0100">GetStaticClass</a> ()</td></tr>
<tr class="memdesc:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the declared class of this particular object.  <a href="#aeba892081e500e981d22a2c54b6a0100">More...</a><br /></td></tr>
<tr class="separator:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a89f92d51d036637db84d57290616e98b">IsClassPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given class name is available.  <a href="#a89f92d51d036637db84d57290616e98b">More...</a><br /></td></tr>
<tr class="separator:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8621b61dcdce80c57165aa941840a747"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a8621b61dcdce80c57165aa941840a747">MProtocolC12</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel, bool channelIsOwned=true)</td></tr>
<tr class="memdesc:a8621b61dcdce80c57165aa941840a747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new abstract ANSI C12 protocol with the channel given.  <a href="#a8621b61dcdce80c57165aa941840a747">More...</a><br /></td></tr>
<tr class="separator:a8621b61dcdce80c57165aa941840a747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:a84c83febc048cf02cb62cd89c30d933f inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a84c83febc048cf02cb62cd89c30d933f">MProtocol</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel, bool channelIsOwned=true)</td></tr>
<tr class="memdesc:a84c83febc048cf02cb62cd89c30d933f inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new abstract protocol with the channel given.  <a href="#a84c83febc048cf02cb62cd89c30d933f">More...</a><br /></td></tr>
<tr class="separator:a84c83febc048cf02cb62cd89c30d933f inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c2fcb6ca3c640a2fab27161c17b336 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae7c2fcb6ca3c640a2fab27161c17b336">DoStartSession</a> ()</td></tr>
<tr class="memdesc:ae7c2fcb6ca3c640a2fab27161c17b336 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously start the session, don't do service count.  <a href="#ae7c2fcb6ca3c640a2fab27161c17b336">More...</a><br /></td></tr>
<tr class="separator:ae7c2fcb6ca3c640a2fab27161c17b336 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6362a4ce7b3e94cfb464f9f393cebe4 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa6362a4ce7b3e94cfb464f9f393cebe4">DoEndSession</a> ()</td></tr>
<tr class="memdesc:aa6362a4ce7b3e94cfb464f9f393cebe4 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously end the session, don't do service count.  <a href="#aa6362a4ce7b3e94cfb464f9f393cebe4">More...</a><br /></td></tr>
<tr class="separator:aa6362a4ce7b3e94cfb464f9f393cebe4 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5713023f78fa29cef7dd4d447c46c13c inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5713023f78fa29cef7dd4d447c46c13c">DoTableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:a5713023f78fa29cef7dd4d447c46c13c inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter, don't do service count.  <a href="#a5713023f78fa29cef7dd4d447c46c13c">More...</a><br /></td></tr>
<tr class="separator:a5713023f78fa29cef7dd4d447c46c13c inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed51debc39d8bbf7f2ca1b5327f7bfc inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abed51debc39d8bbf7f2ca1b5327f7bfc">DoTableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:abed51debc39d8bbf7f2ca1b5327f7bfc inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write the whole table with number given as parameter, don't do service count.  <a href="#abed51debc39d8bbf7f2ca1b5327f7bfc">More...</a><br /></td></tr>
<tr class="separator:abed51debc39d8bbf7f2ca1b5327f7bfc inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df82b4dfb44ebf518616fa27d4feef7 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0df82b4dfb44ebf518616fa27d4feef7">DoTableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset, int size)</td></tr>
<tr class="memdesc:a0df82b4dfb44ebf518616fa27d4feef7 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read part of the table with number given as parameter, don't do service count.  <a href="#a0df82b4dfb44ebf518616fa27d4feef7">More...</a><br /></td></tr>
<tr class="separator:a0df82b4dfb44ebf518616fa27d4feef7 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1679a8d7a6ffc68b79aceddb89165d inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6f1679a8d7a6ffc68b79aceddb89165d">DoTableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a6f1679a8d7a6ffc68b79aceddb89165d inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write part of the table with number given as parameter, don't do service count.  <a href="#a6f1679a8d7a6ffc68b79aceddb89165d">More...</a><br /></td></tr>
<tr class="separator:a6f1679a8d7a6ffc68b79aceddb89165d inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac4a0d11d9d0a767103abf7da4db49a inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0ac4a0d11d9d0a767103abf7da4db49a">DoFunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a0ac4a0d11d9d0a767103abf7da4db49a inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with no parameters, the number of the function is given as parameter, don't do service count.  <a href="#a0ac4a0d11d9d0a767103abf7da4db49a">More...</a><br /></td></tr>
<tr class="separator:a0ac4a0d11d9d0a767103abf7da4db49a inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498d5dc0aecad07ce33fad05a051dffc inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a498d5dc0aecad07ce33fad05a051dffc">DoFunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:a498d5dc0aecad07ce33fad05a051dffc inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request data, the number of the function is given as parameter, don't do service count.  <a href="#a498d5dc0aecad07ce33fad05a051dffc">More...</a><br /></td></tr>
<tr class="separator:a498d5dc0aecad07ce33fad05a051dffc inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2765259b51fb263615753e0354284c4d inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2765259b51fb263615753e0354284c4d">DoFunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;response)</td></tr>
<tr class="memdesc:a2765259b51fb263615753e0354284c4d inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with response data, the number of the function is given as parameter, don't do service count.  <a href="#a2765259b51fb263615753e0354284c4d">More...</a><br /></td></tr>
<tr class="separator:a2765259b51fb263615753e0354284c4d inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638ffb840d26add215f782dedf9253a0 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a638ffb840d26add215f782dedf9253a0">DoFunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;response)</td></tr>
<tr class="memdesc:a638ffb840d26add215f782dedf9253a0 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request and response data, the number of the function is given as parameter, don't do service count.  <a href="#a638ffb840d26add215f782dedf9253a0">More...</a><br /></td></tr>
<tr class="separator:a638ffb840d26add215f782dedf9253a0 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99437b4f61294658ca525ebaf46b6c3b inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a99437b4f61294658ca525ebaf46b6c3b">DoIdentifyMeter</a> (bool sessionIsStarted, <a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *tablesRead)</td></tr>
<tr class="memdesc:a99437b4f61294658ca525ebaf46b6c3b inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command).  <a href="#a99437b4f61294658ca525ebaf46b6c3b">More...</a><br /></td></tr>
<tr class="separator:a99437b4f61294658ca525ebaf46b6c3b inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0daefaa99d91762fbf5da71033d87 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80a0daefaa99d91762fbf5da71033d87">DoTryPasswordOrPasswordList</a> ()</td></tr>
<tr class="memdesc:a80a0daefaa99d91762fbf5da71033d87 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try password or passwords for the protocol according to the PASSWORD and PasswordList settings.  <a href="#a80a0daefaa99d91762fbf5da71033d87">More...</a><br /></td></tr>
<tr class="separator:a80a0daefaa99d91762fbf5da71033d87 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab55c37d116010b499c3cb153c64781 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a8ab55c37d116010b499c3cb153c64781">DoTryPasswordEntry</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;entry)</td></tr>
<tr class="memdesc:a8ab55c37d116010b499c3cb153c64781 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try one password, throw if error.  <a href="#a8ab55c37d116010b499c3cb153c64781">More...</a><br /></td></tr>
<tr class="separator:a8ab55c37d116010b499c3cb153c64781 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e1791d3e8f1439f0e4ba228cb50a24 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad5e1791d3e8f1439f0e4ba228cb50a24">DoBuildComplexServiceName</a> (<a class="el" href="group___m_c_o_r_e.html#ga0cb232e7db5da70b9864e90ccdf41a1a">MChars</a> fullServiceName, <a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> serviceName, <a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int par1=-1, int par2=-1)</td></tr>
<tr class="memdesc:ad5e1791d3e8f1439f0e4ba228cb50a24 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build service name with a number and given parameters.  <a href="#ad5e1791d3e8f1439f0e4ba228cb50a24">More...</a><br /></td></tr>
<tr class="separator:ad5e1791d3e8f1439f0e4ba228cb50a24 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1387ff56bed4d3ce4ed3d7526ffb0eb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a1387ff56bed4d3ce4ed3d7526ffb0eb5">MCOMObject</a> ()</td></tr>
<tr class="memdesc:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fd4059be176487607315d88d715a97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a48fd4059be176487607315d88d715a97">MObject</a> ()</td></tr>
<tr class="memdesc:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a9160d5a51f8d3b85ace23e83f967f269">DoSetPersistentPropertiesToDefault</a> (const <a class="el" href="class_m_class.html">MClass</a> *staticClass)</td></tr>
<tr class="memdesc:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties to their default values for one object provided the class for that object.  <a href="#a9160d5a51f8d3b85ace23e83f967f269">More...</a><br /></td></tr>
<tr class="separator:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae930847fb891a40c903b0e5c0ac5bcf0"></a>
static const <a class="el" href="class_m_class.html">MClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae930847fb891a40c903b0e5c0ac5bcf0">s_class</a></td></tr>
<tr class="memdesc:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>. <br /></td></tr>
<tr class="separator:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic ANSI C12 abstract protocol, base for C12.18, C12.21, and C12.22. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ab1b6db7136fb0112a71d300490bb5dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab1b6db7136fb0112a71d300490bb5dc9a1e3ae80bbb9f1ead7589eed8f0d5fbe6"></a>READ_SERVICE_OVERHEAD&#160;</td><td class="fielddoc">
<p>Comprises of: ok8 count16 data chksum8. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab1b6db7136fb0112a71d300490bb5dc9a6e702878fd0384ba6715e15c73ca9d4c"></a>WRITE_SERVICE_OVERHEAD&#160;</td><td class="fielddoc">
<p>Comprises of: 0x40 tableid16 count16 data chksum8. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab1b6db7136fb0112a71d300490bb5dc9ab50d26ac1350dfd7835640f8f7693872"></a>PARTIAL_WRITE_SERVICE_OVERHEAD&#160;</td><td class="fielddoc">
<p>Comprises of: 0x4F tableid16 offset24 count16 data chksum8. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a101a273254d6d1b343a7042ffe0d68bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">MProtocolC12::ReadFunctionResponseEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logic of when ST8 has to be read during execution of function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#a6315b81d46343250904f858044458d76">GetAlwaysReadFunctionResponse</a> - property where this enumeration is used. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a101a273254d6d1b343a7042ffe0d68bcab001c6956785d76f54c86fdcfb7d8831"></a>ReadFunctionResponseWhenPresent&#160;</td><td class="fielddoc">
<p>Read function response only when response is present. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a101a273254d6d1b343a7042ffe0d68bca5fb91c7616dbb0c1beada4b537fa8bb2"></a>ReadFunctionResponseWhenDesired&#160;</td><td class="fielddoc">
<p>Avoid reading function response in special cases. </p>
<p>The behavior of this legacy flag is the same as <a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bca8c17152bb67546ee86b478376ce312f2">ReadFunctionResponseAlways</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a101a273254d6d1b343a7042ffe0d68bca8c17152bb67546ee86b478376ce312f2"></a>ReadFunctionResponseAlways&#160;</td><td class="fielddoc">
<p>Fully compliant ANSI behavior, always read function response. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8621b61dcdce80c57165aa941840a747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MProtocolC12::MProtocolC12 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>channelIsOwned</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new abstract ANSI C12 protocol with the channel given. </p>
<p>The service is protected because the class is abstract.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel object of the protocol. It will be a rare case when a protocol can be created without a channel, in which case this parameter can be NULL. </td></tr>
    <tr><td class="paramname">channelIsOwned</td><td>Whether the channel has to be owned by the protocol, deleted in protocol destructor or at channel reassignment. By default the protocol owns its channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a800259ba467f3410801e6c6b3504bb9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MProtocolC12::~MProtocolC12 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the C12 protocol object. </p>
<p>If the channel is owned, <a class="el" href="class_m_protocol.html#a159f02566ad282534dca1cc48ca6a9be">MProtocol::IsChannelOwned</a> is true, the channel is also destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="add7b6dceb2e6e519d524e03ef812d11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocolC12::ApplicationLayerRequestResponse </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the full application layer request and return a response. </p>
<p>The command will be the first byte in the packet, while the request parameter, if present, will form the rest of the packet. The returned response will not have the status byte, which will be thrown as <a class="el" href="class_m_e_c12_nok_response.html" title="Exception which is thrown in case the ANSI C12 meter responded with an error defined by the protocol...">MEC12NokResponse</a> if it was not zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The request corresponds to the correct C12 service packet of the given command. The channel is functioning, the state allows such request. Otherwise the exception is thrown. Any nonzero status code will be thrown as C12 exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>C12 command of the application layer. </td></tr>
    <tr><td class="paramname">request</td><td>Request buffer of the command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Response buffer, excluding the status code. </dd></dl>

</div>
</div>
<a class="anchor" id="a84f2ed24daaec391fb5d71bed3f7c372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::ApplyChannelParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the configuration of the channel in a way compatible with ANSI C12 protocol handshake sequence. </p>
<p>The action depends on the channel and particular ANSI C12 protocol. Implementations ensure that the service behaves gracefully whether the channel is connected or not. </p>

<p>Reimplemented from <a class="el" href="class_m_protocol.html#a0e5624fcd28fbc1d199dab3202220f75">MProtocol</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1222.html#aa61f5f142ad235f5d96991f83f09e700">MProtocolC1222</a>, <a class="el" href="class_m_protocol_c1218.html#a5445a7b8ac2e17b4a5227cb58724440a">MProtocolC1218</a>, and <a class="el" href="class_m_protocol_c1221.html#a16611f1db87bbe66d6576a0259858702">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="a00383e3d04e77b0f4331efd1e1a7bc51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned MProtocolC12::CalculateChecksumFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protocol dependent one-byte checksum calculation procedure that uses buffer and its size. </p>
<p>This particular implementation of the checksum calculation fits the majority of the protocols, override if needed. There is also CalculateChecksum, that works on byte string and returns a checksum value as unsigned integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer designated with the pointer and the length is valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the beginning of buffer. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of checksum. </dd></dl>

<p>Reimplemented from <a class="el" href="class_m_protocol.html#a1f41d7ea056c7487378a942b7013cd61">MProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="ad781dfc93f91866eb9ac2865ce9c0e1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Muint16 MProtocolC12::CalculateCRC16FromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two-byte CRC calculation procedure specific to C12 protocol. </p>
<p>The algorithm itself uses a set of shifts and XOR operators for efficiency. When executing on Intel, or other Little Endian architectures, the bytes are swapped after polynom calculation. </p>

<p>Reimplemented from <a class="el" href="class_m_protocol.html#a02ec86e1cc6b8fb4a1b3ecb812d0ba35">MProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="ac651a5b76f9a8cef7198219810db5843"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned MProtocolC12::CRC16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above, but taking byte string, reflected. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Same as StaticCalculateCRC16FromBuffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a87b2e3350005bee20e6ffd9bd39f875a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::FullLogin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform whatever is required by the protocol to clear security with the meter. </p>
<p>This can call ANSI C12 <a class="el" href="class_m_protocol_c12.html#ad6fde8c7dc31790774993c984ea7b403">Security</a> request, or in case of C12.21 Authenticate request.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Security or Authenticate to be called. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1221.html#a751ad19480d55db265c96bd5fe6186ae">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="a6315b81d46343250904f858044458d76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a> MProtocolC12::GetAlwaysReadFunctionResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether or not ST-8 will be read if the function does not have a response.</p>
<p>This property should be true for most ANSI meters. However, for some option boards installed on an ANSI meter, this property needs to be set to false.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27. However, the type changed from Boolean to INT32 in MeteringSDK Version 5.4.0. All versions can accept the value as Boolean or INT32, so no changes are needed to existing applications built using older versions.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>2 for MeteringSDK Versions 5.4.0 and later.</li>
<li>1 {True} for MeteringSDK Versions prior to 5.4.0.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>False, or 0 : ST-8 is NOT read when the function does not have a response. This behavior is available for all versions. Applications that set the value to 0, or False, will behave exactly the same in any version.</li>
<li>True, 1, 2, or -1 : ST-8 is read for ALL functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1e53a70a87fd5762faa9343d94e90651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC12::GetAlwaysUsePartial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use partial reads and writes in place of full reads and writes.</p>
<p>Standard table 7 write and standard table 8 write, the sequence that forms function execution, and are always performed in full, regardless of the value of this property. Also, full reads and full writes have to always be made through partial operations when full table size would not fit into a single application layer request.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.2.0.1720.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>False [0] for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>.</li>
<li>False [0] for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>.</li>
<li>False [0] for <a class="el" href="class_m_protocol_c1222.html" title="ANSI C12.22 protocol implementation. ">MProtocolC1222</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>False : perform full table reads and writes if they fit in the application layer.</li>
<li>True : replace full table reads and writes with partial operations for all tables except ST7 and ST8. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af584c3e57c6bc43ef22ea6ec4307d237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetApplicationLayerProcedureRetries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of application layer retries for functions (ANSI C12 procedures).</p>
<p>Number of times to retry on the application layer procedure request when the request has been successfully transmitted to the meter, but the meter responded that it cannot service the request. The most common meter responses that trigger an application retry are the meter is busy BSY or the data is not ready DNR.</p>
<p>The typical value for ApplicationLayerProcedureRetries is a large number (like 20) as the communications are okay and the meter is sending a meaningful response. Set the value to something small (like 0) to force the operation to fail when the meter is busy or the data is not ready.</p>
<p>ApplicationLayerProcedureRetries is different from ApplicationLayerRetries which specifies the application retries when the request is a table.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>20</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. MAXINT </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a67ca720e8642357c5ea508438699883b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetApplicationLayerProcedureRetryDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of milliseconds which the application layer should wait after reading procedure status code 1 from table 8.</p>
<p>Number of milliseconds to wait before resubmitting the table 8 read request during procedure handling. This is most useful for handling the meter is busy (BSY) and data is not ready (DNR) response codes.</p>
<p>ApplicationLayerProcedureRetryDelay is different from ApplicationLayerRetryDelay which specifies the application retries when the request is a table.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>500 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. MAXINT</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#ade7c2380742033d82f2f2a73a5cbb3fb">GetApplicationLayerRetryDelay</a> that works for table retry delays. </dd></dl>

</div>
</div>
<a class="anchor" id="a68720d1a83fe953d500e259cd3c25f37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetApplicationLayerRetries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of application layer retries for tables. The application layer table request is retried only in the case the meter is busy, or the data are not available.</p>
<p>Number of times to retry on the application layer table request when the request has been successfully transmitted to the meter, but the meter responded that it cannot service the request. The most common meter responses that trigger an application retry are the meter is busy BSY or the data is not ready DNR.</p>
<p>The typical value for ApplicationLayerRetries is a large number (like 20) as the communications are okay and the meter is sending a meaningful response. Set the value to something small (like 0) to force the operation to fail when the meter is busy or the data is not ready.</p>
<p>ApplicationLayerRetries is different from LinkLayerRetries which specifies how many times to attempt sending a link layer packet (the link layer handles the data transfer) and is different from ApplicationLayerProcedureRetries which specifies the application retries when the request is a procedure.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>20</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#af584c3e57c6bc43ef22ea6ec4307d237">GetApplicationLayerProcedureRetries</a> that works for procedure retries. </dd></dl>

</div>
</div>
<a class="anchor" id="ade7c2380742033d82f2f2a73a5cbb3fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetApplicationLayerRetryDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of milliseconds which the application layer should wait after receiving a busy response from the table.</p>
<p>Number of milliseconds to wait before resubmitting the application layer retry during table handling. This is most useful for handling the meter is busy (BSY) and data is not ready (DNR) response codes.</p>
<p>ApplicationLayerRetryDelay is different from ApplicationLayerProcedureRetryDelay which specifies the application retries when the request is a procedure.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>2000 milliseconds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#a67ca720e8642357c5ea508438699883b">GetApplicationLayerProcedureRetryDelay</a> that works for procedure retry delays. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cf83a00802dc74fc07448f43daa944d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC12::GetEndSessionOnApplicationLayerError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines whether to process Terminate service on Application Layer error.</p>
<p>This property enables automatic handling of protocols with sessions. When such protocol encounters an error within the session, and this property is true, it is possible to enable the attempt of closing the session prior to throwing the error to the user.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.2.0.1720.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>false</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The end session services are sent to the device after an Application Layer error.</li>
<li>False [0] : The end session services are NOT sent to the device after an Application Layer error. The session timeouts according to the protocol rules. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac72abca6518a456402fddb87c57cc1dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC12::GetIssueSecurityOnStartSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the start session will include the security service or the authenticate service.</p>
<p>When it is set to False, neither the security nor the authenticate service is sent, allowing data that is not password protected to be accessed without the password.</p>
<p>MeteringSDK has a check prior to sending the authenticate service. When an identify service is sent (always the first service sent in a start session sequence), the device responds with what it supports. If it says that it does not support authentication, then MeteringSDK aborts the start session sequence and throws the error "Meter does not support authentication".</p>
<p>Refer to the ANSI protocol standards for more information on the start session, security, and authenticate services.</p><ul>
<li>ANSI Std C12.18-1995 "PROTOCOL SPECIFICATION FOR ANSI TYPE 2 OPTICAL PORT"</li>
<li>ANSI Std C12.21-1998 "PROTOCOL SPECIFICATION FOR TELEPHONE MODEM COMMUNICATION"</li>
<li>ANSI Std C12.22-2008 "PROTOCOL SPECIFICATION FOR INTERFACING TO DATA COMMUNICATION NETWORKS"</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>True</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The security or authenticate service is issued with the password.</li>
<li>False [0] : The security or authenticate service is NOT issued. Data that does not require a password can be read. Attempting to access data that requires a password will generate an error. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a83cbf50c3fe4c8b5f882d3d6c41f860c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetLinkLayerRetries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of link layer retries.</p>
<p>The link layer retry takes place if an error occurs in the data transfer. For protocols that break application layer into link layer packets, such as C12.18, C12.21, and serial C12.22, this is the number of times to re-send a packet after a link layer NAK (negative-acknowledge) or timeout before giving up. The most common causes are incorrect CRC or noise in the line (data lost on the line, extra garbage characters, framing errors, bits tweaked, etc.)</p>
<p>For C12.22 protocol, this property only applies when the channel is of type <a class="el" href="class_m_channel_socket_udp.html">MChannelSocketUdp</a>, in which case this is the number of resends of the outgoing UDP packet.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>3 </dd></dl>

</div>
</div>
<a class="anchor" id="a6781d4aa9fae4b507dd76b70a00f7ac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetMaximumReadTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum possible size of a table to read partially or fully in a single application layer packet. </p>
<p>When the requested table size is bigger than the value of this property, the request is transparently broken into multiple application layer packets, so that each table data transfer fits within the property value.</p>
<p>The property value is calculated using the current protocol properties, capabilities, and overhead. The value can change after properties are negotiated with the device.</p>
<p>For example, when the protocol is C12.18, the maximum read table size will depend on the packet size and the maximum number of packets. After Negotiate is issued, the value can change depending on the negotiated packet size and the negotiated maximum number of packets. </p>

</div>
</div>
<a class="anchor" id="a1d19806287de5f72638af728763bb2ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetProcedureSequenceNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sequence number byte to use in the next C12 procedure.</p>
<p>Procedure sequence number is a dynamic property, not persistent, and it will always be set to zero at the creation of the protocol object. During the lifespan of the protocol, the property can either be modified by the user (the caller), or by the incoming packet that relates to ANSI C12 procedure as defined in ANSI C12.19 standard paper.</p>
<p>In client protocols the user (the caller) can modify this property at any moment before a desired FUNCTION is executed to change SEQ_NBR field of ST7 write. The following ST8 read will modify this property with the SEQ_NBR value. The compliant protocol implementation will always respond with the same value for SEQ_NBR. Currently MeteringSDK client does not check by itself if sequence numbers in ST7 write and in the following ST8 read match, as this can possibly break some C12 implementations. The behavior can be reconsidered later after the extensive testing.</p>
<p>In the server implementation, ST7 write arrives first, and it changes the value of this property with the incoming SEQ_NBR. The same value is sent back in ST8 unless the user modifies the property to a different value in the function handler, in which case a noncompliant value of SEQ_NBR is sent back. This can be helpful for testing purposes.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 6.6.0.5882.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>0</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 255</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aba17f8b403b824f484d56872640ceb83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetTurnAroundDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of milliseconds to wait before the computer sends data to the meter on the link layer.</p>
<p>The data may be an ACK or NAK to a packet received from the meter or it may be the next request to send to the meter. The delay is required so that the UART and firmware in the meter has time to switch from transmit to receive and to process the last transmission it received. If the data is sent to too soon, the meter may not receive it, which results in communication failures and retry attempts. The actual amount of delay will depend on the computer and the number of tasks running (for example, the Sleep method causes a task switch). Faster machines will approach the specified time more closely. </p><div class="fragment"><div class="line">0.01 <a class="code" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">StartSession</a></div><div class="line">0.12 Identify</div><div class="line">0.17 Tx&gt; EE 00 00 00 00 01 20 13 10</div><div class="line">0.20 Rx&gt; 06 EE 00 00 00 00 05 00 00 01 00 00 C6 B5</div><div class="line">   <span class="comment">// Turn around delay, approximately 60 msec before</span></div><div class="line">   <span class="comment">// ACK (0x06) transmitted to the meter</span></div><div class="line">0.26 Tx&gt; 06</div><div class="line">0.26 Identify success</div><div class="line">   <span class="comment">// Turn around delay, approximately 60 msec before</span></div><div class="line">   <span class="comment">// next request (Negotiate) transmitted to the meter</span></div><div class="line">0.26 Negotiate</div><div class="line">0.32 Tx&gt; EE 00 20 00 00 05 61 04 00 80 06 C2 29</div><div class="line">0.35 Rx&gt; 06 EE 00 20 00 00 05 00 04 00 80 06 35 83</div><div class="line">0.41 Tx&gt; 06</div><div class="line">0.41 Negotiate success</div></div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>20 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>.</li>
<li>20 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>.</li>
<li>20 milliseconds for <a class="el" href="class_m_protocol_c1222.html" title="ANSI C12.22 protocol implementation. ">MProtocolC1222</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. MAXINT in milliseconds. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab743cbb677afa0790653f03698b9850e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&amp; MProtocolC12::GetUser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the user name that will be used during logon service of the protocol.</p>
<p>Value used in the "user" parameter of the ANSI C12 logon service. The logon service is part of QStartSession. The User as defined by the ANSI C12 standard is a utility supplied name of the operator requesting the access to the device.</p>
<p>The User property can have a maximum of 10 characters. If the User property is specified with less than 10 characters, then during communications the remaining characters are filled with blank spaces. For example, if User is specified as "METER1", then "METER1 " is used in the user field of the logon service, but the property User reports "METER1".</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>10 characters with binary zero values.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>Any string containing 10 or less bytes, i.e. "1234567890". </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a146ef42e1040bd735fa82bb97d7f893b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC12::GetUseReadInKeepSessionAlive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use table read for session keeping instead of C12 Wait. This property has no effect if KEEP_SESSION_ALIVE is False.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 4.0.54.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The first byte of ST1 will be read to keep the session alive.</li>
<li>False [0] : The C12 Wait service will be used to keep the session alive. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a02e79193a4c47c45f7d70fb6f4e824a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::GetUserId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>User identity number reported to device.</p>
<p>User ID is used in logon services of all variants of ANSI C12, and in sessionless mode Security service of ANSI C12.22. The User ID as defined by the ANSI C12 standard is a code indicating a utility supplied identity of the operator requesting the creation of the session. If the metering device supports Events and History logs, it has the option of storing the User ID as defined in the "Utility Industry End Device Data Tables" document.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>0</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 65535</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aeeedd60972e30daaa70274dcab5dd33d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::Logoff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Logoff service. </p>
<p>This standard service is part of <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">MProtocol::StartSession()</a>, but it can also be called directly by the user for any purpose such as testing, or custom implementation of Start Session sequence.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Logoff to be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ca4e7b5d3ae6da1b160b520b2b1728e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::Logon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Logon service. </p>
<p>This standard service is part of <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">MProtocol::StartSession()</a>, but it can also be called directly by the user for any purpose such as testing, or custom implementation of Start Session sequence.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Logon to be called. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1222.html#ab6d27381bb0e4619f36e6b307be7a0c8">MProtocolC1222</a>.</p>

</div>
</div>
<a class="anchor" id="a03c52d5cf88970f3d7b9af93329c4afd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint8 MProtocolC12::ReceiveServiceByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one byte from the incoming application layer data packet. </p>
<p>The service works like a stream, one can issue ReceiveByte many times in small chunks, and it will be returning subsequent bytes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The packet was received successfully, and it has data available. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b92f863b59fcac9b865a39b41a66dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocolC12::ReceiveServiceBytes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read several bytes of the incoming application layer data packet. </p>
<p>The length of the returned buffer is expected. The service works like a stream, one can issue ReceiveServiceUInt many times in small chunks, and it will be returning subsequent bytes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The packet was received successfully, and it has data available. </dd></dl>

</div>
</div>
<a class="anchor" id="a80e449f54f53f85ec3e86026d1f2f874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint8 MProtocolC12::ReceiveServiceCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a code of the incoming application layer data packet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The packet was received successfully, and it has the code data available. </dd></dl>

</div>
</div>
<a class="anchor" id="a5602d36bc610094386de8122b4d9f05f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocolC12::ReceiveServiceRemainingBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes of the incoming application layer data packet. </p>
<p>Returned buffer has a remaining size.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The packet was received successfully, and it has data available. </dd></dl>

</div>
</div>
<a class="anchor" id="adf12a9c3e16baf235353f449be5b77ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC12::ReceiveServiceUInt </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read several bytes from the incoming application layer data packet. </p>
<p>No more than 4 bytes are allowed to be read. To read more than 4 bytes use ReceiveServiceBytes. The service works like a stream, one can issue ReceiveServiceUInt many times in small chunks, and it will be returning subsequent bytes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The packet was received successfully, and it has data available, parameter size is no more than 4. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6fde8c7dc31790774993c984ea7b403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::Security </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Security service. </p>
<p>This standard service is part of <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">MProtocol::StartSession()</a>, but it can also be called directly by the user for any purpose such as testing, or custom implementation of Start Session sequence.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Logon to be called. </dd></dl>

</div>
</div>
<a class="anchor" id="ad40a414d2e935e1a733fc0422a26cc59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetAlwaysReadFunctionResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether or not ST-8 will be read if the function does not have a response.</p>
<p>This property should be true for most ANSI meters. However, for some option boards installed on an ANSI meter, this property needs to be set to false.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27. However, the type changed from Boolean to INT32 in MeteringSDK Version 5.4.0. All versions can accept the value as Boolean or INT32, so no changes are needed to existing applications built using older versions.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>2 for MeteringSDK Versions 5.4.0 and later.</li>
<li>1 {True} for MeteringSDK Versions prior to 5.4.0.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>False, or 0 : ST-8 is NOT read when the function does not have a response. This behavior is available for all versions. Applications that set the value to 0, or False, will behave exactly the same in any version.</li>
<li>True, 1, 2, or -1 : ST-8 is read for ALL functions. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a94e1a04ca84321239b78e4b77e748950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetAlwaysUsePartial </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use partial reads and writes in place of full reads and writes.</p>
<p>Standard table 7 write and standard table 8 write, the sequence that forms function execution, and are always performed in full, regardless of the value of this property. Also, full reads and full writes have to always be made through partial operations when full table size would not fit into a single application layer request.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.2.0.1720.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>False [0] for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>.</li>
<li>False [0] for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>.</li>
<li>False [0] for <a class="el" href="class_m_protocol_c1222.html" title="ANSI C12.22 protocol implementation. ">MProtocolC1222</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>False : perform full table reads and writes if they fit in the application layer.</li>
<li>True : replace full table reads and writes with partial operations for all tables except ST7 and ST8. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4eb6a66e89731e89b4c812f78e4d2c57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetApplicationLayerProcedureRetries </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>retries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of application layer retries for functions (ANSI C12 procedures).</p>
<p>Number of times to retry on the application layer procedure request when the request has been successfully transmitted to the meter, but the meter responded that it cannot service the request. The most common meter responses that trigger an application retry are the meter is busy BSY or the data is not ready DNR.</p>
<p>The typical value for ApplicationLayerProcedureRetries is a large number (like 20) as the communications are okay and the meter is sending a meaningful response. Set the value to something small (like 0) to force the operation to fail when the meter is busy or the data is not ready.</p>
<p>ApplicationLayerProcedureRetries is different from ApplicationLayerRetries which specifies the application retries when the request is a table.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>20</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. MAXINT </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aca28f4ac408b77fc27c7b2b9b88422d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetApplicationLayerProcedureRetryDelay </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of milliseconds which the application layer should wait after reading procedure status code 1 from table 8.</p>
<p>Number of milliseconds to wait before resubmitting the table 8 read request during procedure handling. This is most useful for handling the meter is busy (BSY) and data is not ready (DNR) response codes.</p>
<p>ApplicationLayerProcedureRetryDelay is different from ApplicationLayerRetryDelay which specifies the application retries when the request is a table.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>500 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. MAXINT</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#ade7c2380742033d82f2f2a73a5cbb3fb">GetApplicationLayerRetryDelay</a> that works for table retry delays. </dd></dl>

</div>
</div>
<a class="anchor" id="a1492dc4303aaba34492ae85f7b9f2098"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetApplicationLayerRetries </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>retries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of application layer retries for tables. The application layer table request is retried only in the case the meter is busy, or the data are not available.</p>
<p>Number of times to retry on the application layer table request when the request has been successfully transmitted to the meter, but the meter responded that it cannot service the request. The most common meter responses that trigger an application retry are the meter is busy BSY or the data is not ready DNR.</p>
<p>The typical value for ApplicationLayerRetries is a large number (like 20) as the communications are okay and the meter is sending a meaningful response. Set the value to something small (like 0) to force the operation to fail when the meter is busy or the data is not ready.</p>
<p>ApplicationLayerRetries is different from LinkLayerRetries which specifies how many times to attempt sending a link layer packet (the link layer handles the data transfer) and is different from ApplicationLayerProcedureRetries which specifies the application retries when the request is a procedure.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>20</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#af584c3e57c6bc43ef22ea6ec4307d237">GetApplicationLayerProcedureRetries</a> that works for procedure retries. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bceb67a0c9486070dbb02b9b3f6982c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetApplicationLayerRetryDelay </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of milliseconds which the application layer should wait after receiving a busy response from the table.</p>
<p>Number of milliseconds to wait before resubmitting the application layer retry during table handling. This is most useful for handling the meter is busy (BSY) and data is not ready (DNR) response codes.</p>
<p>ApplicationLayerRetryDelay is different from ApplicationLayerProcedureRetryDelay which specifies the application retries when the request is a procedure.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>2000 milliseconds</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#a67ca720e8642357c5ea508438699883b">GetApplicationLayerProcedureRetryDelay</a> that works for procedure retry delays. </dd></dl>

</div>
</div>
<a class="anchor" id="abd1a5e69e3c698e7e0f232191513eb79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetEndSessionOnApplicationLayerError </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endSessionOnApplicationLayerError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines whether to process Terminate service on Application Layer error.</p>
<p>This property enables automatic handling of protocols with sessions. When such protocol encounters an error within the session, and this property is true, it is possible to enable the attempt of closing the session prior to throwing the error to the user.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.2.0.1720.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>false</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The end session services are sent to the device after an Application Layer error.</li>
<li>False [0] : The end session services are NOT sent to the device after an Application Layer error. The session timeouts according to the protocol rules. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae4ba7c99bbbe38cb5ba6775b4f2bfe96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::SetIssueSecurityOnStartSession </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the start session will include the security service or the authenticate service.</p>
<p>When it is set to False, neither the security nor the authenticate service is sent, allowing data that is not password protected to be accessed without the password.</p>
<p>MeteringSDK has a check prior to sending the authenticate service. When an identify service is sent (always the first service sent in a start session sequence), the device responds with what it supports. If it says that it does not support authentication, then MeteringSDK aborts the start session sequence and throws the error "Meter does not support authentication".</p>
<p>Refer to the ANSI protocol standards for more information on the start session, security, and authenticate services.</p><ul>
<li>ANSI Std C12.18-1995 "PROTOCOL SPECIFICATION FOR ANSI TYPE 2 OPTICAL PORT"</li>
<li>ANSI Std C12.21-1998 "PROTOCOL SPECIFICATION FOR TELEPHONE MODEM COMMUNICATION"</li>
<li>ANSI Std C12.22-2008 "PROTOCOL SPECIFICATION FOR INTERFACING TO DATA COMMUNICATION NETWORKS"</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>True</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The security or authenticate service is issued with the password.</li>
<li>False [0] : The security or authenticate service is NOT issued. Data that does not require a password can be read. Attempting to access data that requires a password will generate an error. </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1222.html#a2eae9a8d8956f334fccdb56004c0193a">MProtocolC1222</a>.</p>

</div>
</div>
<a class="anchor" id="a081e76c597fce9b27afb371dcb196397"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetLinkLayerRetries </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>retries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of link layer retries.</p>
<p>The link layer retry takes place if an error occurs in the data transfer. For protocols that break application layer into link layer packets, such as C12.18, C12.21, and serial C12.22, this is the number of times to re-send a packet after a link layer NAK (negative-acknowledge) or timeout before giving up. The most common causes are incorrect CRC or noise in the line (data lost on the line, extra garbage characters, framing errors, bits tweaked, etc.)</p>
<p>For C12.22 protocol, this property only applies when the channel is of type <a class="el" href="class_m_channel_socket_udp.html">MChannelSocketUdp</a>, in which case this is the number of resends of the outgoing UDP packet.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>3 </dd></dl>

</div>
</div>
<a class="anchor" id="a711c67714f108b262fe7c5de9021311e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetProcedureSequenceNumber </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sequence number byte to use in the next C12 procedure.</p>
<p>Procedure sequence number is a dynamic property, not persistent, and it will always be set to zero at the creation of the protocol object. During the lifespan of the protocol, the property can either be modified by the user (the caller), or by the incoming packet that relates to ANSI C12 procedure as defined in ANSI C12.19 standard paper.</p>
<p>In client protocols the user (the caller) can modify this property at any moment before a desired FUNCTION is executed to change SEQ_NBR field of ST7 write. The following ST8 read will modify this property with the SEQ_NBR value. The compliant protocol implementation will always respond with the same value for SEQ_NBR. Currently MeteringSDK client does not check by itself if sequence numbers in ST7 write and in the following ST8 read match, as this can possibly break some C12 implementations. The behavior can be reconsidered later after the extensive testing.</p>
<p>In the server implementation, ST7 write arrives first, and it changes the value of this property with the incoming SEQ_NBR. The same value is sent back in ST8 unless the user modifies the property to a different value in the function handler, in which case a noncompliant value of SEQ_NBR is sent back. This can be helpful for testing purposes.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 6.6.0.5882.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>0</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 255</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a364147a8f5d419e7555dccda9ae8c0eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetTurnAroundDelay </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of milliseconds to wait before the computer sends data to the meter on the link layer.</p>
<p>The data may be an ACK or NAK to a packet received from the meter or it may be the next request to send to the meter. The delay is required so that the UART and firmware in the meter has time to switch from transmit to receive and to process the last transmission it received. If the data is sent to too soon, the meter may not receive it, which results in communication failures and retry attempts. The actual amount of delay will depend on the computer and the number of tasks running (for example, the Sleep method causes a task switch). Faster machines will approach the specified time more closely. </p><div class="fragment"><div class="line">0.01 <a class="code" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">StartSession</a></div><div class="line">0.12 Identify</div><div class="line">0.17 Tx&gt; EE 00 00 00 00 01 20 13 10</div><div class="line">0.20 Rx&gt; 06 EE 00 00 00 00 05 00 00 01 00 00 C6 B5</div><div class="line">   <span class="comment">// Turn around delay, approximately 60 msec before</span></div><div class="line">   <span class="comment">// ACK (0x06) transmitted to the meter</span></div><div class="line">0.26 Tx&gt; 06</div><div class="line">0.26 Identify success</div><div class="line">   <span class="comment">// Turn around delay, approximately 60 msec before</span></div><div class="line">   <span class="comment">// next request (Negotiate) transmitted to the meter</span></div><div class="line">0.26 Negotiate</div><div class="line">0.32 Tx&gt; EE 00 20 00 00 05 61 04 00 80 06 C2 29</div><div class="line">0.35 Rx&gt; 06 EE 00 20 00 00 05 00 04 00 80 06 35 83</div><div class="line">0.41 Tx&gt; 06</div><div class="line">0.41 Negotiate success</div></div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>20 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>.</li>
<li>20 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>.</li>
<li>20 milliseconds for <a class="el" href="class_m_protocol_c1222.html" title="ANSI C12.22 protocol implementation. ">MProtocolC1222</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. MAXINT in milliseconds. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad6c52a6b797045c8fb739a2d512ad3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>userName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the user name that will be used during logon service of the protocol.</p>
<p>Value used in the "user" parameter of the ANSI C12 logon service. The logon service is part of QStartSession. The User as defined by the ANSI C12 standard is a utility supplied name of the operator requesting the access to the device.</p>
<p>The User property can have a maximum of 10 characters. If the User property is specified with less than 10 characters, then during communications the remaining characters are filled with blank spaces. For example, if User is specified as "METER1", then "METER1 " is used in the user field of the logon service, but the property User reports "METER1".</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>10 characters with binary zero values.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>Any string containing 10 or less bytes, i.e. "1234567890". </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9a43f1026237f4b14d8e2b553123b53b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetUseReadInKeepSessionAlive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use table read for session keeping instead of C12 Wait. This property has no effect if KEEP_SESSION_ALIVE is False.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 4.0.54.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The first byte of ST1 will be read to keep the session alive.</li>
<li>False [0] : The C12 Wait service will be used to keep the session alive. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abd0a00abedf0f78c28ca860e7e4b7eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC12::SetUserId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>userId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User identity number reported to device.</p>
<p>User ID is used in logon services of all variants of ANSI C12, and in sessionless mode Security service of ANSI C12.22. The User ID as defined by the ANSI C12 standard is a code indicating a utility supplied identity of the operator requesting the creation of the session. If the metering device supports Events and History logs, it has the option of storing the User ID as defined in the "Utility Industry End Device Data Tables" document.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>0</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 65535</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad085c2bdd954e2075edfa6bdb214c06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned MProtocolC12::StaticCalculateChecksum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute checksum of the byte string given as parameters. </p>
<p>The checksum is calculated based on the C12 rules. </p>

</div>
</div>
<a class="anchor" id="aff6d64fb1f68e579d2d91556be61b81a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned MProtocolC12::StaticCalculateChecksumFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute checksum of the buffer and length given as parameters. </p>
<p>The checksum is calculated based on the C12 rules.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c12.html#ad085c2bdd954e2075edfa6bdb214c06f" title="Compute checksum of the byte string given as parameters. ">StaticCalculateChecksum</a> for the variation with the byte string given as byte string. </dd></dl>

</div>
</div>
<a class="anchor" id="a76b5cbe42994ff3f5983f2f0eebfe561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Muint16 MProtocolC12::StaticCalculateCRC16FromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two-byte CRC calculation static procedure specific to C12 protocol. </p>
<p>The algorithm itself uses a set of shifts and xor operators for efficiency. When executing on Intel, or other Little Endian architectures, the bytes are swapped after polynom calculation.</p>
<p>Note that there is also a virtual variation of this service, CalculateCRC16FromBuffer, which is used externally by interfaces which do not care about particular protocols.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The buffer designated with the pointer and the length is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a47ee47d2594f1c05ba4d48334d77ec93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::Terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Terminate service. </p>
<p>This standard service is part of <a class="el" href="class_m_protocol.html#a614c406f96f58b3c72411924f085e0f1">MProtocol::EndSession()</a>, but it can also be called directly by the user for any purpose such as testing, or custom implementation of End Session sequence.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Terminate to be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a2037a107e2308035f797ec0c702a2428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC12::Wait </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Wait service. </p>
<p>ANSI C12 Wait extends the session to the given number of seconds, so in case of inactivity of the communication the session does not time out.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Wait to be called. Seconds are no bigger than 255. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_protocol_c12.html">MProtocolC12</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
