<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MChannel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_channel.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_m_channel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MChannel Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___m_c_o_m.html">MCOM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstraction of all channel-level communication media.  
 <a href="class_m_channel.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MChannel:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_channel__inherit__graph.png" border="0" usemap="#_m_channel_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_channel_inherit__map" id="_m_channel_inherit__map">
<area shape="rect" id="node4" href="class_m_channel_serial_port.html" title="Serial port based channel, a null cable direct serial link or a link through a current loop adapter..." alt="" coords="408,81,545,108"/>
<area shape="rect" id="node9" href="class_m_channel_socket_base.html" title="MChannelSocket implements the channel interface for an IP socket, either TCP or UDP. " alt="" coords="401,157,552,184"/>
<area shape="rect" id="node2" href="class_m_c_o_m_object.html" title="Root communication object that defines default property handling and configuration location..." alt="" coords="124,132,225,159"/>
<area shape="rect" id="node3" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars..." alt="" coords="5,132,76,159"/>
<area shape="rect" id="node5" href="class_m_channel_current_loop.html" title="MChannelCurrentLoop implements methods necessary for handling RS&#45;232 serial port. ..." alt="" coords="602,5,753,32"/>
<area shape="rect" id="node6" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. " alt="" coords="616,56,739,83"/>
<area shape="rect" id="node8" href="class_m_channel_optical_probe.html" title="Optical probe is a channel based on serial port that is able to control the batteries of the probe (i..." alt="" coords="600,107,755,133"/>
<area shape="rect" id="node7" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. " alt="" coords="813,56,987,83"/>
<area shape="rect" id="node10" href="class_m_channel_socket.html" title="MChannelSocket implements the channel interface for an TCP/IP socket. " alt="" coords="617,157,738,184"/>
<area shape="rect" id="node12" href="class_m_channel_socket_udp.html" title="Implements the channel interface for an UDP datagram socket. " alt="" coords="605,208,749,235"/>
<area shape="rect" id="node11" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. " alt="" coords="815,157,985,184"/>
<area shape="rect" id="node13" href="class_m_channel_socket_udp_callback.html" title="Socket callback channel is MChannelSocketUdp that has Auto Answer enabled by default. " alt="" coords="803,208,997,235"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel_1_1_read_timeout_savior.html">ReadTimeoutSavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily overrides read timeout with a new value using scope rules.  <a href="class_m_channel_1_1_read_timeout_savior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel_1_1_uninterruptible_communication.html">UninterruptibleCommunication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninterruptible communication C++ wrapper.  <a href="class_m_channel_1_1_uninterruptible_communication.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8f92f7546c30df757eacfe61108f9032"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_m_channel.html#a8f92f7546c30df757eacfe61108f9032ac491d4c3448092a7beb308f4156d2349">CANCEL_COMMUNICATION_CHECK_OPTIMUM_INTERVAL</a> = 1000
 }</td></tr>
<tr class="separator:a8f92f7546c30df757eacfe61108f9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16a5a9f75ff0feba8b7eb9ff0bf38fe7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a16a5a9f75ff0feba8b7eb9ff0bf38fe7">CreateClone</a> () const </td></tr>
<tr class="memdesc:a16a5a9f75ff0feba8b7eb9ff0bf38fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual copy constructor, creates the channel, which is a clone of current.  <a href="#a16a5a9f75ff0feba8b7eb9ff0bf38fe7">More...</a><br /></td></tr>
<tr class="separator:a16a5a9f75ff0feba8b7eb9ff0bf38fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01d306b233de3d3a9fd0b60e75c3bf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#acd01d306b233de3d3a9fd0b60e75c3bf">~MChannel</a> ()</td></tr>
<tr class="memdesc:acd01d306b233de3d3a9fd0b60e75c3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor is public, and virtual.  <a href="#acd01d306b233de3d3a9fd0b60e75c3bf">More...</a><br /></td></tr>
<tr class="separator:acd01d306b233de3d3a9fd0b60e75c3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9ead36be06025ce8cd6292824bf59f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect</a> ()</td></tr>
<tr class="memdesc:acb9ead36be06025ce8cd6292824bf59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes channel and establishes connection between the computer and the end device.  <a href="#acb9ead36be06025ce8cd6292824bf59f">More...</a><br /></td></tr>
<tr class="separator:acb9ead36be06025ce8cd6292824bf59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098b8ede4c951f9f9e52e9468d2624f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ab098b8ede4c951f9f9e52e9468d2624f">WaitForNextIncomingConnection</a> (bool reinitialize=true)</td></tr>
<tr class="memdesc:ab098b8ede4c951f9f9e52e9468d2624f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="class_m_channel.html#afb30fa08d603b57356a3a3f1be6b088a">GetAutoAnswer</a> true, wait for the incoming connection without disconnecting the channel.  <a href="#ab098b8ede4c951f9f9e52e9468d2624f">More...</a><br /></td></tr>
<tr class="separator:ab098b8ede4c951f9f9e52e9468d2624f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330d82a247925e1550a4563e2e09550d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a330d82a247925e1550a4563e2e09550d">Disconnect</a> ()=0</td></tr>
<tr class="memdesc:a330d82a247925e1550a4563e2e09550d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect brings down the data link, hangs up the phone, powers down the probe, etc.  <a href="#a330d82a247925e1550a4563e2e09550d">More...</a><br /></td></tr>
<tr class="separator:a330d82a247925e1550a4563e2e09550d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731c83d6eea5106729ec5ec45c38c404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a731c83d6eea5106729ec5ec45c38c404">WriteBytes</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer)</td></tr>
<tr class="memdesc:a731c83d6eea5106729ec5ec45c38c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data to the channel, and returns when the last byte has been sent by the software.  <a href="#a731c83d6eea5106729ec5ec45c38c404">More...</a><br /></td></tr>
<tr class="separator:a731c83d6eea5106729ec5ec45c38c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b88439ade55836f2e71b94080855460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a2b88439ade55836f2e71b94080855460">WriteByte</a> (Muint8 b)</td></tr>
<tr class="memdesc:a2b88439ade55836f2e71b94080855460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte to the channel, and returns when it has been sent.  <a href="#a2b88439ade55836f2e71b94080855460">More...</a><br /></td></tr>
<tr class="separator:a2b88439ade55836f2e71b94080855460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a06321f08963d1711b16433ffdad70b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a3a06321f08963d1711b16433ffdad70b">WriteBuffer</a> (const char *buf, unsigned len)</td></tr>
<tr class="memdesc:a3a06321f08963d1711b16433ffdad70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data buffer to the channel, and returns when the last character has been sent by the software (but hardware might still need to do some work).  <a href="#a3a06321f08963d1711b16433ffdad70b">More...</a><br /></td></tr>
<tr class="separator:a3a06321f08963d1711b16433ffdad70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac043ee5beb8c292428f6cf2a987c27a4"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ac043ee5beb8c292428f6cf2a987c27a4">ReadByte</a> ()</td></tr>
<tr class="memdesc:ac043ee5beb8c292428f6cf2a987c27a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from the channel.  <a href="#ac043ee5beb8c292428f6cf2a987c27a4">More...</a><br /></td></tr>
<tr class="separator:ac043ee5beb8c292428f6cf2a987c27a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8095a7465924403cbad1efec5b192e6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a8095a7465924403cbad1efec5b192e6b">ReadBuffer</a> (char *buf, unsigned numberToRead)</td></tr>
<tr class="memdesc:a8095a7465924403cbad1efec5b192e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an exact number of characters from the channel.  <a href="#a8095a7465924403cbad1efec5b192e6b">More...</a><br /></td></tr>
<tr class="separator:a8095a7465924403cbad1efec5b192e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9180847c893e84260f6d3ceebf7b7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#aa9180847c893e84260f6d3ceebf7b7ff">Unread</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;byteOrBytes)</td></tr>
<tr class="memdesc:aa9180847c893e84260f6d3ceebf7b7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given byte or bytes to the stream buffer so they get read at the next read operation.  <a href="#aa9180847c893e84260f6d3ceebf7b7ff">More...</a><br /></td></tr>
<tr class="separator:aa9180847c893e84260f6d3ceebf7b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ea0e811d4f418aa3da909d67307123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a63ea0e811d4f418aa3da909d67307123">UnreadBuffer</a> (const char *buff, unsigned size)</td></tr>
<tr class="memdesc:a63ea0e811d4f418aa3da909d67307123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given bytes to the stream buffer so they get read at the next read operation.  <a href="#a63ea0e811d4f418aa3da909d67307123">More...</a><br /></td></tr>
<tr class="separator:a63ea0e811d4f418aa3da909d67307123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805c7fd6339478512fa700f5a4b943aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a805c7fd6339478512fa700f5a4b943aa">ReadBytes</a> (unsigned numberToRead)</td></tr>
<tr class="memdesc:a805c7fd6339478512fa700f5a4b943aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes directly from the communication channel.  <a href="#a805c7fd6339478512fa700f5a4b943aa">More...</a><br /></td></tr>
<tr class="separator:a805c7fd6339478512fa700f5a4b943aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9746e38f37ab3ea43f96b71ad8b398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#abe9746e38f37ab3ea43f96b71ad8b398">ReadBytesUntil</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;terminatingString)</td></tr>
<tr class="memdesc:abe9746e38f37ab3ea43f96b71ad8b398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from the channel until a specified sequence is read.  <a href="#abe9746e38f37ab3ea43f96b71ad8b398">More...</a><br /></td></tr>
<tr class="separator:abe9746e38f37ab3ea43f96b71ad8b398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cececc0073acf42f63f7ca767608c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a5cececc0073acf42f63f7ca767608c30">ReadBytesUntilAnyByte</a> (const char *finisher, unsigned finisherSize, unsigned headerSize, unsigned footerSize)</td></tr>
<tr class="memdesc:a5cececc0073acf42f63f7ca767608c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from the channel until a specified sequence is read.  <a href="#a5cececc0073acf42f63f7ca767608c30">More...</a><br /></td></tr>
<tr class="separator:a5cececc0073acf42f63f7ca767608c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf1fab92eb368655d0710863cc55fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#aebf1fab92eb368655d0710863cc55fb8">ReadAllBytes</a> ()</td></tr>
<tr class="memdesc:aebf1fab92eb368655d0710863cc55fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an arbitrary number of characters from the channel, as much as available.  <a href="#aebf1fab92eb368655d0710863cc55fb8">More...</a><br /></td></tr>
<tr class="separator:aebf1fab92eb368655d0710863cc55fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ca141b9db717761bdf401318abc24a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a26ca141b9db717761bdf401318abc24a">ClearInputBuffer</a> ()</td></tr>
<tr class="memdesc:a26ca141b9db717761bdf401318abc24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately discards all the pending characters from the channel.  <a href="#a26ca141b9db717761bdf401318abc24a">More...</a><br /></td></tr>
<tr class="separator:a26ca141b9db717761bdf401318abc24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a63e8de38e77fa3bf67adee91b30b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a1a63e8de38e77fa3bf67adee91b30b3d">ClearInputUntilSilence</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:a1a63e8de38e77fa3bf67adee91b30b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep reading and ignoring input until there is silence.  <a href="#a1a63e8de38e77fa3bf67adee91b30b3d">More...</a><br /></td></tr>
<tr class="separator:a1a63e8de38e77fa3bf67adee91b30b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b109b020b1175388ebf364afbc7bd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a16b109b020b1175388ebf364afbc7bd0">FlushOutputBuffer</a> (unsigned numberOfCharsInBuffer=UINT_MAX)=0</td></tr>
<tr class="memdesc:a16b109b020b1175388ebf364afbc7bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the characters from the output buffer are sent.  <a href="#a16b109b020b1175388ebf364afbc7bd0">More...</a><br /></td></tr>
<tr class="separator:a16b109b020b1175388ebf364afbc7bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6738f1560bb852d71c53da9892575f9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ae6738f1560bb852d71c53da9892575f9">IsConnected</a> () const  =0</td></tr>
<tr class="memdesc:ae6738f1560bb852d71c53da9892575f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current connection state of the channel.  <a href="#ae6738f1560bb852d71c53da9892575f9">More...</a><br /></td></tr>
<tr class="separator:ae6738f1560bb852d71c53da9892575f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c61c006adeb0aff63f1ce5bacde570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ab6c61c006adeb0aff63f1ce5bacde570">CheckIfConnected</a> ()</td></tr>
<tr class="memdesc:ab6c61c006adeb0aff63f1ce5bacde570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an appropriate exception if the channel is not connected.  <a href="#ab6c61c006adeb0aff63f1ce5bacde570">More...</a><br /></td></tr>
<tr class="separator:ab6c61c006adeb0aff63f1ce5bacde570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad2da9373f2e42f4cd360b6fb3193fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#afad2da9373f2e42f4cd360b6fb3193fd">CheckIfConnectedConst</a> () const </td></tr>
<tr class="memdesc:afad2da9373f2e42f4cd360b6fb3193fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an appropriate exception if the channel is not connected, constant version.  <a href="#afad2da9373f2e42f4cd360b6fb3193fd">More...</a><br /></td></tr>
<tr class="separator:afad2da9373f2e42f4cd360b6fb3193fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a9e785402be9b22fb02d2c55468c0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#acf7a9e785402be9b22fb02d2c55468c0">GetCountBytesSent</a> () const </td></tr>
<tr class="memdesc:acf7a9e785402be9b22fb02d2c55468c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes sent through the channel since its creation or since the last <a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">ResetCounts()</a>.  <a href="#acf7a9e785402be9b22fb02d2c55468c0">More...</a><br /></td></tr>
<tr class="separator:acf7a9e785402be9b22fb02d2c55468c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267d38dcc27fc894a5fd9651e5b1ba33"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a267d38dcc27fc894a5fd9651e5b1ba33">GetCountBytesReceived</a> () const </td></tr>
<tr class="memdesc:a267d38dcc27fc894a5fd9651e5b1ba33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes received through the channel since creation or since the last <a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">ResetCounts()</a>.  <a href="#a267d38dcc27fc894a5fd9651e5b1ba33">More...</a><br /></td></tr>
<tr class="separator:a267d38dcc27fc894a5fd9651e5b1ba33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1691589a0a91e20604b5a787cb4158"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ada1691589a0a91e20604b5a787cb4158">GetMediaIdentification</a> () const  =0</td></tr>
<tr class="memdesc:ada1691589a0a91e20604b5a787cb4158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that uniquely identifies the media through which this channel is communicating.  <a href="#ada1691589a0a91e20604b5a787cb4158">More...</a><br /></td></tr>
<tr class="separator:ada1691589a0a91e20604b5a787cb4158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d8ae5b8df9566ad5ea7762fcdbd51b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">ResetCounts</a> ()</td></tr>
<tr class="memdesc:a34d8ae5b8df9566ad5ea7762fcdbd51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset channel statistical data, so the counters become zeros.  <a href="#a34d8ae5b8df9566ad5ea7762fcdbd51b">More...</a><br /></td></tr>
<tr class="separator:a34d8ae5b8df9566ad5ea7762fcdbd51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a740949755f31d5ab223d1684b903"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a2e0a740949755f31d5ab223d1684b903">WriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a2e0a740949755f31d5ab223d1684b903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write a message to the monitor, if it is connected.  <a href="#a2e0a740949755f31d5ab223d1684b903">More...</a><br /></td></tr>
<tr class="separator:a2e0a740949755f31d5ab223d1684b903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8480509546b6ef9f66fb3f46e2058419"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a8480509546b6ef9f66fb3f46e2058419">CancelCommunication</a> (bool callDisconnect=false)</td></tr>
<tr class="memdesc:a8480509546b6ef9f66fb3f46e2058419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request canceling of the communication.  <a href="#a8480509546b6ef9f66fb3f46e2058419">More...</a><br /></td></tr>
<tr class="separator:a8480509546b6ef9f66fb3f46e2058419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d9d35a6cf72948a4f4159c473b20f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#af6d9d35a6cf72948a4f4159c473b20f0">EnterUninterruptibleCommunication</a> (bool notify=true)</td></tr>
<tr class="memdesc:af6d9d35a6cf72948a4f4159c473b20f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter a communication sequence that shall not be be interrupted with CancelCommunication call.  <a href="#af6d9d35a6cf72948a4f4159c473b20f0">More...</a><br /></td></tr>
<tr class="separator:af6d9d35a6cf72948a4f4159c473b20f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a520af43484a4d1d24eb2d6ab179229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a4a520af43484a4d1d24eb2d6ab179229">LeaveUninterruptibleCommunication</a> (bool notify=true)</td></tr>
<tr class="memdesc:a4a520af43484a4d1d24eb2d6ab179229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a communication sequence that shall not be be interrupted with CancelCommunication call.  <a href="#a4a520af43484a4d1d24eb2d6ab179229">More...</a><br /></td></tr>
<tr class="separator:a4a520af43484a4d1d24eb2d6ab179229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad2725180f9eb2e168f23636f07475a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a9ad2725180f9eb2e168f23636f07475a">CheckIfOperationIsCancelled</a> ()</td></tr>
<tr class="memdesc:a9ad2725180f9eb2e168f23636f07475a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the user has requested the termination of the communication, and whether the cancel operation lock is zero.  <a href="#a9ad2725180f9eb2e168f23636f07475a">More...</a><br /></td></tr>
<tr class="separator:a9ad2725180f9eb2e168f23636f07475a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaafc50110a58a79c5ea7f7013d0557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#afcaafc50110a58a79c5ea7f7013d0557">Sleep</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:afcaafc50110a58a79c5ea7f7013d0557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel version of Sleep, a delay function that is aware of cancel communication event.  <a href="#afcaafc50110a58a79c5ea7f7013d0557">More...</a><br /></td></tr>
<tr class="separator:afcaafc50110a58a79c5ea7f7013d0557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743ee6acac0495b97ef9c46faa619dd4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a743ee6acac0495b97ef9c46faa619dd4">ReadWithTimeout</a> (char *buf, unsigned size, unsigned timeout)</td></tr>
<tr class="memdesc:a743ee6acac0495b97ef9c46faa619dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read up to size bytes into buffer using the given timeout.  <a href="#a743ee6acac0495b97ef9c46faa619dd4">More...</a><br /></td></tr>
<tr class="separator:a743ee6acac0495b97ef9c46faa619dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afb30fa08d603b57356a3a3f1be6b088a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#afb30fa08d603b57356a3a3f1be6b088a">GetAutoAnswer</a> () const </td></tr>
<tr class="separator:afb30fa08d603b57356a3a3f1be6b088a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff16c64f8d05c5744c5a728091f4f233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#aff16c64f8d05c5744c5a728091f4f233">SetAutoAnswer</a> (bool isAutoAnswer)</td></tr>
<tr class="separator:aff16c64f8d05c5744c5a728091f4f233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab6d52d899465c0fc961a9c3b41779d51"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ab6d52d899465c0fc961a9c3b41779d51">GetAutoAnswerTimeout</a> () const </td></tr>
<tr class="separator:ab6d52d899465c0fc961a9c3b41779d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1437bdded336d977ee79603a837005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a6e1437bdded336d977ee79603a837005">SetAutoAnswerTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:a6e1437bdded336d977ee79603a837005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae251331c8f24481e7bee9ea6b7636816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#ae251331c8f24481e7bee9ea6b7636816">SetMonitor</a> (<a class="el" href="class_m_monitor.html#aafaba455a0c660807e1eb8008e294774">MMonitor::Pointer</a> monitor)</td></tr>
<tr class="separator:ae251331c8f24481e7bee9ea6b7636816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aba12fd3b541d74a7ec1723f10a989b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_monitor.html#aafaba455a0c660807e1eb8008e294774">MMonitor::Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a3aba12fd3b541d74a7ec1723f10a989b">GetMonitor</a> () const </td></tr>
<tr class="separator:a3aba12fd3b541d74a7ec1723f10a989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a47dd88f77e67e6d395a6cb90fa5e2114"><td class="memItemLeft" align="right" valign="top">SHOW_INTERNAL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a47dd88f77e67e6d395a6cb90fa5e2114">GetEcho</a> () const </td></tr>
<tr class="separator:a47dd88f77e67e6d395a6cb90fa5e2114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8133d808fd093b1a01ba046fcf42d9e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a8133d808fd093b1a01ba046fcf42d9e0">SetEcho</a> (bool echo)</td></tr>
<tr class="separator:a8133d808fd093b1a01ba046fcf42d9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23237988170bc2d969c547f13f8945f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a23237988170bc2d969c547f13f8945f4">GetSendEchoBytesToMonitor</a> () const </td></tr>
<tr class="separator:a23237988170bc2d969c547f13f8945f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138748bdbd403da40ea3f6690a174690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a138748bdbd403da40ea3f6690a174690">SetSendEchoBytesToMonitor</a> (bool doSend)</td></tr>
<tr class="separator:a138748bdbd403da40ea3f6690a174690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4e2c74fb3add32214e7a25958ddd2825"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a4e2c74fb3add32214e7a25958ddd2825">GetIntercharacterTimeout</a> () const </td></tr>
<tr class="separator:a4e2c74fb3add32214e7a25958ddd2825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c117100cda361f259cefc22e9ab3bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a85c117100cda361f259cefc22e9ab3bf">SetIntercharacterTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:a85c117100cda361f259cefc22e9ab3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a814dc1177c80113a068bab3b4b1df2ab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a814dc1177c80113a068bab3b4b1df2ab">GetReadTimeout</a> () const </td></tr>
<tr class="separator:a814dc1177c80113a068bab3b4b1df2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb98e5f66f0dc0ab2e673babfe52afe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#aeb98e5f66f0dc0ab2e673babfe52afe3">SetReadTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:aeb98e5f66f0dc0ab2e673babfe52afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a54cf77b62de0053d43e8481798ae94f9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a54cf77b62de0053d43e8481798ae94f9">GetWriteTimeout</a> () const </td></tr>
<tr class="separator:a54cf77b62de0053d43e8481798ae94f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d24341a6fa4b786571bdac2fa4669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#a5c0d24341a6fa4b786571bdac2fa4669">SetWriteTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:a5c0d24341a6fa4b786571bdac2fa4669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d9454ddf99ec17a57e738b7a4c9924"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a21d9454ddf99ec17a57e738b7a4c9924">~MCOMObject</a> ()</td></tr>
<tr class="memdesc:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a035721a745792a3acf0d4b274f1357f7">GetAllPropertyNames</a> () const </td></tr>
<tr class="memdesc:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available properties in MCOM syntax.  <a href="#a035721a745792a3acf0d4b274f1357f7">More...</a><br /></td></tr>
<tr class="separator:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a49655583da819ff86d7798a28537c6a8">GetAllPersistentPropertyNames</a> () const </td></tr>
<tr class="memdesc:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available persistent properties in MCOM syntax.  <a href="#a49655583da819ff86d7798a28537c6a8">More...</a><br /></td></tr>
<tr class="separator:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ae29a16d367eb0adb13332f8ac5fb888c">GetPersistentPropertyValues</a> (bool onlyNondefaults=false, bool excludeSecurityRelated=false) const </td></tr>
<tr class="memdesc:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#ae29a16d367eb0adb13332f8ac5fb888c">More...</a><br /></td></tr>
<tr class="separator:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#acc4469513dd44b58e00cec24dbb6d8a3">SetPersistentPropertyValues</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;values)</td></tr>
<tr class="memdesc:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties for the object using the string with the following format:  <a href="#acc4469513dd44b58e00cec24dbb6d8a3">More...</a><br /></td></tr>
<tr class="separator:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ac1d0975664316b3009c6f4f1822cfa75">SetPropertyValues</a> (const <a class="el" href="class_m_dictionary.html">MDictionary</a> &amp;values)</td></tr>
<tr class="memdesc:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the properties for the object using the property list object.  <a href="#ac1d0975664316b3009c6f4f1822cfa75">More...</a><br /></td></tr>
<tr class="separator:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a7f7d1bbe083159dca4bd92e5d8268ad2">WritePropertiesToMonitor</a> ()</td></tr>
<tr class="memdesc:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all non-default values of protocol properties into monitor.  <a href="#a7f7d1bbe083159dca4bd92e5d8268ad2">More...</a><br /></td></tr>
<tr class="separator:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a74dc8ffe0afce73e590f2206c890a0f2">DoGetPersistentPropertyValues0</a> () const </td></tr>
<tr class="memdesc:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the whole list of persistent property names and their values.  <a href="#a74dc8ffe0afce73e590f2206c890a0f2">More...</a><br /></td></tr>
<tr class="separator:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a68f6f34b5bf5ad5b6cba05aae222bf58">DoGetPersistentPropertyValues1</a> (bool onlyNondefaults) const </td></tr>
<tr class="memdesc:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#a68f6f34b5bf5ad5b6cba05aae222bf58">More...</a><br /></td></tr>
<tr class="separator:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44959297f429d05d4408c88d7596afc4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a44959297f429d05d4408c88d7596afc4">~MObject</a> ()</td></tr>
<tr class="memdesc:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a297127a242f90a602d4ba24243591b52">GetClass</a> () const  =0</td></tr>
<tr class="memdesc:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final class of the object.  <a href="#a297127a242f90a602d4ba24243591b52">More...</a><br /></td></tr>
<tr class="separator:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a87705dec46a625badd4ceda29547b338">GetEmbeddedSizeof</a> () const </td></tr>
<tr class="memdesc:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">For embedded object types, return the size of the class.  <a href="#a87705dec46a625badd4ceda29547b338">More...</a><br /></td></tr>
<tr class="separator:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a203c3127403741b20df02335c1015532">IsEmbeddedObject</a> () const </td></tr>
<tr class="memdesc:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the object is of embedded kind.  <a href="#a203c3127403741b20df02335c1015532">More...</a><br /></td></tr>
<tr class="separator:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">SHOW_INTERNAL <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad752a5e3b6800212e453481287e28067">Call</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;params)</td></tr>
<tr class="memdesc:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant.  <a href="#ad752a5e3b6800212e453481287e28067">More...</a><br /></td></tr>
<tr class="separator:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a62a3a6bb2e0e64a644b0be916a502492">Call0</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with no parameters.  <a href="#a62a3a6bb2e0e64a644b0be916a502492">More...</a><br /></td></tr>
<tr class="separator:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3dafe0a11416dd435a4384678f9fe010">Call1</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1)</td></tr>
<tr class="memdesc:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with one parameter.  <a href="#a3dafe0a11416dd435a4384678f9fe010">More...</a><br /></td></tr>
<tr class="separator:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a47cced5e73d0558ac761367380efde52">Call2</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2)</td></tr>
<tr class="memdesc:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with two parameter.  <a href="#a47cced5e73d0558ac761367380efde52">More...</a><br /></td></tr>
<tr class="separator:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad5b38fa7d1eedf7640183ce1bf750479">Call3</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3)</td></tr>
<tr class="memdesc:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with three parameter.  <a href="#ad5b38fa7d1eedf7640183ce1bf750479">More...</a><br /></td></tr>
<tr class="separator:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#abac65416662f68d208674270c4fc2a95">Call4</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4)</td></tr>
<tr class="memdesc:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with four parameter.  <a href="#abac65416662f68d208674270c4fc2a95">More...</a><br /></td></tr>
<tr class="separator:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a72636f3f379105f9b98eb4644464c96c">Call5</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5)</td></tr>
<tr class="memdesc:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with five parameter.  <a href="#a72636f3f379105f9b98eb4644464c96c">More...</a><br /></td></tr>
<tr class="separator:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3634a9b8b7927122ec3b7e9f08f15be9">Call6</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p6)</td></tr>
<tr class="memdesc:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with six parameter.  <a href="#a3634a9b8b7927122ec3b7e9f08f15be9">More...</a><br /></td></tr>
<tr class="separator:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae7a3f18267d3af7513242e7247c8c40e">CallV</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">MVariant::VariantVector</a> &amp;params)</td></tr>
<tr class="memdesc:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant vector.  <a href="#ae7a3f18267d3af7513242e7247c8c40e">More...</a><br /></td></tr>
<tr class="separator:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99063368f3e5fb4189bcbd13339e47c0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a99063368f3e5fb4189bcbd13339e47c0">IsPropertyPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the property with the given name exists. <br /></td></tr>
<tr class="separator:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d10a068500c82809fcb6d97ea9611da"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a6d10a068500c82809fcb6d97ea9611da">IsServicePresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the service with the given name exists. <br /></td></tr>
<tr class="separator:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a0e84b79fc7c435e2b338f0f9a6239b45">GetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property value using name of the property.  <a href="#a0e84b79fc7c435e2b338f0f9a6239b45">More...</a><br /></td></tr>
<tr class="separator:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a4c04b41d6114e57b12447bd0e07e6af5">SetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="memdesc:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property using name of the property, and value.  <a href="#a4c04b41d6114e57b12447bd0e07e6af5">More...</a><br /></td></tr>
<tr class="separator:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a65eb2f14c14157a7aeead3d68550092f">SetPersistentPropertiesToDefault</a> ()</td></tr>
<tr class="memdesc:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties of the object to their default values.  <a href="#a65eb2f14c14157a7aeead3d68550092f">More...</a><br /></td></tr>
<tr class="separator:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a14384d8101f49cb7616bddd06fe6ecbd">GetPersistentPropertyDefaultValue</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default value of persistent property with the name given.  <a href="#a14384d8101f49cb7616bddd06fe6ecbd">More...</a><br /></td></tr>
<tr class="separator:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a76f62e685cf1f638da5aef8c41ca8586">SetPersistentPropertyToDefault</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent property with the name given to default value.  <a href="#a76f62e685cf1f638da5aef8c41ca8586">More...</a><br /></td></tr>
<tr class="separator:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03324a7bc9b626fe2860beb4b84b6bcc"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a03324a7bc9b626fe2860beb4b84b6bcc">GetType</a> () const </td></tr>
<tr class="memdesc:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the type for the object (could be the same as class name). <br /></td></tr>
<tr class="separator:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a164dbf0ffa4e8c65b9ceffbf1d6fb391">SetType</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;)</td></tr>
<tr class="memdesc:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally, it will set the name of the type for the object, but the service will not allow setting the name to anything other than the current name.  <a href="#a164dbf0ffa4e8c65b9ceffbf1d6fb391">More...</a><br /></td></tr>
<tr class="separator:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#af929f6afc9295557a8c5ead74c6c0b6a">Validate</a> ()</td></tr>
<tr class="memdesc:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate internal structures of the object.  <a href="#af929f6afc9295557a8c5ead74c6c0b6a">More...</a><br /></td></tr>
<tr class="separator:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf365aa9a9584bbc1dc872a7b11dcd16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_channel.html#adf365aa9a9584bbc1dc872a7b11dcd16">MChannel</a> ()</td></tr>
<tr class="memdesc:adf365aa9a9584bbc1dc872a7b11dcd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the channel object from parent class.  <a href="#adf365aa9a9584bbc1dc872a7b11dcd16">More...</a><br /></td></tr>
<tr class="separator:adf365aa9a9584bbc1dc872a7b11dcd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1387ff56bed4d3ce4ed3d7526ffb0eb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a1387ff56bed4d3ce4ed3d7526ffb0eb5">MCOMObject</a> ()</td></tr>
<tr class="memdesc:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fd4059be176487607315d88d715a97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a48fd4059be176487607315d88d715a97">MObject</a> ()</td></tr>
<tr class="memdesc:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a9160d5a51f8d3b85ace23e83f967f269">DoSetPersistentPropertiesToDefault</a> (const <a class="el" href="class_m_class.html">MClass</a> *staticClass)</td></tr>
<tr class="memdesc:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties to their default values for one object provided the class for that object.  <a href="#a9160d5a51f8d3b85ace23e83f967f269">More...</a><br /></td></tr>
<tr class="separator:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#aeba892081e500e981d22a2c54b6a0100">GetStaticClass</a> ()</td></tr>
<tr class="memdesc:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the declared class of this particular object.  <a href="#aeba892081e500e981d22a2c54b6a0100">More...</a><br /></td></tr>
<tr class="separator:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a89f92d51d036637db84d57290616e98b">IsClassPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given class name is available.  <a href="#a89f92d51d036637db84d57290616e98b">More...</a><br /></td></tr>
<tr class="separator:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae930847fb891a40c903b0e5c0ac5bcf0"></a>
static const <a class="el" href="class_m_class.html">MClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae930847fb891a40c903b0e5c0ac5bcf0">s_class</a></td></tr>
<tr class="memdesc:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>. <br /></td></tr>
<tr class="separator:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction of all channel-level communication media. </p>
<p>Channels are intended to provide the mechanism for reading and writing byte streams with timeouts. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8f92f7546c30df757eacfe61108f9032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8f92f7546c30df757eacfe61108f9032ac491d4c3448092a7beb308f4156d2349"></a>CANCEL_COMMUNICATION_CHECK_OPTIMUM_INTERVAL&#160;</td><td class="fielddoc">
<p>How often in milliseconds to check for the communication to cancel. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adf365aa9a9584bbc1dc872a7b11dcd16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MChannel::MChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the channel object from parent class. </p>
<p>The constructor is protected because the class is abstract. </p>

</div>
</div>
<a class="anchor" id="acd01d306b233de3d3a9fd0b60e75c3bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MChannel::~MChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor is public, and virtual. </p>
<p><a class="el" href="class_m_channel.html" title="Abstraction of all channel-level communication media. ">MChannel</a> objects should be deleted by their owner, <a class="el" href="class_m_c_o_m_factory.html" title="Factory that is capable of creating MCOM objects. ">MCOMFactory</a> creates Channels, but does not destroy them. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8480509546b6ef9f66fb3f46e2058419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::CancelCommunication </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callDisconnect</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request canceling of the communication. </p>
<p>This service is typically called from a separate thread. The child channels might try to do some additional processing to cancel the communication. Disconnect will be called only if the parameter of the function is true. </p>

<p>Reimplemented in <a class="el" href="class_m_channel_modem.html#a163ee42a0c4e1e0091391ece12b5854e">MChannelModem</a>.</p>

</div>
</div>
<a class="anchor" id="ab6c61c006adeb0aff63f1ce5bacde570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::CheckIfConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an appropriate exception if the channel is not connected. </p>
<p>The exception can be different depending on whether the connection was not made previously, or if the connection was unexpectedly terminated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is connected, or an exception is thrown. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_channel_socket.html#a4db4572c18582de27fd97e285c7f02be">MChannelSocket</a>, and <a class="el" href="class_m_channel_modem.html#a395eef88a8d4369bea5376051407c35b">MChannelModem</a>.</p>

</div>
</div>
<a class="anchor" id="afad2da9373f2e42f4cd360b6fb3193fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::CheckIfConnectedConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an appropriate exception if the channel is not connected, constant version. </p>
<p>The exception can be different depending on whether the connection was not made previously, or if the connection was unexpectedly terminated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is connected, or an exception is thrown.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#ab6c61c006adeb0aff63f1ce5bacde570">CheckIfConnected</a> - non-constant version of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ad2725180f9eb2e168f23636f07475a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::CheckIfOperationIsCancelled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the user has requested the termination of the communication, and whether the cancel operation lock is zero. </p>
<p>If both conditions are yes, throw an exception <a class="el" href="class_m_e_operation_cancelled.html" title="Exception which is thrown in case the operation is canceled. ">MEOperationCancelled</a>. </p>

</div>
</div>
<a class="anchor" id="a26ca141b9db717761bdf401318abc24a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::ClearInputBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately discards all the pending characters from the channel. </p>
<p>Just like Connect or Disconnect, ClearInputBuffer is synchronous and is not queued. It should be used carefully when mixed with <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s Queue Methods, which are transmitted to the end device only when QCommit is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a1a63e8de38e77fa3bf67adee91b30b3d">ClearInputUntilSilence</a> Keep reading and ignoring input until there is silence. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a63e8de38e77fa3bf67adee91b30b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::ClearInputUntilSilence </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep reading and ignoring input until there is silence. </p>
<p>Useful when it is known that the party will be sending data that has to be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>Time in milliseconds, for how long the party keeps silent for the method to return. Typically, this is equal to intercharacter timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a26ca141b9db717761bdf401318abc24a">ClearInputBuffer</a> Removes all bytes that are already present in the input buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="acb9ead36be06025ce8cd6292824bf59f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::Connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes channel and establishes connection between the computer and the end device. </p>
<p>The specific set of actions depends on the channel type:</p><ul>
<li>For an optical probe, the serial port is opened.</li>
<li>For a modem, the port is opened, then the modem is connected by either dialing-in, or by waiting for the call-back.</li>
<li>For socket channel the outgoing socket is connected or an incoming connection is accepted, depending on channel parameters.</li>
</ul>
<p>Once the connection is established (Connect successfully completed), no other application can connect to the end device using the same communication line. Use the Disconnect method to terminate the connection. Be sure to include Disconnect in error handling routines, to ensure the link is always terminated. Otherwise, other applications may not be able to connect to the end device.</p>
<p>After successful Connect, bytes can be read/written to the meter.</p>
<dl class="section pre"><dt>Precondition</dt><dd>IsConnected should be false before calling this method. Many OS, environment, and program related exceptions can be thrown by this method.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a330d82a247925e1550a4563e2e09550d">Disconnect</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_channel_optical_probe.html#a9d38341e70187ae6b53356845e3d220d">MChannelOpticalProbe</a>, <a class="el" href="class_m_channel_modem.html#aa5b870a580ac3a8503779fd466afc8f9">MChannelModem</a>, <a class="el" href="class_m_channel_serial_port.html#a3aa5b8fb02c47d3162216e44951fe7b9">MChannelSerialPort</a>, <a class="el" href="class_m_channel_socket_udp.html#a1e5df4636ad4851114566dbc7242b786">MChannelSocketUdp</a>, <a class="el" href="class_m_channel_socket.html#aa7889c16ac5f25a4fbdaaf4f1c91373e">MChannelSocket</a>, and <a class="el" href="class_m_channel_socket_base.html#a14936d01c89dc508a4640f59fdb04236">MChannelSocketBase</a>.</p>

</div>
</div>
<a class="anchor" id="a16a5a9f75ff0feba8b7eb9ff0bf38fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_channel.html">MChannel</a>* MChannel::CreateClone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual copy constructor, creates the channel, which is a clone of current. </p>
<p>All persistent properties get copied, all other properties have initial values. Channel will not be connected, etc. </p>

<p>Reimplemented from <a class="el" href="class_m_c_o_m_object.html#aabf9b98757e6ae0b1939879f04ca9bfe">MCOMObject</a>.</p>

</div>
</div>
<a class="anchor" id="a330d82a247925e1550a4563e2e09550d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::Disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect brings down the data link, hangs up the phone, powers down the probe, etc. </p>
<p>After Disconnect, no communication is possible with the meter. Calling Disconnect when the <a class="el" href="class_m_channel.html" title="Abstraction of all channel-level communication media. ">MChannel</a> is not <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f" title="Initializes channel and establishes connection between the computer and the end device. ">Connect()</a>ed has no effect, and Disconnect itself will always be successful.</p>
<ul>
<li>For <a class="el" href="class_m_channel_optical_probe.html" title="Optical probe is a channel based on serial port that is able to control the batteries of the probe (i...">MChannelOpticalProbe</a>, this method simply releases the communication port back to the operating System, sets IsConnected to False, and returns.</li>
<li>For <a class="el" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. ">MChannelModem</a>, a hang up sequence is performed on the modem prior to releasing the communication port back to the operating system and setting IsConnected to False.</li>
</ul>
<p>Disconnect never generates an error. This allows it to be successfully issued even if the channel is not connected. This behavior was implemented in order to simplify handling of situations where the channel holds some resources but IsConnected = FALSE. For example, the modem link is disconnected, but the communication port is open and waiting to reestablish the connection. In this case, IsConnected = FALSE, but the communication port is still being held by the channel. Issuing Disconnect in this case would result in releasing the communication port back to the Operating System. It is not possible to use IsConnected in this situation to determine whether or not to issue the Disconnect method, so the Disconnect method was designed to operate successfully regardless of whether the channel is connected or disconnected.</p>
<p>Use the Connect method to establish the connection between the computer and the end device. As long as the connection exists, no other application can connect to the end device using the same communication line. Use Disconnect to terminate the connection. Include Disconnect in error handling routines, otherwise, other applications may not be able to connect to the end device.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect</a> </dd></dl>

<p>Implemented in <a class="el" href="class_m_channel_optical_probe.html#ac2c8385c28d4c756f9a4a282a6b76d50">MChannelOpticalProbe</a>, <a class="el" href="class_m_channel_modem.html#a02ed3e8d15259566a07e2a904031532d">MChannelModem</a>, <a class="el" href="class_m_channel_socket.html#abeaaf1e314629008b2ce0a4e161e8bac">MChannelSocket</a>, <a class="el" href="class_m_channel_serial_port.html#a37211cd10baa85a3d40699c39af23578">MChannelSerialPort</a>, and <a class="el" href="class_m_channel_socket_base.html#a9eef1d8f894fa038f4bd87fe6c9236fc">MChannelSocketBase</a>.</p>

</div>
</div>
<a class="anchor" id="af6d9d35a6cf72948a4f4159c473b20f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::EnterUninterruptibleCommunication </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter a communication sequence that shall not be be interrupted with CancelCommunication call. </p>
<p>There is also LeaveUninterruptibleCommunication that ends such sequence. The matching pairs of these calls can be stacked. In which case the interruption can happen only after leaving the very top LeaveUninterruptibleCommunication. </p>

</div>
</div>
<a class="anchor" id="a16b109b020b1175388ebf364afbc7bd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::FlushOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numberOfCharsInBuffer</em> = <code>UINT_MAX</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that the characters from the output buffer are sent. </p>
<p>The parameter, if specified, should match the number of characters written into the serial port right before FlushOutputBuffer is called. If the parameter is missing, the biggest possible number of characters will be ensured to go away.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. </dd></dl>

<p>Implemented in <a class="el" href="class_m_channel_socket_base.html#afd24e277f39e9204418ca6196564edd7">MChannelSocketBase</a>, and <a class="el" href="class_m_channel_serial_port.html#ae6bd08d4a06152b55d3eca04fd0bb30c">MChannelSerialPort</a>.</p>

</div>
</div>
<a class="anchor" id="afb30fa08d603b57356a3a3f1be6b088a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MChannel::GetAutoAnswer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the channel initiates the communication or waits for the incoming connection.</p>
<p>When <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect()</a> is issued, the state of Auto Answer determines whether the channel initiates communication (Auto Answer = false), or waits for the incoming connection (Auto Answer = true). When Auto Answer mode is enabled (Auto Answer = true), at the attempt to issue <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect()</a> the channel waits <a class="el" href="class_m_channel.html#ab6d52d899465c0fc961a9c3b41779d51">GetAutoAnswerTimeout</a> seconds for the incoming connection. The connection attempt can take a long time to complete or time out. If the connection is queued with QConnect and committed asynchronously with QCommit(True), then the connection can be aborted with QAbort.</p>
<p>All channels support initiating or waiting for the connection, though the typical use is to initiate the connection.</p>
<dl class="section since"><dt>Since</dt><dd>Available to all channels since MeteringSDK Version 5.0.0.980. </dd>
<dd>
Available to <a class="el" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. ">MChannelModem</a> and <a class="el" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. ">MChannelModemCallback</a> since MeteringSDK Version 2.1.27. </dd>
<dd>
Available to <a class="el" href="class_m_channel_socket.html" title="MChannelSocket implements the channel interface for an TCP/IP socket. ">MChannelSocket</a> and <a class="el" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. ">MChannelSocketCallback</a> since MeteringSDK Version 4.0.15.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False [0], unless otherwise noted. <br />
<a class="el" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. ">MChannelModemCallback</a> defaults to True [1]. <br />
<a class="el" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. ">MChannelSocketCallback</a> defaults to True [1]. <br />
<a class="el" href="class_m_channel_socket_udp_callback.html" title="Socket callback channel is MChannelSocketUdp that has Auto Answer enabled by default. ">MChannelSocketUdpCallback</a> defaults to True [1].</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The channel waits for incoming connection.</li>
<li>False [0] : The channel initiates the connection. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab6d52d899465c0fc961a9c3b41779d51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::GetAutoAnswerTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Time in seconds to wait for the incoming connection.</p>
<p>The number of seconds that the channel listens in <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect()</a> for an inbound call or connection. <a class="el" href="class_m_channel.html#afb30fa08d603b57356a3a3f1be6b088a">GetAutoAnswer</a> must be True for this property to have any effect. This can be a very large value for applications that want to continuously listen, however the maximum possible value is determined by the number of milliseconds in a 32-bit value, therefore, when an attempt is made to set the timeout to a value bigger than 2,147,483 seconds, the result will be about 24 days.</p>
<p>A good idea for the application is to commit the connection asynchronously using <a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">MProtocol::QConnect()</a> and <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">MProtocol::QCommit</a>(bool asynchronous = true). This allows the application to continue to do work while waiting for the incoming connection, and also allows the connection attempt to be aborted with <a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">MProtocol::QAbort()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>Available to all channels since MeteringSDK Version 5.0.0.980. </dd>
<dd>
Available to <a class="el" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. ">MChannelModem</a> and <a class="el" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. ">MChannelModemCallback</a> since MeteringSDK Version 2.1.27. </dd>
<dd>
Available to <a class="el" href="class_m_channel_socket.html" title="MChannelSocket implements the channel interface for an TCP/IP socket. ">MChannelSocket</a> and <a class="el" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. ">MChannelSocketCallback</a> since MeteringSDK Version 4.0.15.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>60 seconds</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXINT seconds. </dt><dd>However, values larger than 2,147,483 seconds may result in unpredictable timeouts as the maximum time is determined by the number of milliseconds in a 32-bit value. Prior to MeteringSDK Version 6.4.0.4908, values larger than 2,147,483 seconds could result in a silent overflow and an unpredictable timeout period. For MeteringSDK Versions 6.4.0.4908 and later, values larger than 2,147,483 seconds will result in a timeout of 2,147,483 seconds (slightly more than 24 days). </dd></dl>

</div>
</div>
<a class="anchor" id="a267d38dcc27fc894a5fd9651e5b1ba33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::GetCountBytesReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes received through the channel since creation or since the last <a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">ResetCounts()</a>. </p>
<p>The count is nullified when the connection is created.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXUINT</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="acf7a9e785402be9b22fb02d2c55468c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::GetCountBytesSent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes sent through the channel since its creation or since the last <a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">ResetCounts()</a>. </p>
<p>This count starts from zero at channel creation, or at a call to <a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">ResetCounts()</a>, and it gets incremented for each byte successfully sent.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXUINT</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a47dd88f77e67e6d395a6cb90fa5e2114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHOW_INTERNAL bool MChannel::GetEcho </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Echo mode, whether the bytes are echoed back, so they have to be read by the channel.</p>
<p>Indicates whether or not the end device echoes every character transmitted through the channel. For example, Echo needs to be enabled for current loop devices and two-wire RS-485 devices.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.0.5.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>True [1] - For <a class="el" href="class_m_channel_current_loop.html" title="MChannelCurrentLoop implements methods necessary for handling RS-232 serial port. ...">MChannelCurrentLoop</a></li>
<li>False [0] - For all other channels</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] - The end device echoes bytes back through the channel.</li>
<li>False [0] - The end device does not echo bytes.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a23237988170bc2d969c547f13f8945f4">GetSendEchoBytesToMonitor</a> - whether or not to send the echoed bytes to monitor. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e2c74fb3add32214e7a25958ddd2825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::GetIntercharacterTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Timeout value in between receiving any two characters.</p>
<p>All channel types have intercharacter timeout property. Intercharacter timeout is only applicable to read operations that request more than one byte. The protocols impose their own restrictions on IntercharacterTimeout, and they control this value while communicating. Advanced users may want to control this property when working directly with the channel using the available read services.</p>
<p>When the value of this property is nonzero, it controls the maximum time to wait between receiving any two consecutive bytes before initiating a timeout condition. Also, when intercharacter timeout is nonzero, ReadTimeout property guards time to receive the first character in the sequence. This mode is often the case for serial communications, and the way all current protocols, except ANSI C12.22, behave.</p>
<p>When this property is zero, the way timeouts are handled by the channel is altered. In this mode, intercharacter timeout is not guarded, however the ReadTimeout property becomes responsible for receiving the whole sequence. This mode is often the case for TCP/IP communications, and is the way ANSI C12.22 behaves.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>500 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd>0 - Special value that alters the way timeouts are handled, see description text. 1 .. MAXINT value of intercharacter timeout in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ada1691589a0a91e20604b5a787cb4158"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MChannel::GetMediaIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string that uniquely identifies the media through which this channel is communicating. </p>
<p>It will typically consist of computer host name, channel type and unique channel parameters pertinent to that channel type. Examples of media identifications:</p><ul>
<li>"myhost:SOCKET:10.65.67.169:1153" - Socket channel initiated from host myhost towards IP address 10.65.67.169 and port 1153.</li>
<li>"wincomp10x64:SERIAL:COM1" - Optical probe channel that uses serial port COM1 of host wincomp10x64.</li>
<li>"wincomp10x64:SERIAL:COM25" - Direct serial channel that uses serial port COM25.</li>
</ul>
<p>Channel types in the media identification string are more generic than MeteringSDK channel type names. For instance, whether the channel is optical probe or a current loop, it will return SERIAL as its identification type. </p>

<p>Implemented in <a class="el" href="class_m_channel_serial_port.html#ac7d80117da6cca303b83b67fe628d76d">MChannelSerialPort</a>, and <a class="el" href="class_m_channel_socket_base.html#a25eb0731968603f5a69aa978910af8d8">MChannelSocketBase</a>.</p>

</div>
</div>
<a class="anchor" id="a3aba12fd3b541d74a7ec1723f10a989b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_monitor.html#aafaba455a0c660807e1eb8008e294774">MMonitor::Pointer</a> MChannel::GetMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Monitor object bound to the channel object.</p>
<p>The <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object allows messages to be sent to a listening monitor application and to save the messages in a binary file that can be viewed later by loading it into the monitor application. The monitor application does not have to be running in order for a client to send messages or capture the communications into a binary file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The monitor pointer must be valid, or NULL.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>Any valid <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a>.</li>
<li>Null pointer to discard the previously set monitor. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a814dc1177c80113a068bab3b4b1df2ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::GetReadTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read timeout, responsible for receiving either the first byte or the whole packet.</p>
<p>The protocols always control this value themselves, while the user will typically handle it only when using the channel services to read from the channel directly.</p>
<p>The meaning of read timeout depends on the value of IntercharacterTimeout property as follows:</p><ul>
<li>When IntercharacterTimeout is nonzero, the read timeout is the maximum time to wait for receiving the first character in a sequence before initiating a timeout condition. In this case, the timeout applicable to all subsequent characters in the same packet is the value of IntercharacterTimeout.</li>
<li>When IntercharacterTimeout is zero, the read timeout is guarding time to receive the whole sequence of bytes requested.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>1000 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXINT, timeout in milliseconds.</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a23237988170bc2d969c547f13f8945f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MChannel::GetSendEchoBytesToMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to send echo bytes to the <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object, applicable to channel types that support the Echo property.</p>
<p>Enable or disable sending the Echo characters to the <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object. Typically, users do not want to see the Echo'ed characters in the communications log. However, for developers that need to debug communication problems, having the Echo'ed characters in the communications log can be helpful.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.2.23.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False [0]</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : Send the echo'ed characters to the <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object. If Echo = false, there are no Echo'ed characters to send, and no error is thrown.</li>
<li>False [0] : Do not send the echo'ed characters.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a47dd88f77e67e6d395a6cb90fa5e2114">GetEcho</a> - property to control the channel echo. </dd></dl>

</div>
</div>
<a class="anchor" id="a54cf77b62de0053d43e8481798ae94f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::GetWriteTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum time to wait for the successful transmission of a packet before initiating a timeout error.</p>
<p>The protocols always control this value themselves. The user will typically handle it only when using the channel services to write to the port directly.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>2000 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXINT, timeout in milliseconds.</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae6738f1560bb852d71c53da9892575f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MChannel::IsConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current connection state of the channel. </p>
<p>IsConnected reflects the assumption the communication component has about the channel state, it does not guarantee that the next action with the channel will be successful. Issue the Connect service to establish the connection and the Disconnect service to terminate the connection.</p>
<ul>
<li>For <a class="el" href="class_m_channel_optical_probe.html" title="Optical probe is a channel based on serial port that is able to control the batteries of the probe (i...">MChannelOpticalProbe</a>, IsConnected will simply indicate that the resources for the communication port have been acquired.</li>
<li>For <a class="el" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. ">MChannelModem</a>, IsConnected indicates that the resources have been acquired and that the modem has also successfully connected to another modem.</li>
</ul>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True - The connection has been established.</li>
<li>False - The connection has not been established. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_m_channel_modem.html#a7c4ee6bc0bec9dba36c1e3f550ab3ca6">MChannelModem</a>, <a class="el" href="class_m_channel_serial_port.html#a54487e2864dda854ce041ae4e59cda7e">MChannelSerialPort</a>, and <a class="el" href="class_m_channel_socket_base.html#abe81346befb2722d44d95c2dc5240366">MChannelSocketBase</a>.</p>

</div>
</div>
<a class="anchor" id="a4a520af43484a4d1d24eb2d6ab179229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::LeaveUninterruptibleCommunication </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a communication sequence that shall not be be interrupted with CancelCommunication call. </p>
<p>There is also EnterUninterruptibleCommunication that ends such sequence. The matching pairs of these calls can be stacked. In which case the interruption can happen only after leaving the very top LeaveUninterruptibleCommunication. The communication is uninterrupted at next interaction with the channel, not at the call of this function. </p>

</div>
</div>
<a class="anchor" id="aebf1fab92eb368655d0710863cc55fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MChannel::ReadAllBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an arbitrary number of characters from the channel, as much as available. </p>
<p>Note this service assumes that the channel has flow control that tells when the read is done.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. Timeout exception is thrown if no characters were read from the channel during read timeout. </dd></dl>

</div>
</div>
<a class="anchor" id="a8095a7465924403cbad1efec5b192e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::ReadBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numberToRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an exact number of characters from the channel. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. The number of characters given as parameter are received within the timeout period. Otherwise the timeout exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ac043ee5beb8c292428f6cf2a987c27a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint8 MChannel::ReadByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte from the channel. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. The character is received within timeout period. Otherwise the timeout exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a805c7fd6339478512fa700f5a4b943aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MChannel::ReadBytes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numberToRead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes directly from the communication channel. </p>
<p>Unusual variations of the protocol can be simulated by sending data to the meter using WriteBytes, then reading the meter's response with ReadBytes. Invalid packets or noise data can also be sent to the meter for test purposes.</p>
<p>Just like Connect or Disconnect, ReadBytes is synchronous and is not queued. It should be used carefully when mixed with the <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s Queue Methods, which are transmitted to the end device only when QCommit is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberToRead</td><td>Number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a4e2c74fb3add32214e7a25958ddd2825">GetIntercharacterTimeout</a> - the number of milliseconds to wait for the byte to arrive before throwing a timeout exception. </dd></dl>

</div>
</div>
<a class="anchor" id="abe9746e38f37ab3ea43f96b71ad8b398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MChannel::ReadBytesUntil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>terminatingString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from the channel until a specified sequence is read. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a4e2c74fb3add32214e7a25958ddd2825">GetIntercharacterTimeout</a> - the number of milliseconds to wait for the byte to arrive before throwing a timeout exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cececc0073acf42f63f7ca767608c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MChannel::ReadBytesUntilAnyByte </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>finisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>finisherSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>headerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>footerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from the channel until a specified sequence is read. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a4e2c74fb3add32214e7a25958ddd2825">GetIntercharacterTimeout</a> - the number of milliseconds to wait for the byte to arrive before throwing a timeout exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a743ee6acac0495b97ef9c46faa619dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MChannel::ReadWithTimeout </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read up to size bytes into buffer using the given timeout. </p>
<p>This method does not use ReadTimeout property, but it will not throw a timeout exception. </p>

</div>
</div>
<a class="anchor" id="a34d8ae5b8df9566ad5ea7762fcdbd51b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::ResetCounts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset channel statistical data, so the counters become zeros. </p>
<p>The list of channel properties that are reset follows:</p><ul>
<li><a class="el" href="class_m_channel.html#a267d38dcc27fc894a5fd9651e5b1ba33">GetCountBytesReceived</a></li>
<li><a class="el" href="class_m_channel.html#acf7a9e785402be9b22fb02d2c55468c0">GetCountBytesSent</a></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">MProtocol::ResetCounts()</a> - reset extra counts available in the protocol, and in the associated channel. </dd></dl>

</div>
</div>
<a class="anchor" id="aff16c64f8d05c5744c5a728091f4f233"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetAutoAnswer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAutoAnswer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the channel initiates the communication or waits for the incoming connection.</p>
<p>When <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect()</a> is issued, the state of Auto Answer determines whether the channel initiates communication (Auto Answer = false), or waits for the incoming connection (Auto Answer = true). When Auto Answer mode is enabled (Auto Answer = true), at the attempt to issue <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect()</a> the channel waits <a class="el" href="class_m_channel.html#ab6d52d899465c0fc961a9c3b41779d51">GetAutoAnswerTimeout</a> seconds for the incoming connection. The connection attempt can take a long time to complete or time out. If the connection is queued with QConnect and committed asynchronously with QCommit(True), then the connection can be aborted with QAbort.</p>
<p>All channels support initiating or waiting for the connection, though the typical use is to initiate the connection.</p>
<dl class="section since"><dt>Since</dt><dd>Available to all channels since MeteringSDK Version 5.0.0.980. </dd>
<dd>
Available to <a class="el" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. ">MChannelModem</a> and <a class="el" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. ">MChannelModemCallback</a> since MeteringSDK Version 2.1.27. </dd>
<dd>
Available to <a class="el" href="class_m_channel_socket.html" title="MChannelSocket implements the channel interface for an TCP/IP socket. ">MChannelSocket</a> and <a class="el" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. ">MChannelSocketCallback</a> since MeteringSDK Version 4.0.15.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False [0], unless otherwise noted. <br />
<a class="el" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. ">MChannelModemCallback</a> defaults to True [1]. <br />
<a class="el" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. ">MChannelSocketCallback</a> defaults to True [1]. <br />
<a class="el" href="class_m_channel_socket_udp_callback.html" title="Socket callback channel is MChannelSocketUdp that has Auto Answer enabled by default. ">MChannelSocketUdpCallback</a> defaults to True [1].</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The channel waits for incoming connection.</li>
<li>False [0] : The channel initiates the connection. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6e1437bdded336d977ee79603a837005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetAutoAnswerTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time in seconds to wait for the incoming connection.</p>
<p>The number of seconds that the channel listens in <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect()</a> for an inbound call or connection. <a class="el" href="class_m_channel.html#afb30fa08d603b57356a3a3f1be6b088a">GetAutoAnswer</a> must be True for this property to have any effect. This can be a very large value for applications that want to continuously listen, however the maximum possible value is determined by the number of milliseconds in a 32-bit value, therefore, when an attempt is made to set the timeout to a value bigger than 2,147,483 seconds, the result will be about 24 days.</p>
<p>A good idea for the application is to commit the connection asynchronously using <a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">MProtocol::QConnect()</a> and <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">MProtocol::QCommit</a>(bool asynchronous = true). This allows the application to continue to do work while waiting for the incoming connection, and also allows the connection attempt to be aborted with <a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">MProtocol::QAbort()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>Available to all channels since MeteringSDK Version 5.0.0.980. </dd>
<dd>
Available to <a class="el" href="class_m_channel_modem.html" title="Modem channel is a channel based on serial port. ">MChannelModem</a> and <a class="el" href="class_m_channel_modem_callback.html" title="Modem callback channel is MChannelModem that has Auto Answer enabled by default. ">MChannelModemCallback</a> since MeteringSDK Version 2.1.27. </dd>
<dd>
Available to <a class="el" href="class_m_channel_socket.html" title="MChannelSocket implements the channel interface for an TCP/IP socket. ">MChannelSocket</a> and <a class="el" href="class_m_channel_socket_callback.html" title="Socket callback channel is MChannelSocket that has Auto Answer enabled by default. ">MChannelSocketCallback</a> since MeteringSDK Version 4.0.15.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>60 seconds</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXINT seconds. </dt><dd>However, values larger than 2,147,483 seconds may result in unpredictable timeouts as the maximum time is determined by the number of milliseconds in a 32-bit value. Prior to MeteringSDK Version 6.4.0.4908, values larger than 2,147,483 seconds could result in a silent overflow and an unpredictable timeout period. For MeteringSDK Versions 6.4.0.4908 and later, values larger than 2,147,483 seconds will result in a timeout of 2,147,483 seconds (slightly more than 24 days). </dd></dl>

</div>
</div>
<a class="anchor" id="a8133d808fd093b1a01ba046fcf42d9e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetEcho </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>echo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Echo mode, whether the bytes are echoed back, so they have to be read by the channel.</p>
<p>Indicates whether or not the end device echoes every character transmitted through the channel. For example, Echo needs to be enabled for current loop devices and two-wire RS-485 devices.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.0.5.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>True [1] - For <a class="el" href="class_m_channel_current_loop.html" title="MChannelCurrentLoop implements methods necessary for handling RS-232 serial port. ...">MChannelCurrentLoop</a></li>
<li>False [0] - For all other channels</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] - The end device echoes bytes back through the channel.</li>
<li>False [0] - The end device does not echo bytes.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a23237988170bc2d969c547f13f8945f4">GetSendEchoBytesToMonitor</a> - whether or not to send the echoed bytes to monitor. </dd></dl>

</div>
</div>
<a class="anchor" id="a85c117100cda361f259cefc22e9ab3bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetIntercharacterTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timeout value in between receiving any two characters.</p>
<p>All channel types have intercharacter timeout property. Intercharacter timeout is only applicable to read operations that request more than one byte. The protocols impose their own restrictions on IntercharacterTimeout, and they control this value while communicating. Advanced users may want to control this property when working directly with the channel using the available read services.</p>
<p>When the value of this property is nonzero, it controls the maximum time to wait between receiving any two consecutive bytes before initiating a timeout condition. Also, when intercharacter timeout is nonzero, ReadTimeout property guards time to receive the first character in the sequence. This mode is often the case for serial communications, and the way all current protocols, except ANSI C12.22, behave.</p>
<p>When this property is zero, the way timeouts are handled by the channel is altered. In this mode, intercharacter timeout is not guarded, however the ReadTimeout property becomes responsible for receiving the whole sequence. This mode is often the case for TCP/IP communications, and is the way ANSI C12.22 behaves.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>500 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd>0 - Special value that alters the way timeouts are handled, see description text. 1 .. MAXINT value of intercharacter timeout in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ae251331c8f24481e7bee9ea6b7636816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_monitor.html#aafaba455a0c660807e1eb8008e294774">MMonitor::Pointer</a>&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Monitor object bound to the channel object.</p>
<p>The <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object allows messages to be sent to a listening monitor application and to save the messages in a binary file that can be viewed later by loading it into the monitor application. The monitor application does not have to be running in order for a client to send messages or capture the communications into a binary file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The monitor pointer must be valid, or NULL.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>Any valid <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a>.</li>
<li>Null pointer to discard the previously set monitor. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aeb98e5f66f0dc0ab2e673babfe52afe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetReadTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read timeout, responsible for receiving either the first byte or the whole packet.</p>
<p>The protocols always control this value themselves, while the user will typically handle it only when using the channel services to read from the channel directly.</p>
<p>The meaning of read timeout depends on the value of IntercharacterTimeout property as follows:</p><ul>
<li>When IntercharacterTimeout is nonzero, the read timeout is the maximum time to wait for receiving the first character in a sequence before initiating a timeout condition. In this case, the timeout applicable to all subsequent characters in the same packet is the value of IntercharacterTimeout.</li>
<li>When IntercharacterTimeout is zero, the read timeout is guarding time to receive the whole sequence of bytes requested.</li>
</ul>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>1000 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXINT, timeout in milliseconds.</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a138748bdbd403da40ea3f6690a174690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetSendEchoBytesToMonitor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to send echo bytes to the <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object, applicable to channel types that support the Echo property.</p>
<p>Enable or disable sending the Echo characters to the <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object. Typically, users do not want to see the Echo'ed characters in the communications log. However, for developers that need to debug communication problems, having the Echo'ed characters in the communications log can be helpful.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.2.23.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False [0]</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : Send the echo'ed characters to the <a class="el" href="class_m_monitor.html" title="Abstract monitor to watch communication. ">MMonitor</a> object. If Echo = false, there are no Echo'ed characters to send, and no error is thrown.</li>
<li>False [0] : Do not send the echo'ed characters.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a47dd88f77e67e6d395a6cb90fa5e2114">GetEcho</a> - property to control the channel echo. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c0d24341a6fa4b786571bdac2fa4669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::SetWriteTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum time to wait for the successful transmission of a packet before initiating a timeout error.</p>
<p>The protocols always control this value themselves. The user will typically handle it only when using the channel services to write to the port directly.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>2000 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. MAXINT, timeout in milliseconds.</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afcaafc50110a58a79c5ea7f7013d0557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::Sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel version of Sleep, a delay function that is aware of cancel communication event. </p>
<p>Different from <a class="el" href="class_m_timer.html#a4d107df93fe5aef90a4f7f255075a2da" title="Sleep for the given number of milliseconds. ">MUtilities.Sleep</a>, this function might throw cancel communication exception. </p>

</div>
</div>
<a class="anchor" id="aa9180847c893e84260f6d3ceebf7b7ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::Unread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given byte or bytes to the stream buffer so they get read at the next read operation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ea0e811d4f418aa3da909d67307123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::UnreadBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the given bytes to the stream buffer so they get read at the next read operation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ab098b8ede4c951f9f9e52e9468d2624f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::WaitForNextIncomingConnection </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reinitialize</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <a class="el" href="class_m_channel.html#afb30fa08d603b57356a3a3f1be6b088a">GetAutoAnswer</a> true, wait for the incoming connection without disconnecting the channel. </p>
<p>A typical server application sequence that uses this call: </p><div class="fragment"><div class="line"><a class="code" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">Connect</a>() <span class="comment">// wait for the first incoming connection</span></div><div class="line">loop until interrupted:</div><div class="line">    ... communicate ...</div><div class="line">    <a class="code" href="class_m_channel.html#ab098b8ede4c951f9f9e52e9468d2624f">WaitForNextIncomingConnection</a>() <span class="comment">// wait for the next incoming connection</span></div><div class="line">end loop</div><div class="line"><a class="code" href="class_m_channel.html#a330d82a247925e1550a4563e2e09550d">Disconnect</a>()</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reinitialize</td><td>Tells if reinitialization of the channel has to be made at each new incoming connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Prior to this call, the channel needs to be configured with <a class="el" href="class_m_channel.html#aff16c64f8d05c5744c5a728091f4f233">SetAutoAnswer</a> true, and the connection established with <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f" title="Initializes channel and establishes connection between the computer and the end device. ">Connect()</a>. Not all channels support Auto Answer mode, and might throw an exception. A timeout exception is thrown if no call is received during the <a class="el" href="class_m_channel.html#ab6d52d899465c0fc961a9c3b41779d51">GetAutoAnswerTimeout</a> period. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_channel_modem.html#a18da974a97f8b2da1dd31042da648c72">MChannelModem</a>, <a class="el" href="class_m_channel_serial_port.html#a17f7f3d9c27b5107a5e1db6c2bfbacbe">MChannelSerialPort</a>, <a class="el" href="class_m_channel_socket_udp.html#ae5750c49cf005446bb3f7c03ab3d9dd4">MChannelSocketUdp</a>, and <a class="el" href="class_m_channel_socket.html#addb86f7546751c0278898791c474e436">MChannelSocket</a>.</p>

</div>
</div>
<a class="anchor" id="a3a06321f08963d1711b16433ffdad70b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::WriteBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the data buffer to the channel, and returns when the last character has been sent by the software (but hardware might still need to do some work). </p>
<p>To ensure that all data is sent, use FlushOutputBuffer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception. The buffer is initialized correctly, otherwise the behavior is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b88439ade55836f2e71b94080855460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::WriteByte </td>
          <td>(</td>
          <td class="paramtype">Muint8&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a byte to the channel, and returns when it has been sent. </p>
<p>After the method returns the hardware might still need to do some work to actually send the buffer. To ensure that all data is sent, use FlushOutputBuffer.</p>
<p>Unusual variations of the protocol can be simulated by sending data to the meter using WriteBytes, then reading the meter's response with ReadBytes. Invalid packets or noise data can also be sent to the meter for test purposes.</p>
<p>Just like Connect or Disconnect, WriteBytes is synchronous and is not queued. It should be used carefully when mixed with <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s Queue Methods, which are transmitted to the end device only when QCommit is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Byte to write to the channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a731c83d6eea5106729ec5ec45c38c404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MChannel::WriteBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the data to the channel, and returns when the last byte has been sent by the software. </p>
<p>After the method returns the hardware might still need to do some work to actually send the buffer. To ensure that all data is sent, use FlushOutputBuffer.</p>
<p>Unusual variations of the protocol can be simulated by sending data to the meter using WriteBytes, then reading the meter's response with ReadBytes. Invalid packets or noise data can also be sent to the meter for test purposes.</p>
<p>Just like Connect or Disconnect, WriteBytes is synchronous and is not queued. It should be used carefully when mixed with <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s Queue Methods, which are transmitted to the end device only when QCommit is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, otherwise the operation fails with an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>An array of bytes to pass to the channel. The byte in the lower bound of the array is the first byte to be transmitted and the byte in the upper bound of the array is the last byte to be transmitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e0a740949755f31d5ab223d1684b903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MChannel::WriteToMonitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously write a message to the monitor, if it is connected. </p>
<p>No errors are ever thrown by this method, if there is no monitor connected, nothing is done. </p>

<p>Reimplemented from <a class="el" href="class_m_c_o_m_object.html#a99ed01aedf686356cf861d77a155088a">MCOMObject</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_channel.html">MChannel</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
