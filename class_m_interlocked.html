<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MInterlocked Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_interlocked.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_m_interlocked-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MInterlocked Class Reference<div class="ingroups"><a class="el" href="group___m_c_o_r_e.html">MCORE</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>System independent lightweight synchronization object that synchronizes the access to one variable across multiple threads.  
 <a href="class_m_interlocked.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad81ab11ba3e7a2a9da061c51a99b564a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad81ab11ba3e7a2a9da061c51a99b564a"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#ad81ab11ba3e7a2a9da061c51a99b564a">ValueType</a></td></tr>
<tr class="memdesc:ad81ab11ba3e7a2a9da061c51a99b564a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used by interlocked class by default. <br /></td></tr>
<tr class="separator:ad81ab11ba3e7a2a9da061c51a99b564a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a329233690520f79f27b8fe08330692c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#a329233690520f79f27b8fe08330692c3">MInterlocked</a> (int value=0)</td></tr>
<tr class="memdesc:a329233690520f79f27b8fe08330692c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the interlocked variable.  <a href="#a329233690520f79f27b8fe08330692c3">More...</a><br /></td></tr>
<tr class="separator:a329233690520f79f27b8fe08330692c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d16ff05550a2843461acbc9e7f794e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#a38d16ff05550a2843461acbc9e7f794e">MInterlocked</a> (const <a class="el" href="class_m_interlocked.html">MInterlocked</a> &amp;other)</td></tr>
<tr class="memdesc:a38d16ff05550a2843461acbc9e7f794e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that copies value from parameter.  <a href="#a38d16ff05550a2843461acbc9e7f794e">More...</a><br /></td></tr>
<tr class="separator:a38d16ff05550a2843461acbc9e7f794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc22eb81e0dbcbb33057cb093f1a9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_interlocked.html">MInterlocked</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#a9cc22eb81e0dbcbb33057cb093f1a9be">operator=</a> (int value)</td></tr>
<tr class="memdesc:a9cc22eb81e0dbcbb33057cb093f1a9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes integer value.  <a href="#a9cc22eb81e0dbcbb33057cb093f1a9be">More...</a><br /></td></tr>
<tr class="separator:a9cc22eb81e0dbcbb33057cb093f1a9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f2e02f021b8f43928632e44fff73fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_interlocked.html">MInterlocked</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#a63f2e02f021b8f43928632e44fff73fd">operator=</a> (const <a class="el" href="class_m_interlocked.html">MInterlocked</a> &amp;other)</td></tr>
<tr class="memdesc:a63f2e02f021b8f43928632e44fff73fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object assignment operator.  <a href="#a63f2e02f021b8f43928632e44fff73fd">More...</a><br /></td></tr>
<tr class="separator:a63f2e02f021b8f43928632e44fff73fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7356cfd3319b81136232ea2881e5a5af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#a7356cfd3319b81136232ea2881e5a5af">operator int</a> () const </td></tr>
<tr class="memdesc:a7356cfd3319b81136232ea2881e5a5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value of the interlocked class.  <a href="#a7356cfd3319b81136232ea2881e5a5af">More...</a><br /></td></tr>
<tr class="separator:a7356cfd3319b81136232ea2881e5a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eaa2305956a5361ae841411c2a88a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#ac3eaa2305956a5361ae841411c2a88a8">operator++</a> ()</td></tr>
<tr class="memdesc:ac3eaa2305956a5361ae841411c2a88a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment this object value and return result.  <a href="#ac3eaa2305956a5361ae841411c2a88a8">More...</a><br /></td></tr>
<tr class="separator:ac3eaa2305956a5361ae841411c2a88a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf74c35553a5a5007ca82acc4c9ef51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#acdf74c35553a5a5007ca82acc4c9ef51">operator++</a> (int)</td></tr>
<tr class="memdesc:acdf74c35553a5a5007ca82acc4c9ef51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment this object value and return previous value.  <a href="#acdf74c35553a5a5007ca82acc4c9ef51">More...</a><br /></td></tr>
<tr class="separator:acdf74c35553a5a5007ca82acc4c9ef51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460455b4d0515c3a380a8857a0574997"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#a460455b4d0515c3a380a8857a0574997">operator--</a> ()</td></tr>
<tr class="memdesc:a460455b4d0515c3a380a8857a0574997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically decrement this object value and return result.  <a href="#a460455b4d0515c3a380a8857a0574997">More...</a><br /></td></tr>
<tr class="separator:a460455b4d0515c3a380a8857a0574997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16380b7296ef65b216f14e3aa5fe7d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#ac16380b7296ef65b216f14e3aa5fe7d3">operator--</a> (int)</td></tr>
<tr class="memdesc:ac16380b7296ef65b216f14e3aa5fe7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically decrement this object value and return previous value.  <a href="#ac16380b7296ef65b216f14e3aa5fe7d3">More...</a><br /></td></tr>
<tr class="separator:ac16380b7296ef65b216f14e3aa5fe7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe685cdc1cb4089ebbf0098ad719435e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#abe685cdc1cb4089ebbf0098ad719435e">IncrementAndFetch</a> (volatile int *v)</td></tr>
<tr class="memdesc:abe685cdc1cb4089ebbf0098ad719435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that atomically increments an integer in the given pointer and returns the new value.  <a href="#abe685cdc1cb4089ebbf0098ad719435e">More...</a><br /></td></tr>
<tr class="separator:abe685cdc1cb4089ebbf0098ad719435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cf68c6633dda8fa321fe9ce81d3c2a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#ad1cf68c6633dda8fa321fe9ce81d3c2a">FetchAndIncrement</a> (volatile int *v)</td></tr>
<tr class="memdesc:ad1cf68c6633dda8fa321fe9ce81d3c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that atomically increments an integer in the given pointer and returns the previous value.  <a href="#ad1cf68c6633dda8fa321fe9ce81d3c2a">More...</a><br /></td></tr>
<tr class="separator:ad1cf68c6633dda8fa321fe9ce81d3c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb104f834e96987e312f4f3ea9d9f9ed"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#afb104f834e96987e312f4f3ea9d9f9ed">DecrementAndFetch</a> (volatile int *v)</td></tr>
<tr class="memdesc:afb104f834e96987e312f4f3ea9d9f9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that atomically decrements an integer in the given pointer and returns the new value.  <a href="#afb104f834e96987e312f4f3ea9d9f9ed">More...</a><br /></td></tr>
<tr class="separator:afb104f834e96987e312f4f3ea9d9f9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab368a97ce86ec2df16f06d8babbf8d73"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_interlocked.html#ab368a97ce86ec2df16f06d8babbf8d73">FetchAndDecrement</a> (volatile int *v)</td></tr>
<tr class="memdesc:ab368a97ce86ec2df16f06d8babbf8d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function that atomically decrements an integer in the given pointer and returns the previous value.  <a href="#ab368a97ce86ec2df16f06d8babbf8d73">More...</a><br /></td></tr>
<tr class="separator:ab368a97ce86ec2df16f06d8babbf8d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>System independent lightweight synchronization object that synchronizes the access to one variable across multiple threads. </p>
<p>At present, the only atomic operations supported are increment and decrement.</p>
<p>Implementation note: On the majority of architectures, assignment to and from a properly aligned unsigned variable is an atomic operation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a329233690520f79f27b8fe08330692c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MInterlocked::MInterlocked </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the interlocked variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Initial value of interlocked variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d16ff05550a2843461acbc9e7f794e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MInterlocked::MInterlocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_interlocked.html">MInterlocked</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor that copies value from parameter. </p>
<p>If during this operation the value of the other object keeps changing, the result value will be consistent, correspond to some value that was held by other object at an unknown time of the copy operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Interlocked object from which to copy value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afb104f834e96987e312f4f3ea9d9f9ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MInterlocked::DecrementAndFetch </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that atomically decrements an integer in the given pointer and returns the new value. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Volatile pointer to the integer that should be decremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value that is the result of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ab368a97ce86ec2df16f06d8babbf8d73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MInterlocked::FetchAndDecrement </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that atomically decrements an integer in the given pointer and returns the previous value. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Volatile pointer to the integer that should be decremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value that had previously been in memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1cf68c6633dda8fa321fe9ce81d3c2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MInterlocked::FetchAndIncrement </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that atomically increments an integer in the given pointer and returns the previous value. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Volatile pointer to the integer that should be incremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value that had previously been in memory. </dd></dl>

</div>
</div>
<a class="anchor" id="abe685cdc1cb4089ebbf0098ad719435e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MInterlocked::IncrementAndFetch </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function that atomically increments an integer in the given pointer and returns the new value. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Volatile pointer to the integer that should be incremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value that is the result of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a7356cfd3319b81136232ea2881e5a5af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MInterlocked::operator int </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value of the interlocked class. </p>
<p>If the object keeps changing from other threads, the result will be a consistent value at some definite but unknown period of time. </p>

</div>
</div>
<a class="anchor" id="ac3eaa2305956a5361ae841411c2a88a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MInterlocked::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically increment this object value and return result. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value that is the result of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="acdf74c35553a5a5007ca82acc4c9ef51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MInterlocked::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically increment this object value and return previous value. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value that had previously been in memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a460455b4d0515c3a380a8857a0574997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MInterlocked::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically decrement this object value and return result. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value that is the result of the operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac16380b7296ef65b216f14e3aa5fe7d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MInterlocked::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically decrement this object value and return previous value. </p>
<p>This operation should be used in multithreaded environments in order to prevent situations when multiple threads would fail to change the same value in a consistent way.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value that had previously been in memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cc22eb81e0dbcbb33057cb093f1a9be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_interlocked.html">MInterlocked</a>&amp; MInterlocked::operator= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator that takes integer value. </p>
<p>When many threads attempt to change interlocked value at the same time, any one can be the last, and the result value will be atomically changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value of interlocked variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63f2e02f021b8f43928632e44fff73fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_interlocked.html">MInterlocked</a>&amp; MInterlocked::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_interlocked.html">MInterlocked</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Object assignment operator. </p>
<p>If during this operation the value of the other object keeps changing, the result value will be consistent, correspond to some value that was held by the other object at an unknown time of the copy operation. If during this operation the value of this object keeps changing with other assignment operators, the result of the copy can be discarded, however if increment or decrement operations are used, the increments will start to work on the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Interlocked object from which to copy value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_interlocked.html">MInterlocked</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
