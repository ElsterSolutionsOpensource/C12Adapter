<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MProtocolC1218 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_protocol_c1218.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_m_protocol_c1218-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MProtocolC1218 Class Reference<div class="ingroups"><a class="el" href="group___m_c_o_m.html">MCOM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols.  
 <a href="class_m_protocol_c1218.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MProtocolC1218:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_protocol_c1218__inherit__graph.png" border="0" usemap="#_m_protocol_c1218_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_protocol_c1218_inherit__map" id="_m_protocol_c1218_inherit__map">
<area shape="rect" id="node6" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. " alt="" coords="5,379,124,405"/>
<area shape="rect" id="node2" href="class_m_protocol_c12.html" title="Generic ANSI C12 abstract protocol, base for C12.18, C12.21, and C12.22. " alt="" coords="13,229,117,256"/>
<area shape="rect" id="node3" href="class_m_protocol.html" title="Abstraction of a communication protocol. " alt="" coords="24,155,105,181"/>
<area shape="rect" id="node4" href="class_m_c_o_m_object.html" title="Root communication object that defines default property handling and configuration location..." alt="" coords="14,80,115,107"/>
<area shape="rect" id="node5" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars..." alt="" coords="29,5,100,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4173550ff10e858368ec6257c122fb3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_protocol_c1218.html#a4173550ff10e858368ec6257c122fb3bab9d961f95a7d7a796ea737245ddfd0b9">SMALLEST_PACKET_SIZE</a> = 32, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c1218.html#a4173550ff10e858368ec6257c122fb3ba857ae5f588ac2c3fedf5286dbe90e0e9">BIGGEST_PACKET_SIZE</a> = 8192, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c1218.html#a4173550ff10e858368ec6257c122fb3bace656629f5449decd6caeb893bddebb4">PACKET_HEADER_AND_FOOTER_LENGTH</a> = 8, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c1218.html#a4173550ff10e858368ec6257c122fb3ba4a7e9c7facfad14df4eca6081d5243e5">MAXIMUM_BAD_PACKET_LENGTH_SLEEP</a> = 1000, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c1218.html#a4173550ff10e858368ec6257c122fb3ba5c57c05602e03704eee26b280ad17ab2">MAXIMUM_BAD_TOGGLE_BIT_SLEEP</a> = 1500
<br />
 }</td></tr>
<tr class="separator:a4173550ff10e858368ec6257c122fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_m_protocol_c12"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_m_protocol_c12')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_m_protocol_c12.html">MProtocolC12</a></td></tr>
<tr class="memitem:a101a273254d6d1b343a7042ffe0d68bc inherit pub_types_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a> { <br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bcab001c6956785d76f54c86fdcfb7d8831">ReadFunctionResponseWhenPresent</a> = 0, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bca5fb91c7616dbb0c1beada4b537fa8bb2">ReadFunctionResponseWhenDesired</a> = 1, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bca8c17152bb67546ee86b478376ce312f2">ReadFunctionResponseAlways</a> = 2
<br />
 }<tr class="memdesc:a101a273254d6d1b343a7042ffe0d68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logic of when ST8 has to be read during execution of function.  <a href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a101a273254d6d1b343a7042ffe0d68bc inherit pub_types_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6db7136fb0112a71d300490bb5dc9 inherit pub_types_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#ab1b6db7136fb0112a71d300490bb5dc9a1e3ae80bbb9f1ead7589eed8f0d5fbe6">READ_SERVICE_OVERHEAD</a> = 4, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#ab1b6db7136fb0112a71d300490bb5dc9a6e702878fd0384ba6715e15c73ca9d4c">WRITE_SERVICE_OVERHEAD</a> = 7, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol_c12.html#ab1b6db7136fb0112a71d300490bb5dc9ab50d26ac1350dfd7835640f8f7693872">PARTIAL_WRITE_SERVICE_OVERHEAD</a> = 9
<br />
 }</td></tr>
<tr class="separator:ab1b6db7136fb0112a71d300490bb5dc9 inherit pub_types_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:acb2efd86856570ae339320ade2841e70 inherit pub_types_class_m_protocol"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a7df75f2423de285046975aa2c250fa06">MAXIMUM_NUMBER_STRING_SIZE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70acd2b89f18226e2b07f46691300abae70">MAXIMUM_SERVICE_NAME_STRING_SIZE</a> = MAXIMUM_NUMBER_STRING_SIZE + 64, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a> = 0x1000, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a7a2476e18495e7f0be160468bfea5d73">MAXIMUM_POSSIBLE_TABLE_OFFSET</a> = 0xFFFFFF, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a955afe7a1975e8484755ee30010fa6a1">MAXIMUM_POSSIBLE_TABLE_LENGTH</a> = 0xFFFFFF
<br />
 }</td></tr>
<tr class="separator:acb2efd86856570ae339320ade2841e70 inherit pub_types_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48fb8eb277613de30019f264fdeb271 inherit pub_types_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad48fb8eb277613de30019f264fdeb271"></a>
typedef std::vector&lt; <a class="el" href="struct_m_protocol_1_1_table_raw_data.html">TableRawData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a></td></tr>
<tr class="memdesc:ad48fb8eb277613de30019f264fdeb271 inherit pub_types_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of table raw data. <br /></td></tr>
<tr class="separator:ad48fb8eb277613de30019f264fdeb271 inherit pub_types_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa7e7ccc2efc24c9c07757cf3f41cc7a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aa7e7ccc2efc24c9c07757cf3f41cc7a5">MProtocolC1218</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel, bool channelIsOwned=true)</td></tr>
<tr class="memdesc:aa7e7ccc2efc24c9c07757cf3f41cc7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new C12.18 protocol with the channel given.  <a href="#aa7e7ccc2efc24c9c07757cf3f41cc7a5">More...</a><br /></td></tr>
<tr class="separator:aa7e7ccc2efc24c9c07757cf3f41cc7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9759fe736cb70a386863fddc11fa8e15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9759fe736cb70a386863fddc11fa8e15"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a9759fe736cb70a386863fddc11fa8e15">~MProtocolC1218</a> ()</td></tr>
<tr class="memdesc:a9759fe736cb70a386863fddc11fa8e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the C12.18 protocol object. <br /></td></tr>
<tr class="separator:a9759fe736cb70a386863fddc11fa8e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5445a7b8ac2e17b4a5227cb58724440a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5445a7b8ac2e17b4a5227cb58724440a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a5445a7b8ac2e17b4a5227cb58724440a">ApplyChannelParameters</a> ()</td></tr>
<tr class="memdesc:a5445a7b8ac2e17b4a5227cb58724440a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the configuration of the channel according to the C12.18 protocol handshake settings. <br /></td></tr>
<tr class="separator:a5445a7b8ac2e17b4a5227cb58724440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a272c467ccc7c59e7f0e456fdb004c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a5a272c467ccc7c59e7f0e456fdb004c2">Identify</a> ()</td></tr>
<tr class="memdesc:a5a272c467ccc7c59e7f0e456fdb004c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Identify request.  <a href="#a5a272c467ccc7c59e7f0e456fdb004c2">More...</a><br /></td></tr>
<tr class="separator:a5a272c467ccc7c59e7f0e456fdb004c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa301bc65a4b2ff7e6cde4886b9327d33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aa301bc65a4b2ff7e6cde4886b9327d33">Negotiate</a> ()</td></tr>
<tr class="memdesc:aa301bc65a4b2ff7e6cde4886b9327d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Negotiate request.  <a href="#aa301bc65a4b2ff7e6cde4886b9327d33">More...</a><br /></td></tr>
<tr class="separator:aa301bc65a4b2ff7e6cde4886b9327d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181c42f7f5e504399ef0d23733bb6925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a181c42f7f5e504399ef0d23733bb6925">GetIdentifiedReferenceStandard</a> () const </td></tr>
<tr class="memdesc:a181c42f7f5e504399ef0d23733bb6925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference standard, as identified by the C12.18 Identify command.  <a href="#a181c42f7f5e504399ef0d23733bb6925">More...</a><br /></td></tr>
<tr class="separator:a181c42f7f5e504399ef0d23733bb6925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ca7d32e7a31558d23923878790c8e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a01ca7d32e7a31558d23923878790c8e6">GetIdentifiedStandardVersion</a> () const </td></tr>
<tr class="memdesc:a01ca7d32e7a31558d23923878790c8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the standard version, as identified by the C12.18 Identify command.  <a href="#a01ca7d32e7a31558d23923878790c8e6">More...</a><br /></td></tr>
<tr class="separator:a01ca7d32e7a31558d23923878790c8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af037dec13c48e64314e9560624a6ff84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#af037dec13c48e64314e9560624a6ff84">GetIdentifiedStandardRevision</a> () const </td></tr>
<tr class="memdesc:af037dec13c48e64314e9560624a6ff84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the standard revision, as identified by the C12.18 Identify command.  <a href="#af037dec13c48e64314e9560624a6ff84">More...</a><br /></td></tr>
<tr class="separator:af037dec13c48e64314e9560624a6ff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9469fd2294caa11aeddfc834a12d67ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a9469fd2294caa11aeddfc834a12d67ac">GetIdentifiedPropertiesPresent</a> () const </td></tr>
<tr class="memdesc:a9469fd2294caa11aeddfc834a12d67ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if Identify command was successful, and IDENTIFIED properties are available.  <a href="#a9469fd2294caa11aeddfc834a12d67ac">More...</a><br /></td></tr>
<tr class="separator:a9469fd2294caa11aeddfc834a12d67ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0a5dd20930b5dcddfd159dc0dcf60b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a1f0a5dd20930b5dcddfd159dc0dcf60b">GetNegotiatedPacketSize</a> () const </td></tr>
<tr class="memdesc:a1f0a5dd20930b5dcddfd159dc0dcf60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet size which was negotiated with the meter in the Negotiate command.  <a href="#a1f0a5dd20930b5dcddfd159dc0dcf60b">More...</a><br /></td></tr>
<tr class="separator:a1f0a5dd20930b5dcddfd159dc0dcf60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01365c27720fb6edf8630970f290461"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#af01365c27720fb6edf8630970f290461">GetNegotiatedMaximumNumberOfPackets</a> () const </td></tr>
<tr class="memdesc:af01365c27720fb6edf8630970f290461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of packets, which was negotiated with the meter in the Negotiate command.  <a href="#af01365c27720fb6edf8630970f290461">More...</a><br /></td></tr>
<tr class="separator:af01365c27720fb6edf8630970f290461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da583022c5a7bb127bd147619299b38"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a6da583022c5a7bb127bd147619299b38">GetNegotiatedSessionBaud</a> () const </td></tr>
<tr class="memdesc:a6da583022c5a7bb127bd147619299b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negotiated session baud, which was returned by the meter in the Negotiate command.  <a href="#a6da583022c5a7bb127bd147619299b38">More...</a><br /></td></tr>
<tr class="separator:a6da583022c5a7bb127bd147619299b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af298e51508b98edcad7f94baa7c93345"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#af298e51508b98edcad7f94baa7c93345">GetNegotiatedPropertiesPresent</a> () const </td></tr>
<tr class="memdesc:af298e51508b98edcad7f94baa7c93345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if Negotiate command was successful, and negotiated properties are available.  <a href="#af298e51508b98edcad7f94baa7c93345">More...</a><br /></td></tr>
<tr class="separator:af298e51508b98edcad7f94baa7c93345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a44846efa76bfd1ae0a66034d98f1893a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a44846efa76bfd1ae0a66034d98f1893a">GetIntercharacterTimeout</a> () const </td></tr>
<tr class="separator:a44846efa76bfd1ae0a66034d98f1893a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf4c1c08d369b34bbd6234a493ec168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aecf4c1c08d369b34bbd6234a493ec168">SetIntercharacterTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:aecf4c1c08d369b34bbd6234a493ec168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a63f65a558ca22cd976774a79cb755cf7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a63f65a558ca22cd976774a79cb755cf7">GetAcknowledgementTimeout</a> () const </td></tr>
<tr class="separator:a63f65a558ca22cd976774a79cb755cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cacb35c92362f3dffa8636f9e2996f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aa2cacb35c92362f3dffa8636f9e2996f">SetAcknowledgementTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:aa2cacb35c92362f3dffa8636f9e2996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afefa52f53b7216835f4b83770a87a3b0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#afefa52f53b7216835f4b83770a87a3b0">GetChannelTrafficTimeout</a> () const </td></tr>
<tr class="separator:afefa52f53b7216835f4b83770a87a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992758a4dbd69a8f38bf9138c5d219c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#ab992758a4dbd69a8f38bf9138c5d219c">SetChannelTrafficTimeout</a> (unsigned timeout)</td></tr>
<tr class="separator:ab992758a4dbd69a8f38bf9138c5d219c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0ff7811021a55cb04c067f0f901fc759"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a0ff7811021a55cb04c067f0f901fc759">GetPacketSize</a> () const </td></tr>
<tr class="separator:a0ff7811021a55cb04c067f0f901fc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cccd7fddbbdda3278a0b4f46364844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a40cccd7fddbbdda3278a0b4f46364844">SetPacketSize</a> (unsigned packetSize)</td></tr>
<tr class="separator:a40cccd7fddbbdda3278a0b4f46364844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaa6e475b3ea0b5f309378a6cf848de3b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aaa6e475b3ea0b5f309378a6cf848de3b">GetMaximumNumberOfPackets</a> () const </td></tr>
<tr class="separator:aaa6e475b3ea0b5f309378a6cf848de3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2618879810d4595899ec61a211dfed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#ad2618879810d4595899ec61a211dfed6">SetMaximumNumberOfPackets</a> (unsigned num)</td></tr>
<tr class="separator:ad2618879810d4595899ec61a211dfed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afbd9cbde13d7bc09c3189b941540a269"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#afbd9cbde13d7bc09c3189b941540a269">GetSessionBaud</a> () const </td></tr>
<tr class="separator:afbd9cbde13d7bc09c3189b941540a269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ca39e3fcb8b56b63b4106bca774b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a29ca39e3fcb8b56b63b4106bca774b1f">SetSessionBaud</a> (unsigned sessionBaud)</td></tr>
<tr class="separator:a29ca39e3fcb8b56b63b4106bca774b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b03492e7d1d03f63b989c1d0c9a56d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> () const </td></tr>
<tr class="separator:a6b03492e7d1d03f63b989c1d0c9a56d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94499b1450b0f8a16f0e77c2dd6dcef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aa94499b1450b0f8a16f0e77c2dd6dcef">SetIssueNegotiateOnStartSession</a> (bool yes)</td></tr>
<tr class="separator:aa94499b1450b0f8a16f0e77c2dd6dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70557df2ceb23bd0f4935392ed1e4eba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a70557df2ceb23bd0f4935392ed1e4eba">GetIssueLogoffOnEndSession</a> () const </td></tr>
<tr class="separator:a70557df2ceb23bd0f4935392ed1e4eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc924303fb3c6d1c2065b64fa5b07c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#adc924303fb3c6d1c2065b64fa5b07c93">SetIssueLogoffOnEndSession</a> (bool yes)</td></tr>
<tr class="separator:adc924303fb3c6d1c2065b64fa5b07c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abb05be2271c312b97c4577d6cd1315e7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#abb05be2271c312b97c4577d6cd1315e7">GetProcedureInitiateTimeout</a> () const </td></tr>
<tr class="separator:abb05be2271c312b97c4577d6cd1315e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72c6ce6de5a486159a7d9fa865beab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#ad72c6ce6de5a486159a7d9fa865beab6">SetProcedureInitiateTimeout</a> (unsigned procedureInitiateTimeout)</td></tr>
<tr class="separator:ad72c6ce6de5a486159a7d9fa865beab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a098e64d06dde8d9e9f0edccf7fdc2a75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a098e64d06dde8d9e9f0edccf7fdc2a75">GetNextOutgoingToggleBit</a> () const </td></tr>
<tr class="separator:a098e64d06dde8d9e9f0edccf7fdc2a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530ef727608be3cad6d5260de719c5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a530ef727608be3cad6d5260de719c5d4">SetNextOutgoingToggleBit</a> (bool yes)</td></tr>
<tr class="separator:a530ef727608be3cad6d5260de719c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7889aaf314926c451c2c5e13d57951fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a7889aaf314926c451c2c5e13d57951fd">SetWakeUpSharedOpticalPort</a> (bool wakeUp)</td></tr>
<tr class="separator:a7889aaf314926c451c2c5e13d57951fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326b8097ee0137143260810d072ddf89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a326b8097ee0137143260810d072ddf89">GetWakeUpSharedOpticalPort</a> () const </td></tr>
<tr class="separator:a326b8097ee0137143260810d072ddf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8bc9f7f7b6cb31e73337ead3298b42d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a8bc9f7f7b6cb31e73337ead3298b42d6">GetCheckIncomingToggleBit</a> () const </td></tr>
<tr class="separator:a8bc9f7f7b6cb31e73337ead3298b42d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cb15b4f7ce4901fedff404bd6e25bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a62cb15b4f7ce4901fedff404bd6e25bf">SetCheckIncomingToggleBit</a> (bool doCheck)</td></tr>
<tr class="separator:a62cb15b4f7ce4901fedff404bd6e25bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_protocol_c12"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_protocol_c12')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_protocol_c12.html">MProtocolC12</a></td></tr>
<tr class="memitem:a800259ba467f3410801e6c6b3504bb9b inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a800259ba467f3410801e6c6b3504bb9b">~MProtocolC12</a> ()</td></tr>
<tr class="memdesc:a800259ba467f3410801e6c6b3504bb9b inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the C12 protocol object.  <a href="#a800259ba467f3410801e6c6b3504bb9b">More...</a><br /></td></tr>
<tr class="separator:a800259ba467f3410801e6c6b3504bb9b inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca4e7b5d3ae6da1b160b520b2b1728e inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a4ca4e7b5d3ae6da1b160b520b2b1728e">Logon</a> ()</td></tr>
<tr class="memdesc:a4ca4e7b5d3ae6da1b160b520b2b1728e inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Logon service.  <a href="#a4ca4e7b5d3ae6da1b160b520b2b1728e">More...</a><br /></td></tr>
<tr class="separator:a4ca4e7b5d3ae6da1b160b520b2b1728e inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fde8c7dc31790774993c984ea7b403 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad6fde8c7dc31790774993c984ea7b403">Security</a> ()</td></tr>
<tr class="memdesc:ad6fde8c7dc31790774993c984ea7b403 inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Security service.  <a href="#ad6fde8c7dc31790774993c984ea7b403">More...</a><br /></td></tr>
<tr class="separator:ad6fde8c7dc31790774993c984ea7b403 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2e3350005bee20e6ffd9bd39f875a inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a87b2e3350005bee20e6ffd9bd39f875a">FullLogin</a> ()</td></tr>
<tr class="memdesc:a87b2e3350005bee20e6ffd9bd39f875a inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform whatever is required by the protocol to clear security with the meter.  <a href="#a87b2e3350005bee20e6ffd9bd39f875a">More...</a><br /></td></tr>
<tr class="separator:a87b2e3350005bee20e6ffd9bd39f875a inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeedd60972e30daaa70274dcab5dd33d inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aeeedd60972e30daaa70274dcab5dd33d">Logoff</a> ()</td></tr>
<tr class="memdesc:aeeedd60972e30daaa70274dcab5dd33d inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Logoff service.  <a href="#aeeedd60972e30daaa70274dcab5dd33d">More...</a><br /></td></tr>
<tr class="separator:aeeedd60972e30daaa70274dcab5dd33d inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2037a107e2308035f797ec0c702a2428 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a2037a107e2308035f797ec0c702a2428">Wait</a> (unsigned seconds)</td></tr>
<tr class="memdesc:a2037a107e2308035f797ec0c702a2428 inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Wait service.  <a href="#a2037a107e2308035f797ec0c702a2428">More...</a><br /></td></tr>
<tr class="separator:a2037a107e2308035f797ec0c702a2428 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee47d2594f1c05ba4d48334d77ec93 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a47ee47d2594f1c05ba4d48334d77ec93">Terminate</a> ()</td></tr>
<tr class="memdesc:a47ee47d2594f1c05ba4d48334d77ec93 inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ANSI C12 Terminate service.  <a href="#a47ee47d2594f1c05ba4d48334d77ec93">More...</a><br /></td></tr>
<tr class="separator:a47ee47d2594f1c05ba4d48334d77ec93 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad781dfc93f91866eb9ac2865ce9c0e1c inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual Muint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad781dfc93f91866eb9ac2865ce9c0e1c">CalculateCRC16FromBuffer</a> (const char *buffer, unsigned length) const </td></tr>
<tr class="memdesc:ad781dfc93f91866eb9ac2865ce9c0e1c inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-byte CRC calculation procedure specific to C12 protocol.  <a href="#ad781dfc93f91866eb9ac2865ce9c0e1c">More...</a><br /></td></tr>
<tr class="separator:ad781dfc93f91866eb9ac2865ce9c0e1c inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6781d4aa9fae4b507dd76b70a00f7ac3 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a6781d4aa9fae4b507dd76b70a00f7ac3">GetMaximumReadTableSize</a> () const </td></tr>
<tr class="memdesc:a6781d4aa9fae4b507dd76b70a00f7ac3 inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum possible size of a table to read partially or fully in a single application layer packet.  <a href="#a6781d4aa9fae4b507dd76b70a00f7ac3">More...</a><br /></td></tr>
<tr class="separator:a6781d4aa9fae4b507dd76b70a00f7ac3 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00383e3d04e77b0f4331efd1e1a7bc51 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a00383e3d04e77b0f4331efd1e1a7bc51">CalculateChecksumFromBuffer</a> (const char *buffer, unsigned length) const </td></tr>
<tr class="memdesc:a00383e3d04e77b0f4331efd1e1a7bc51 inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent one-byte checksum calculation procedure that uses buffer and its size.  <a href="#a00383e3d04e77b0f4331efd1e1a7bc51">More...</a><br /></td></tr>
<tr class="separator:a00383e3d04e77b0f4331efd1e1a7bc51 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b6dceb2e6e519d524e03ef812d11a inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#add7b6dceb2e6e519d524e03ef812d11a">ApplicationLayerRequestResponse</a> (char command, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:add7b6dceb2e6e519d524e03ef812d11a inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the full application layer request and return a response.  <a href="#add7b6dceb2e6e519d524e03ef812d11a">More...</a><br /></td></tr>
<tr class="separator:add7b6dceb2e6e519d524e03ef812d11a inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e449f54f53f85ec3e86026d1f2f874 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a80e449f54f53f85ec3e86026d1f2f874">ReceiveServiceCode</a> ()</td></tr>
<tr class="memdesc:a80e449f54f53f85ec3e86026d1f2f874 inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a code of the incoming application layer data packet.  <a href="#a80e449f54f53f85ec3e86026d1f2f874">More...</a><br /></td></tr>
<tr class="separator:a80e449f54f53f85ec3e86026d1f2f874 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c52d5cf88970f3d7b9af93329c4afd inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a03c52d5cf88970f3d7b9af93329c4afd">ReceiveServiceByte</a> ()</td></tr>
<tr class="memdesc:a03c52d5cf88970f3d7b9af93329c4afd inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte from the incoming application layer data packet.  <a href="#a03c52d5cf88970f3d7b9af93329c4afd">More...</a><br /></td></tr>
<tr class="separator:a03c52d5cf88970f3d7b9af93329c4afd inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf12a9c3e16baf235353f449be5b77ab inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#adf12a9c3e16baf235353f449be5b77ab">ReceiveServiceUInt</a> (unsigned size)</td></tr>
<tr class="memdesc:adf12a9c3e16baf235353f449be5b77ab inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several bytes from the incoming application layer data packet.  <a href="#adf12a9c3e16baf235353f449be5b77ab">More...</a><br /></td></tr>
<tr class="separator:adf12a9c3e16baf235353f449be5b77ab inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b92f863b59fcac9b865a39b41a66dd inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad6b92f863b59fcac9b865a39b41a66dd">ReceiveServiceBytes</a> (unsigned length)</td></tr>
<tr class="memdesc:ad6b92f863b59fcac9b865a39b41a66dd inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several bytes of the incoming application layer data packet.  <a href="#ad6b92f863b59fcac9b865a39b41a66dd">More...</a><br /></td></tr>
<tr class="separator:ad6b92f863b59fcac9b865a39b41a66dd inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5602d36bc610094386de8122b4d9f05f inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a5602d36bc610094386de8122b4d9f05f">ReceiveServiceRemainingBytes</a> ()</td></tr>
<tr class="memdesc:a5602d36bc610094386de8122b4d9f05f inherit pub_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes of the incoming application layer data packet.  <a href="#a5602d36bc610094386de8122b4d9f05f">More...</a><br /></td></tr>
<tr class="separator:a5602d36bc610094386de8122b4d9f05f inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cbf50c3fe4c8b5f882d3d6c41f860c inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a83cbf50c3fe4c8b5f882d3d6c41f860c">GetLinkLayerRetries</a> () const </td></tr>
<tr class="separator:a83cbf50c3fe4c8b5f882d3d6c41f860c inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081e76c597fce9b27afb371dcb196397 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a081e76c597fce9b27afb371dcb196397">SetLinkLayerRetries</a> (unsigned retries)</td></tr>
<tr class="separator:a081e76c597fce9b27afb371dcb196397 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72abca6518a456402fddb87c57cc1dc inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ac72abca6518a456402fddb87c57cc1dc">GetIssueSecurityOnStartSession</a> () const </td></tr>
<tr class="separator:ac72abca6518a456402fddb87c57cc1dc inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ba7c99bbbe38cb5ba6775b4f2bfe96 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ae4ba7c99bbbe38cb5ba6775b4f2bfe96">SetIssueSecurityOnStartSession</a> (bool)</td></tr>
<tr class="separator:ae4ba7c99bbbe38cb5ba6775b4f2bfe96 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6315b81d46343250904f858044458d76 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a6315b81d46343250904f858044458d76">GetAlwaysReadFunctionResponse</a> () const </td></tr>
<tr class="separator:a6315b81d46343250904f858044458d76 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a414d2e935e1a733fc0422a26cc59 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad40a414d2e935e1a733fc0422a26cc59">SetAlwaysReadFunctionResponse</a> (<a class="el" href="class_m_protocol_c12.html#a101a273254d6d1b343a7042ffe0d68bc">ReadFunctionResponseEnum</a> value)</td></tr>
<tr class="separator:ad40a414d2e935e1a733fc0422a26cc59 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53a70a87fd5762faa9343d94e90651 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a1e53a70a87fd5762faa9343d94e90651">GetAlwaysUsePartial</a> () const </td></tr>
<tr class="separator:a1e53a70a87fd5762faa9343d94e90651 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e1a04ca84321239b78e4b77e748950 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a94e1a04ca84321239b78e4b77e748950">SetAlwaysUsePartial</a> (bool yes)</td></tr>
<tr class="separator:a94e1a04ca84321239b78e4b77e748950 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146ef42e1040bd735fa82bb97d7f893b inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a146ef42e1040bd735fa82bb97d7f893b">GetUseReadInKeepSessionAlive</a> () const </td></tr>
<tr class="separator:a146ef42e1040bd735fa82bb97d7f893b inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a43f1026237f4b14d8e2b553123b53b inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a9a43f1026237f4b14d8e2b553123b53b">SetUseReadInKeepSessionAlive</a> (bool yes)</td></tr>
<tr class="separator:a9a43f1026237f4b14d8e2b553123b53b inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e79193a4c47c45f7d70fb6f4e824a3 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a02e79193a4c47c45f7d70fb6f4e824a3">GetUserId</a> () const </td></tr>
<tr class="separator:a02e79193a4c47c45f7d70fb6f4e824a3 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a00abedf0f78c28ca860e7e4b7eb2 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#abd0a00abedf0f78c28ca860e7e4b7eb2">SetUserId</a> (unsigned userId)</td></tr>
<tr class="separator:abd0a00abedf0f78c28ca860e7e4b7eb2 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab743cbb677afa0790653f03698b9850e inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ab743cbb677afa0790653f03698b9850e">GetUser</a> () const </td></tr>
<tr class="separator:ab743cbb677afa0790653f03698b9850e inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c52a6b797045c8fb739a2d512ad3d6 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad6c52a6b797045c8fb739a2d512ad3d6">SetUser</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;userName)</td></tr>
<tr class="separator:ad6c52a6b797045c8fb739a2d512ad3d6 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba17f8b403b824f484d56872640ceb83 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aba17f8b403b824f484d56872640ceb83">GetTurnAroundDelay</a> () const </td></tr>
<tr class="separator:aba17f8b403b824f484d56872640ceb83 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364147a8f5d419e7555dccda9ae8c0eb inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a364147a8f5d419e7555dccda9ae8c0eb">SetTurnAroundDelay</a> (unsigned delay)</td></tr>
<tr class="separator:a364147a8f5d419e7555dccda9ae8c0eb inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68720d1a83fe953d500e259cd3c25f37 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a68720d1a83fe953d500e259cd3c25f37">GetApplicationLayerRetries</a> () const </td></tr>
<tr class="separator:a68720d1a83fe953d500e259cd3c25f37 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1492dc4303aaba34492ae85f7b9f2098 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a1492dc4303aaba34492ae85f7b9f2098">SetApplicationLayerRetries</a> (unsigned retries)</td></tr>
<tr class="separator:a1492dc4303aaba34492ae85f7b9f2098 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c2380742033d82f2f2a73a5cbb3fb inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ade7c2380742033d82f2f2a73a5cbb3fb">GetApplicationLayerRetryDelay</a> () const </td></tr>
<tr class="separator:ade7c2380742033d82f2f2a73a5cbb3fb inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bceb67a0c9486070dbb02b9b3f6982c inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a6bceb67a0c9486070dbb02b9b3f6982c">SetApplicationLayerRetryDelay</a> (unsigned milliseconds)</td></tr>
<tr class="separator:a6bceb67a0c9486070dbb02b9b3f6982c inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584c3e57c6bc43ef22ea6ec4307d237 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#af584c3e57c6bc43ef22ea6ec4307d237">GetApplicationLayerProcedureRetries</a> () const </td></tr>
<tr class="separator:af584c3e57c6bc43ef22ea6ec4307d237 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb6a66e89731e89b4c812f78e4d2c57 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a4eb6a66e89731e89b4c812f78e4d2c57">SetApplicationLayerProcedureRetries</a> (unsigned retries)</td></tr>
<tr class="separator:a4eb6a66e89731e89b4c812f78e4d2c57 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ca720e8642357c5ea508438699883b inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a67ca720e8642357c5ea508438699883b">GetApplicationLayerProcedureRetryDelay</a> () const </td></tr>
<tr class="separator:a67ca720e8642357c5ea508438699883b inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca28f4ac408b77fc27c7b2b9b88422d5 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aca28f4ac408b77fc27c7b2b9b88422d5">SetApplicationLayerProcedureRetryDelay</a> (unsigned milliseconds)</td></tr>
<tr class="separator:aca28f4ac408b77fc27c7b2b9b88422d5 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d19806287de5f72638af728763bb2ed inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a1d19806287de5f72638af728763bb2ed">GetProcedureSequenceNumber</a> () const </td></tr>
<tr class="separator:a1d19806287de5f72638af728763bb2ed inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711c67714f108b262fe7c5de9021311e inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a711c67714f108b262fe7c5de9021311e">SetProcedureSequenceNumber</a> (unsigned number)</td></tr>
<tr class="separator:a711c67714f108b262fe7c5de9021311e inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1a5e69e3c698e7e0f232191513eb79 inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#abd1a5e69e3c698e7e0f232191513eb79">SetEndSessionOnApplicationLayerError</a> (bool endSessionOnApplicationLayerError)</td></tr>
<tr class="separator:abd1a5e69e3c698e7e0f232191513eb79 inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf83a00802dc74fc07448f43daa944d inherit pub_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a9cf83a00802dc74fc07448f43daa944d">GetEndSessionOnApplicationLayerError</a> () const </td></tr>
<tr class="separator:a9cf83a00802dc74fc07448f43daa944d inherit pub_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:a2c41fddbb0e3418dc453981c6136028a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_protocol.html">MProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2c41fddbb0e3418dc453981c6136028a">CreateClone</a> () const </td></tr>
<tr class="memdesc:a2c41fddbb0e3418dc453981c6136028a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual copy constructor, creates the protocol which is a clone of current.  <a href="#a2c41fddbb0e3418dc453981c6136028a">More...</a><br /></td></tr>
<tr class="separator:a2c41fddbb0e3418dc453981c6136028a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86685e09ca825849a21b6818c0d2115e inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a86685e09ca825849a21b6818c0d2115e">~MProtocol</a> ()=0</td></tr>
<tr class="memdesc:a86685e09ca825849a21b6818c0d2115e inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the protocol object.  <a href="#a86685e09ca825849a21b6818c0d2115e">More...</a><br /></td></tr>
<tr class="separator:a86685e09ca825849a21b6818c0d2115e inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6479689e3e13a1a11a34b64da99f51 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a3a6479689e3e13a1a11a34b64da99f51">Finalize</a> ()</td></tr>
<tr class="memdesc:a3a6479689e3e13a1a11a34b64da99f51 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute this method as first action in the destructor of any child protocol.  <a href="#a3a6479689e3e13a1a11a34b64da99f51">More...</a><br /></td></tr>
<tr class="separator:a3a6479689e3e13a1a11a34b64da99f51 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367a451ecf3e98ef7363fa98e53e6add inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a367a451ecf3e98ef7363fa98e53e6add">GetCountApplicationLayerServicesSuccessful</a> () const </td></tr>
<tr class="memdesc:a367a451ecf3e98ef7363fa98e53e6add inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have been successfully processed.  <a href="#a367a451ecf3e98ef7363fa98e53e6add">More...</a><br /></td></tr>
<tr class="separator:a367a451ecf3e98ef7363fa98e53e6add inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25fc291953561e4eb248174bc07856e inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af25fc291953561e4eb248174bc07856e">IncrementCountApplicationLayerServicesSuccessful</a> ()</td></tr>
<tr class="memdesc:af25fc291953561e4eb248174bc07856e inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services successfully processed.  <a href="#af25fc291953561e4eb248174bc07856e">More...</a><br /></td></tr>
<tr class="separator:af25fc291953561e4eb248174bc07856e inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab290272e66fd881e1d67010d44451376 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab290272e66fd881e1d67010d44451376">GetCountApplicationLayerServicesRetried</a> () const </td></tr>
<tr class="memdesc:ab290272e66fd881e1d67010d44451376 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have been retried.  <a href="#ab290272e66fd881e1d67010d44451376">More...</a><br /></td></tr>
<tr class="separator:ab290272e66fd881e1d67010d44451376 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c110d281bbb7779b7bbbfc12b5b1d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae57c110d281bbb7779b7bbbfc12b5b1d">IncrementCountApplicationLayerServicesRetried</a> ()</td></tr>
<tr class="memdesc:ae57c110d281bbb7779b7bbbfc12b5b1d inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services retried.  <a href="#ae57c110d281bbb7779b7bbbfc12b5b1d">More...</a><br /></td></tr>
<tr class="separator:ae57c110d281bbb7779b7bbbfc12b5b1d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ad7accc31c929f4a4b8ff4fbc13549 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a17ad7accc31c929f4a4b8ff4fbc13549">GetCountApplicationLayerServicesFailed</a> () const </td></tr>
<tr class="memdesc:a17ad7accc31c929f4a4b8ff4fbc13549 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have failed.  <a href="#a17ad7accc31c929f4a4b8ff4fbc13549">More...</a><br /></td></tr>
<tr class="separator:a17ad7accc31c929f4a4b8ff4fbc13549 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bffec5063153017e67fdd4d667f5cb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a60bffec5063153017e67fdd4d667f5cb">IncrementCountApplicationLayerServicesFailed</a> ()</td></tr>
<tr class="memdesc:a60bffec5063153017e67fdd4d667f5cb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services failed.  <a href="#a60bffec5063153017e67fdd4d667f5cb">More...</a><br /></td></tr>
<tr class="separator:a60bffec5063153017e67fdd4d667f5cb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ba7737c1a7033a784e732539fd442 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a425ba7737c1a7033a784e732539fd442">GetCountLinkLayerPacketsSuccessful</a> () const </td></tr>
<tr class="memdesc:a425ba7737c1a7033a784e732539fd442 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Link Layer packets that have been successfully processed.  <a href="#a425ba7737c1a7033a784e732539fd442">More...</a><br /></td></tr>
<tr class="separator:a425ba7737c1a7033a784e732539fd442 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735e02e29d2dd177059a8cdc15eb6a71 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a735e02e29d2dd177059a8cdc15eb6a71">IncrementCountLinkLayerPacketsSuccessful</a> ()</td></tr>
<tr class="memdesc:a735e02e29d2dd177059a8cdc15eb6a71 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets successfully processed.  <a href="#a735e02e29d2dd177059a8cdc15eb6a71">More...</a><br /></td></tr>
<tr class="separator:a735e02e29d2dd177059a8cdc15eb6a71 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab563dd4909235f42bf80bd5a7d77e05b inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab563dd4909235f42bf80bd5a7d77e05b">GetCountLinkLayerPacketsRetried</a> () const </td></tr>
<tr class="memdesc:ab563dd4909235f42bf80bd5a7d77e05b inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Link Layer packets that have been retried.  <a href="#ab563dd4909235f42bf80bd5a7d77e05b">More...</a><br /></td></tr>
<tr class="separator:ab563dd4909235f42bf80bd5a7d77e05b inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970a90af9476866a8e6b39dbef89c627 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a970a90af9476866a8e6b39dbef89c627">IncrementCountLinkLayerPacketsRetried</a> ()</td></tr>
<tr class="memdesc:a970a90af9476866a8e6b39dbef89c627 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets retried.  <a href="#a970a90af9476866a8e6b39dbef89c627">More...</a><br /></td></tr>
<tr class="separator:a970a90af9476866a8e6b39dbef89c627 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d9dd2722b89549334dbf3ea785052a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80d9dd2722b89549334dbf3ea785052a">GetCountLinkLayerPacketsFailed</a> () const </td></tr>
<tr class="memdesc:a80d9dd2722b89549334dbf3ea785052a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of data link layer packets failed.  <a href="#a80d9dd2722b89549334dbf3ea785052a">More...</a><br /></td></tr>
<tr class="separator:a80d9dd2722b89549334dbf3ea785052a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c162f21b2b82300532288a630238cbd inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0c162f21b2b82300532288a630238cbd">IncrementCountLinkLayerPacketsFailed</a> ()</td></tr>
<tr class="memdesc:a0c162f21b2b82300532288a630238cbd inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets failed.  <a href="#a0c162f21b2b82300532288a630238cbd">More...</a><br /></td></tr>
<tr class="separator:a0c162f21b2b82300532288a630238cbd inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86283365bd46d047e5dbc0048b7b00cd inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a> () const </td></tr>
<tr class="memdesc:a86283365bd46d047e5dbc0048b7b00cd inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum measured approximate packet round trip time over the link layer.  <a href="#a86283365bd46d047e5dbc0048b7b00cd">More...</a><br /></td></tr>
<tr class="separator:a86283365bd46d047e5dbc0048b7b00cd inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1d46c353f5e4f8cac3bf8ed8dc7a2 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a> () const </td></tr>
<tr class="memdesc:af1d1d46c353f5e4f8cac3bf8ed8dc7a2 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum measured approximate packet round trip time over the link layer.  <a href="#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">More...</a><br /></td></tr>
<tr class="separator:af1d1d46c353f5e4f8cac3bf8ed8dc7a2 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45ec72043fe42c32b414d1448fab12 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a> () const </td></tr>
<tr class="memdesc:a9b45ec72043fe42c32b414d1448fab12 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the average measured approximate packet round trip time over the link layer.  <a href="#a9b45ec72043fe42c32b414d1448fab12">More...</a><br /></td></tr>
<tr class="separator:a9b45ec72043fe42c32b414d1448fab12 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d5080403580f3317fc9eade19882d4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a02d5080403580f3317fc9eade19882d4">ClearPasswordList</a> ()</td></tr>
<tr class="memdesc:a02d5080403580f3317fc9eade19882d4 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the password list for the protocol to none, so the <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> property is used.  <a href="#a02d5080403580f3317fc9eade19882d4">More...</a><br /></td></tr>
<tr class="separator:a02d5080403580f3317fc9eade19882d4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5483f327ca2dcb745fdb14494848fa01 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5483f327ca2dcb745fdb14494848fa01">AddToPasswordList</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;password)</td></tr>
<tr class="memdesc:a5483f327ca2dcb745fdb14494848fa01 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a password to the password list.  <a href="#a5483f327ca2dcb745fdb14494848fa01">More...</a><br /></td></tr>
<tr class="separator:a5483f327ca2dcb745fdb14494848fa01 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b038b23f879820284d27f3ecc3768 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a699b038b23f879820284d27f3ecc3768">GetPasswordListSuccessfulEntry</a> () const </td></tr>
<tr class="memdesc:a699b038b23f879820284d27f3ecc3768 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry, which was successfully tried with the meter.  <a href="#a699b038b23f879820284d27f3ecc3768">More...</a><br /></td></tr>
<tr class="separator:a699b038b23f879820284d27f3ecc3768 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb502e0b67a62153f70d818e0fec138a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> ()</td></tr>
<tr class="memdesc:adb502e0b67a62153f70d818e0fec138a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the statistical data for the channel.  <a href="#adb502e0b67a62153f70d818e0fec138a">More...</a><br /></td></tr>
<tr class="separator:adb502e0b67a62153f70d818e0fec138a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb24a5372b721c343add6ae803287e94 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94">Connect</a> ()</td></tr>
<tr class="memdesc:adb24a5372b721c343add6ae803287e94 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the channel and establishes the connection with the peer.  <a href="#adb24a5372b721c343add6ae803287e94">More...</a><br /></td></tr>
<tr class="separator:adb24a5372b721c343add6ae803287e94 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c328afee944e7e977092b8da2887f8 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8">Disconnect</a> ()</td></tr>
<tr class="memdesc:a72c328afee944e7e977092b8da2887f8 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Severs the connection between the computer and the end device.  <a href="#a72c328afee944e7e977092b8da2887f8">More...</a><br /></td></tr>
<tr class="separator:a72c328afee944e7e977092b8da2887f8 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c53c968bd097ffaddee8fb679a3f9d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a26c53c968bd097ffaddee8fb679a3f9d">IsConnected</a> () const </td></tr>
<tr class="memdesc:a26c53c968bd097ffaddee8fb679a3f9d inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the protocol is currently connected.  <a href="#a26c53c968bd097ffaddee8fb679a3f9d">More...</a><br /></td></tr>
<tr class="separator:a26c53c968bd097ffaddee8fb679a3f9d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290983a74af9495c1a5f66d7e1d4b823 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a> () const </td></tr>
<tr class="memdesc:a290983a74af9495c1a5f66d7e1d4b823 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the protocol is in session.  <a href="#a290983a74af9495c1a5f66d7e1d4b823">More...</a><br /></td></tr>
<tr class="separator:a290983a74af9495c1a5f66d7e1d4b823 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1a1eeb1e19a54b2061e276d7248556 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_action.html">MProgressAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5f1a1eeb1e19a54b2061e276d7248556">CreateRootProgressAction</a> ()</td></tr>
<tr class="memdesc:a5f1a1eeb1e19a54b2061e276d7248556 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create root of the progress actions hierarchy.  <a href="#a5f1a1eeb1e19a54b2061e276d7248556">More...</a><br /></td></tr>
<tr class="separator:a5f1a1eeb1e19a54b2061e276d7248556 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace692f1af6dbb0a33512f5582adec430 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_action.html">MProgressAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ace692f1af6dbb0a33512f5582adec430">GetLocalProgressAction</a> ()</td></tr>
<tr class="memdesc:ace692f1af6dbb0a33512f5582adec430 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the currently preset local action in progress monitor.  <a href="#ace692f1af6dbb0a33512f5582adec430">More...</a><br /></td></tr>
<tr class="separator:ace692f1af6dbb0a33512f5582adec430 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73d91a5b3aeec57221ca2ee0cdbef00 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> () const </td></tr>
<tr class="memdesc:ac73d91a5b3aeec57221ca2ee0cdbef00 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not it is time to call QCommit(true) in order to sync with the background thread.  <a href="#ac73d91a5b3aeec57221ca2ee0cdbef00">More...</a><br /></td></tr>
<tr class="separator:ac73d91a5b3aeec57221ca2ee0cdbef00 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002f961375678606b6e281a624db996 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6002f961375678606b6e281a624db996">QIsBackgroundCommunicationProgressing</a> () const </td></tr>
<tr class="memdesc:a6002f961375678606b6e281a624db996 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the background communication is still progressing.  <a href="#a6002f961375678606b6e281a624db996">More...</a><br /></td></tr>
<tr class="separator:a6002f961375678606b6e281a624db996 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35ae0e64619dfc237c154a44ec578c1 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> ()</td></tr>
<tr class="memdesc:ac35ae0e64619dfc237c154a44ec578c1 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines <a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> with the following <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> in case all commands in the queue have been sent.  <a href="#ac35ae0e64619dfc237c154a44ec578c1">More...</a><br /></td></tr>
<tr class="separator:ac35ae0e64619dfc237c154a44ec578c1 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918229482eba7cf7a7901dae6c3796cb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> ()</td></tr>
<tr class="memdesc:a918229482eba7cf7a7901dae6c3796cb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the commands in the queue, or cancel the ongoing background communication.  <a href="#a918229482eba7cf7a7901dae6c3796cb">More...</a><br /></td></tr>
<tr class="separator:a918229482eba7cf7a7901dae6c3796cb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7480f82e6934a8535760cf325af5bb35 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7480f82e6934a8535760cf325af5bb35">QWriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a7480f82e6934a8535760cf325af5bb35 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the message to write to the Monitor log file to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a7480f82e6934a8535760cf325af5bb35">More...</a><br /></td></tr>
<tr class="separator:a7480f82e6934a8535760cf325af5bb35 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ade785b2e4da0b69c4aadeffc82942 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">QConnect</a> ()</td></tr>
<tr class="memdesc:a68ade785b2e4da0b69c4aadeffc82942 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a Connect command in the queue.  <a href="#a68ade785b2e4da0b69c4aadeffc82942">More...</a><br /></td></tr>
<tr class="separator:a68ade785b2e4da0b69c4aadeffc82942 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474d3857824f0fa028644556d0a09ca0 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a474d3857824f0fa028644556d0a09ca0">QDisconnect</a> ()</td></tr>
<tr class="memdesc:a474d3857824f0fa028644556d0a09ca0 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a Disconnect command in the queue.  <a href="#a474d3857824f0fa028644556d0a09ca0">More...</a><br /></td></tr>
<tr class="separator:a474d3857824f0fa028644556d0a09ca0 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c0c4e13e1a1a616be8ad1e4793290 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ace4c0c4e13e1a1a616be8ad1e4793290">QIdentifyMeter</a> ()</td></tr>
<tr class="memdesc:ace4c0c4e13e1a1a616be8ad1e4793290 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an IdentifyMeter task in the queue.  <a href="#ace4c0c4e13e1a1a616be8ad1e4793290">More...</a><br /></td></tr>
<tr class="separator:ace4c0c4e13e1a1a616be8ad1e4793290 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc217114a8b4928f6d62e13ebf826e7f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afc217114a8b4928f6d62e13ebf826e7f">QStartSession</a> ()</td></tr>
<tr class="memdesc:afc217114a8b4928f6d62e13ebf826e7f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a start session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#afc217114a8b4928f6d62e13ebf826e7f">More...</a><br /></td></tr>
<tr class="separator:afc217114a8b4928f6d62e13ebf826e7f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fc80e08ae3337deac67b5503ae7b77 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a> ()</td></tr>
<tr class="memdesc:aa1fc80e08ae3337deac67b5503ae7b77 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an end session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#aa1fc80e08ae3337deac67b5503ae7b77">More...</a><br /></td></tr>
<tr class="separator:aa1fc80e08ae3337deac67b5503ae7b77 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99c12375946ef53645de3b3807aa24 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9b99c12375946ef53645de3b3807aa24">QEndSessionNoThrow</a> ()</td></tr>
<tr class="memdesc:a9b99c12375946ef53645de3b3807aa24 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">EndSessionNoThrow request is queued.  <a href="#a9b99c12375946ef53645de3b3807aa24">More...</a><br /></td></tr>
<tr class="separator:a9b99c12375946ef53645de3b3807aa24 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08880e3f2b73a5b0a099514b0a71c93f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a08880e3f2b73a5b0a099514b0a71c93f">QTableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, unsigned expectedSize, int id)</td></tr>
<tr class="memdesc:a08880e3f2b73a5b0a099514b0a71c93f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a ReadTable command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a08880e3f2b73a5b0a099514b0a71c93f">More...</a><br /></td></tr>
<tr class="separator:a08880e3f2b73a5b0a099514b0a71c93f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71251f6cbda5a70e1072e4cf78fcea5c inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a71251f6cbda5a70e1072e4cf78fcea5c">QTableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:a71251f6cbda5a70e1072e4cf78fcea5c inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a71251f6cbda5a70e1072e4cf78fcea5c">More...</a><br /></td></tr>
<tr class="separator:a71251f6cbda5a70e1072e4cf78fcea5c inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a88700905af18de1934453c800ae9d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a36a88700905af18de1934453c800ae9d">QTableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, int size, int id)</td></tr>
<tr class="memdesc:a36a88700905af18de1934453c800ae9d inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a partial table read command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a36a88700905af18de1934453c800ae9d">More...</a><br /></td></tr>
<tr class="separator:a36a88700905af18de1934453c800ae9d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1568dcd0e0af9c30043f9179fc527632 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1568dcd0e0af9c30043f9179fc527632">QTableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a1568dcd0e0af9c30043f9179fc527632 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a partial table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a1568dcd0e0af9c30043f9179fc527632">More...</a><br /></td></tr>
<tr class="separator:a1568dcd0e0af9c30043f9179fc527632 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63adc1ca9487420d0f0d4f397892a6c0 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a63adc1ca9487420d0f0d4f397892a6c0">QFunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a63adc1ca9487420d0f0d4f397892a6c0 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function without data request in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a> command queue.  <a href="#a63adc1ca9487420d0f0d4f397892a6c0">More...</a><br /></td></tr>
<tr class="separator:a63adc1ca9487420d0f0d4f397892a6c0 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ccc940c3f27964397d8fb2072a4cf inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a144ccc940c3f27964397d8fb2072a4cf">QFunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:a144ccc940c3f27964397d8fb2072a4cf inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with request data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a144ccc940c3f27964397d8fb2072a4cf">More...</a><br /></td></tr>
<tr class="separator:a144ccc940c3f27964397d8fb2072a4cf inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df65accadd116253feed8a730c8664 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac8df65accadd116253feed8a730c8664">QFunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id, unsigned estimatedResponseSize=<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a>)</td></tr>
<tr class="memdesc:ac8df65accadd116253feed8a730c8664 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#ac8df65accadd116253feed8a730c8664">More...</a><br /></td></tr>
<tr class="separator:ac8df65accadd116253feed8a730c8664 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0c9d99fb75dc21283a5d3fcdabb68 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af4a0c9d99fb75dc21283a5d3fcdabb68">QFunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request, int id, unsigned estimatedResponseSize=<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a>)</td></tr>
<tr class="memdesc:af4a0c9d99fb75dc21283a5d3fcdabb68 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with request and response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#af4a0c9d99fb75dc21283a5d3fcdabb68">More...</a><br /></td></tr>
<tr class="separator:af4a0c9d99fb75dc21283a5d3fcdabb68 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad16d887101c1e2ef14894201aa75a17 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> (bool asynchronously=false)</td></tr>
<tr class="memdesc:aad16d887101c1e2ef14894201aa75a17 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all operations in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#aad16d887101c1e2ef14894201aa75a17">More...</a><br /></td></tr>
<tr class="separator:aad16d887101c1e2ef14894201aa75a17 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4db8b1de02405df260fbeea22f22d9 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aeb4db8b1de02405df260fbeea22f22d9">QGetTableData</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id=-1)</td></tr>
<tr class="memdesc:aeb4db8b1de02405df260fbeea22f22d9 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the table data after the table read has been successfully performed by QCommit.  <a href="#aeb4db8b1de02405df260fbeea22f22d9">More...</a><br /></td></tr>
<tr class="separator:aeb4db8b1de02405df260fbeea22f22d9 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bdb2f1cfd7ec87d68a588dfeaa58a2 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">QGetFunctionData</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id=-1)</td></tr>
<tr class="memdesc:ac5bdb2f1cfd7ec87d68a588dfeaa58a2 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the function response data after the function has been successfully executed in QCommit.  <a href="#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">More...</a><br /></td></tr>
<tr class="separator:ac5bdb2f1cfd7ec87d68a588dfeaa58a2 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cb0e39b25f7450228ce092b358bf55 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a81cb0e39b25f7450228ce092b358bf55">QGetIdentifyMeterData</a> ()</td></tr>
<tr class="memdesc:a81cb0e39b25f7450228ce092b358bf55 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the identify meter string after the QIdentifyMeter has been successfully performed in QCommit.  <a href="#a81cb0e39b25f7450228ce092b358bf55">More...</a><br /></td></tr>
<tr class="separator:a81cb0e39b25f7450228ce092b358bf55 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4ac84c215dbf8aa29be17a897b2e4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9fb4ac84c215dbf8aa29be17a897b2e4">WriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a9fb4ac84c215dbf8aa29be17a897b2e4 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write a message to the monitor, if it is connected.  <a href="#a9fb4ac84c215dbf8aa29be17a897b2e4">More...</a><br /></td></tr>
<tr class="separator:a9fb4ac84c215dbf8aa29be17a897b2e4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1c1a9ec69a7b146af846d0b4555cc3 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aad1c1a9ec69a7b146af846d0b4555cc3">WriteCountsToMonitor</a> ()</td></tr>
<tr class="memdesc:aad1c1a9ec69a7b146af846d0b4555cc3 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write running values of communication quality counters to monitor.  <a href="#aad1c1a9ec69a7b146af846d0b4555cc3">More...</a><br /></td></tr>
<tr class="separator:aad1c1a9ec69a7b146af846d0b4555cc3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c0bf42b3e983e64f0d47856d9e10d8 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">StartSession</a> ()</td></tr>
<tr class="memdesc:ac9c0bf42b3e983e64f0d47856d9e10d8 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously start the session.  <a href="#ac9c0bf42b3e983e64f0d47856d9e10d8">More...</a><br /></td></tr>
<tr class="separator:ac9c0bf42b3e983e64f0d47856d9e10d8 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c406f96f58b3c72411924f085e0f1 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a614c406f96f58b3c72411924f085e0f1">EndSession</a> ()</td></tr>
<tr class="memdesc:a614c406f96f58b3c72411924f085e0f1 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously end the session.  <a href="#a614c406f96f58b3c72411924f085e0f1">More...</a><br /></td></tr>
<tr class="separator:a614c406f96f58b3c72411924f085e0f1 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061f6255815a1b2bc982bbcb28ac4df4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a061f6255815a1b2bc982bbcb28ac4df4">EndSessionNoThrow</a> ()</td></tr>
<tr class="memdesc:a061f6255815a1b2bc982bbcb28ac4df4 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the session, but do not throw errors.  <a href="#a061f6255815a1b2bc982bbcb28ac4df4">More...</a><br /></td></tr>
<tr class="separator:a061f6255815a1b2bc982bbcb28ac4df4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a325cbf5b8a9df536131dc7aeeb2fb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae0a325cbf5b8a9df536131dc7aeeb2fb">ReadStartByte</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;setOfValidStartBytes, unsigned trafficTimeout)</td></tr>
<tr class="memdesc:ae0a325cbf5b8a9df536131dc7aeeb2fb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the start byte of the packet in a proper way, taking into consideration timeouts and ignoring garbage.  <a href="#ae0a325cbf5b8a9df536131dc7aeeb2fb">More...</a><br /></td></tr>
<tr class="separator:ae0a325cbf5b8a9df536131dc7aeeb2fb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9f1af7c99107d64f498f4b2b3a04cb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0b9f1af7c99107d64f498f4b2b3a04cb">TableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:a0b9f1af7c99107d64f498f4b2b3a04cb inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter.  <a href="#a0b9f1af7c99107d64f498f4b2b3a04cb">More...</a><br /></td></tr>
<tr class="separator:a0b9f1af7c99107d64f498f4b2b3a04cb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ceef5e13fc8328e914f3a85fa3a4b6 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a97ceef5e13fc8328e914f3a85fa3a4b6">TableReadBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, void *buff, unsigned size)</td></tr>
<tr class="memdesc:a97ceef5e13fc8328e914f3a85fa3a4b6 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadTable, but instead of returning a byte string, read table into a given buffer.  <a href="#a97ceef5e13fc8328e914f3a85fa3a4b6">More...</a><br /></td></tr>
<tr class="separator:a97ceef5e13fc8328e914f3a85fa3a4b6 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac626edc816da38de4579137d15088420">TableReadBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, T &amp;table)</td></tr>
<tr class="memdesc:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadTable, but instead of returning a byte string, read table into a given template variable.  <a href="#ac626edc816da38de4579137d15088420">More...</a><br /></td></tr>
<tr class="separator:ac626edc816da38de4579137d15088420 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6e3cb40e08cc7a1928f424235e12a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad5b6e3cb40e08cc7a1928f424235e12a">TableReadNoThrow</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="class_m_exception.html">MException</a> **exception, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:ad5b6e3cb40e08cc7a1928f424235e12a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter, do not throw an exception, but rather return it.  <a href="#ad5b6e3cb40e08cc7a1928f424235e12a">More...</a><br /></td></tr>
<tr class="separator:ad5b6e3cb40e08cc7a1928f424235e12a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40474bd501a7a79eaa8a858db378818 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae40474bd501a7a79eaa8a858db378818">TableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:ae40474bd501a7a79eaa8a858db378818 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write the whole table with number given as parameter.  <a href="#ae40474bd501a7a79eaa8a858db378818">More...</a><br /></td></tr>
<tr class="separator:ae40474bd501a7a79eaa8a858db378818 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25225dab2e96159a2e87ccf4a3f98ff5 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a25225dab2e96159a2e87ccf4a3f98ff5">TableWriteBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const void *data, unsigned size)</td></tr>
<tr class="memdesc:a25225dab2e96159a2e87ccf4a3f98ff5 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWrite, but uses buffer, given as data and size parameters.  <a href="#a25225dab2e96159a2e87ccf4a3f98ff5">More...</a><br /></td></tr>
<tr class="separator:a25225dab2e96159a2e87ccf4a3f98ff5 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a70c91ea9cb634f292ba182dfad1eb67c">TableWriteBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const T &amp;table)</td></tr>
<tr class="memdesc:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as WriteTable, but uses variable of some specific template class or structure.  <a href="#a70c91ea9cb634f292ba182dfad1eb67c">More...</a><br /></td></tr>
<tr class="separator:a70c91ea9cb634f292ba182dfad1eb67c inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07064801f4387790bc0aa0ec8a4fbb21 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a07064801f4387790bc0aa0ec8a4fbb21">TableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, int size)</td></tr>
<tr class="memdesc:a07064801f4387790bc0aa0ec8a4fbb21 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read part of the table with number given as parameter.  <a href="#a07064801f4387790bc0aa0ec8a4fbb21">More...</a><br /></td></tr>
<tr class="separator:a07064801f4387790bc0aa0ec8a4fbb21 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7d366d9d1f297b52e7baf2bc7ac24b inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#acf7d366d9d1f297b52e7baf2bc7ac24b">TableReadPartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, void *buff, unsigned size)</td></tr>
<tr class="memdesc:acf7d366d9d1f297b52e7baf2bc7ac24b inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableReadPartial, but instead of returning a byte string, read table into a given buffer.  <a href="#acf7d366d9d1f297b52e7baf2bc7ac24b">More...</a><br /></td></tr>
<tr class="separator:acf7d366d9d1f297b52e7baf2bc7ac24b inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2f275facac5ad95bb8ce4e6df7044008">TableReadPartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, T &amp;table, int offset)</td></tr>
<tr class="memdesc:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableReadPartial, but instead of returning a byte string, partially read table into a given template variable.  <a href="#a2f275facac5ad95bb8ce4e6df7044008">More...</a><br /></td></tr>
<tr class="separator:a2f275facac5ad95bb8ce4e6df7044008 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d15c7e39f18cc7d77067ecb5aa0d020 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7d15c7e39f18cc7d77067ecb5aa0d020">TableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a7d15c7e39f18cc7d77067ecb5aa0d020 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write part of the table with number given as parameter.  <a href="#a7d15c7e39f18cc7d77067ecb5aa0d020">More...</a><br /></td></tr>
<tr class="separator:a7d15c7e39f18cc7d77067ecb5aa0d020 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582cc6901f859085d97ae69aca60ac7 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1582cc6901f859085d97ae69aca60ac7">TableWritePartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, const void *buff, unsigned size)</td></tr>
<tr class="memdesc:a1582cc6901f859085d97ae69aca60ac7 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWritePartial, but instead of using a byte string, write table using a given buffer.  <a href="#a1582cc6901f859085d97ae69aca60ac7">More...</a><br /></td></tr>
<tr class="separator:a1582cc6901f859085d97ae69aca60ac7 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af8010cabbebd86ff8775a5f7d82711d3">TableWritePartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const T &amp;table, int offset)</td></tr>
<tr class="memdesc:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWritePartial, but instead of using a byte string, write table using a given template class contents.  <a href="#af8010cabbebd86ff8775a5f7d82711d3">More...</a><br /></td></tr>
<tr class="separator:af8010cabbebd86ff8775a5f7d82711d3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a528fb6f70b4baba1485062c74f3523 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7a528fb6f70b4baba1485062c74f3523">FunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a7a528fb6f70b4baba1485062c74f3523 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with no parameters, the number of the function is given as parameter.  <a href="#a7a528fb6f70b4baba1485062c74f3523">More...</a><br /></td></tr>
<tr class="separator:a7a528fb6f70b4baba1485062c74f3523 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12a2ba50f66f04f0d509b95be684e14 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad12a2ba50f66f04f0d509b95be684e14">FunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:ad12a2ba50f66f04f0d509b95be684e14 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request data, the number of the function is given as parameter.  <a href="#ad12a2ba50f66f04f0d509b95be684e14">More...</a><br /></td></tr>
<tr class="separator:ad12a2ba50f66f04f0d509b95be684e14 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b90e2cd8076ffa77c7c3684fb3b580 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a24b90e2cd8076ffa77c7c3684fb3b580">FunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a24b90e2cd8076ffa77c7c3684fb3b580 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with response data, the number of the function is given as parameter.  <a href="#a24b90e2cd8076ffa77c7c3684fb3b580">More...</a><br /></td></tr>
<tr class="separator:a24b90e2cd8076ffa77c7c3684fb3b580 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda3777c6b76d297bcde7e97ea960623 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afda3777c6b76d297bcde7e97ea960623">FunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:afda3777c6b76d297bcde7e97ea960623 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request and response data, the number of the function is given as parameter.  <a href="#afda3777c6b76d297bcde7e97ea960623">More...</a><br /></td></tr>
<tr class="separator:afda3777c6b76d297bcde7e97ea960623 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1fa960c9550b02aa815a4cc2ec1f5a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6a1fa960c9550b02aa815a4cc2ec1f5a">GetNumberOfDataLinkPackets</a> (MCommunicationCommand::CommandType typeOfRequest, unsigned applicationLayerDataSize=0)</td></tr>
<tr class="memdesc:a6a1fa960c9550b02aa815a4cc2ec1f5a inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of data link packets that are required for a given request, provided an optional size of the application data.  <a href="#a6a1fa960c9550b02aa815a4cc2ec1f5a">More...</a><br /></td></tr>
<tr class="separator:a6a1fa960c9550b02aa815a4cc2ec1f5a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153d408f472c69796e0653a3d6aa8a88 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a153d408f472c69796e0653a3d6aa8a88">IdentifyMeterWithContext</a> (bool sessionIsStarted=false, <a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *tablesRead=NULL)</td></tr>
<tr class="memdesc:a153d408f472c69796e0653a3d6aa8a88 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command).  <a href="#a153d408f472c69796e0653a3d6aa8a88">More...</a><br /></td></tr>
<tr class="separator:a153d408f472c69796e0653a3d6aa8a88 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133e349c1e8797a95c6adacfe1aa763 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa133e349c1e8797a95c6adacfe1aa763">CalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer) const </td></tr>
<tr class="memdesc:aa133e349c1e8797a95c6adacfe1aa763 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent one-byte checksum calculation procedure that uses byte string.  <a href="#aa133e349c1e8797a95c6adacfe1aa763">More...</a><br /></td></tr>
<tr class="separator:aa133e349c1e8797a95c6adacfe1aa763 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb755fa8d912240ffd69553930ea114 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6bb755fa8d912240ffd69553930ea114">CalculateCRC16</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer) const </td></tr>
<tr class="memdesc:a6bb755fa8d912240ffd69553930ea114 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent two-byte CRC calculation procedure that accepts the byte string.  <a href="#a6bb755fa8d912240ffd69553930ea114">More...</a><br /></td></tr>
<tr class="separator:a6bb755fa8d912240ffd69553930ea114 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f966b2e9889aa5111130cc2a96ce27f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a3f966b2e9889aa5111130cc2a96ce27f">Sleep</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:a3f966b2e9889aa5111130cc2a96ce27f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls channel's Sleep method if the channel is present.  <a href="#a3f966b2e9889aa5111130cc2a96ce27f">More...</a><br /></td></tr>
<tr class="separator:a3f966b2e9889aa5111130cc2a96ce27f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85938b8449e0ec4f2d8ccbe0b07e6d07 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a85938b8449e0ec4f2d8ccbe0b07e6d07">GetMeterIsLittleEndian</a> () const </td></tr>
<tr class="separator:a85938b8449e0ec4f2d8ccbe0b07e6d07 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a903d399462a1c758ee69a409ca0a inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#acf7a903d399462a1c758ee69a409ca0a">SetMeterIsLittleEndian</a> (bool isLittleEndian)</td></tr>
<tr class="separator:acf7a903d399462a1c758ee69a409ca0a inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1f3716f3a56c3d652dcd856d4b2afb inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7c1f3716f3a56c3d652dcd856d4b2afb">GetChannel</a> () const </td></tr>
<tr class="separator:a7c1f3716f3a56c3d652dcd856d4b2afb inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742a84d23ad0eb514b1438877caaf546 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a742a84d23ad0eb514b1438877caaf546">SetChannel</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel)</td></tr>
<tr class="separator:a742a84d23ad0eb514b1438877caaf546 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159f02566ad282534dca1cc48ca6a9be inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a159f02566ad282534dca1cc48ca6a9be">IsChannelOwned</a> () const </td></tr>
<tr class="separator:a159f02566ad282534dca1cc48ca6a9be inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4244ee4024965a0ccdc5e374a4f4ce4b inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a4244ee4024965a0ccdc5e374a4f4ce4b">SetIsChannelOwned</a> (bool yes)</td></tr>
<tr class="separator:a4244ee4024965a0ccdc5e374a4f4ce4b inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada79d1deee2f2b2c57f4c0733f9c5670 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ada79d1deee2f2b2c57f4c0733f9c5670">GetKeepSessionAlive</a> () const </td></tr>
<tr class="separator:ada79d1deee2f2b2c57f4c0733f9c5670 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17855be033587c380defb411ca4a169 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab17855be033587c380defb411ca4a169">SetKeepSessionAlive</a> (bool alive)</td></tr>
<tr class="separator:ab17855be033587c380defb411ca4a169 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eb073d8a88ba1a5f741e5ba5ef35e3 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab7eb073d8a88ba1a5f741e5ba5ef35e3">GetPassword</a> () const </td></tr>
<tr class="separator:ab7eb073d8a88ba1a5f741e5ba5ef35e3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad711cb25a0c60e1789391e8398d670 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;password)</td></tr>
<tr class="separator:abad711cb25a0c60e1789391e8398d670 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5d6a64af11464ea5e932188affd950 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aff5d6a64af11464ea5e932188affd950">GetPasswordList</a> () const </td></tr>
<tr class="separator:aff5d6a64af11464ea5e932188affd950 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbfdbdb3cbeb2809e0aa18de682decd inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5fbfdbdb3cbeb2809e0aa18de682decd">SetPasswordList</a> (const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;passwordList)</td></tr>
<tr class="separator:a5fbfdbdb3cbeb2809e0aa18de682decd inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04125b705921153a4bde750649a9ecc3 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a04125b705921153a4bde750649a9ecc3">GetProgressMonitor</a> () const </td></tr>
<tr class="separator:a04125b705921153a4bde750649a9ecc3 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc702f61befdd1b58b7186d457e3789 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2cc702f61befdd1b58b7186d457e3789">SetProgressMonitor</a> (<a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *p)</td></tr>
<tr class="separator:a2cc702f61befdd1b58b7186d457e3789 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c81486925491e60e7c6beb86e603b7 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">MCommunicationQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80c81486925491e60e7c6beb86e603b7">GetCommandQueue</a> ()</td></tr>
<tr class="memdesc:a80c81486925491e60e7c6beb86e603b7 inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">M_NO_PROGRESS_MONITOR.  <a href="#a80c81486925491e60e7c6beb86e603b7">More...</a><br /></td></tr>
<tr class="separator:a80c81486925491e60e7c6beb86e603b7 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850a893c89d0336264c7a67c0a6cdf2f inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">const MCommunicationQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a850a893c89d0336264c7a67c0a6cdf2f">GetCommandQueue</a> () const </td></tr>
<tr class="memdesc:a850a893c89d0336264c7a67c0a6cdf2f inherit pub_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">M_NO_PROGRESS_MONITOR.  <a href="#a850a893c89d0336264c7a67c0a6cdf2f">More...</a><br /></td></tr>
<tr class="separator:a850a893c89d0336264c7a67c0a6cdf2f inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb127ad977cc65921c71f65c56bc427d inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abb127ad977cc65921c71f65c56bc427d">IdentifyMeter</a> (bool sessionIsStarted=false)</td></tr>
<tr class="separator:abb127ad977cc65921c71f65c56bc427d inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78587773f355c611188b78b6fd1be3e4 inherit pub_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a78587773f355c611188b78b6fd1be3e4">DoIdentifyMeter0</a> ()</td></tr>
<tr class="separator:a78587773f355c611188b78b6fd1be3e4 inherit pub_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d9454ddf99ec17a57e738b7a4c9924"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a21d9454ddf99ec17a57e738b7a4c9924">~MCOMObject</a> ()</td></tr>
<tr class="memdesc:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a035721a745792a3acf0d4b274f1357f7">GetAllPropertyNames</a> () const </td></tr>
<tr class="memdesc:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available properties in MCOM syntax.  <a href="#a035721a745792a3acf0d4b274f1357f7">More...</a><br /></td></tr>
<tr class="separator:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a49655583da819ff86d7798a28537c6a8">GetAllPersistentPropertyNames</a> () const </td></tr>
<tr class="memdesc:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available persistent properties in MCOM syntax.  <a href="#a49655583da819ff86d7798a28537c6a8">More...</a><br /></td></tr>
<tr class="separator:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ae29a16d367eb0adb13332f8ac5fb888c">GetPersistentPropertyValues</a> (bool onlyNondefaults=false, bool excludeSecurityRelated=false) const </td></tr>
<tr class="memdesc:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#ae29a16d367eb0adb13332f8ac5fb888c">More...</a><br /></td></tr>
<tr class="separator:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#acc4469513dd44b58e00cec24dbb6d8a3">SetPersistentPropertyValues</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;values)</td></tr>
<tr class="memdesc:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties for the object using the string with the following format:  <a href="#acc4469513dd44b58e00cec24dbb6d8a3">More...</a><br /></td></tr>
<tr class="separator:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ac1d0975664316b3009c6f4f1822cfa75">SetPropertyValues</a> (const <a class="el" href="class_m_dictionary.html">MDictionary</a> &amp;values)</td></tr>
<tr class="memdesc:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the properties for the object using the property list object.  <a href="#ac1d0975664316b3009c6f4f1822cfa75">More...</a><br /></td></tr>
<tr class="separator:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a7f7d1bbe083159dca4bd92e5d8268ad2">WritePropertiesToMonitor</a> ()</td></tr>
<tr class="memdesc:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all non-default values of protocol properties into monitor.  <a href="#a7f7d1bbe083159dca4bd92e5d8268ad2">More...</a><br /></td></tr>
<tr class="separator:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a74dc8ffe0afce73e590f2206c890a0f2">DoGetPersistentPropertyValues0</a> () const </td></tr>
<tr class="memdesc:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the whole list of persistent property names and their values.  <a href="#a74dc8ffe0afce73e590f2206c890a0f2">More...</a><br /></td></tr>
<tr class="separator:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a68f6f34b5bf5ad5b6cba05aae222bf58">DoGetPersistentPropertyValues1</a> (bool onlyNondefaults) const </td></tr>
<tr class="memdesc:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#a68f6f34b5bf5ad5b6cba05aae222bf58">More...</a><br /></td></tr>
<tr class="separator:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44959297f429d05d4408c88d7596afc4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a44959297f429d05d4408c88d7596afc4">~MObject</a> ()</td></tr>
<tr class="memdesc:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a297127a242f90a602d4ba24243591b52">GetClass</a> () const  =0</td></tr>
<tr class="memdesc:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final class of the object.  <a href="#a297127a242f90a602d4ba24243591b52">More...</a><br /></td></tr>
<tr class="separator:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a87705dec46a625badd4ceda29547b338">GetEmbeddedSizeof</a> () const </td></tr>
<tr class="memdesc:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">For embedded object types, return the size of the class.  <a href="#a87705dec46a625badd4ceda29547b338">More...</a><br /></td></tr>
<tr class="separator:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a203c3127403741b20df02335c1015532">IsEmbeddedObject</a> () const </td></tr>
<tr class="memdesc:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the object is of embedded kind.  <a href="#a203c3127403741b20df02335c1015532">More...</a><br /></td></tr>
<tr class="separator:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">SHOW_INTERNAL <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad752a5e3b6800212e453481287e28067">Call</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;params)</td></tr>
<tr class="memdesc:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant.  <a href="#ad752a5e3b6800212e453481287e28067">More...</a><br /></td></tr>
<tr class="separator:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a62a3a6bb2e0e64a644b0be916a502492">Call0</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with no parameters.  <a href="#a62a3a6bb2e0e64a644b0be916a502492">More...</a><br /></td></tr>
<tr class="separator:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3dafe0a11416dd435a4384678f9fe010">Call1</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1)</td></tr>
<tr class="memdesc:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with one parameter.  <a href="#a3dafe0a11416dd435a4384678f9fe010">More...</a><br /></td></tr>
<tr class="separator:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a47cced5e73d0558ac761367380efde52">Call2</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2)</td></tr>
<tr class="memdesc:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with two parameter.  <a href="#a47cced5e73d0558ac761367380efde52">More...</a><br /></td></tr>
<tr class="separator:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad5b38fa7d1eedf7640183ce1bf750479">Call3</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3)</td></tr>
<tr class="memdesc:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with three parameter.  <a href="#ad5b38fa7d1eedf7640183ce1bf750479">More...</a><br /></td></tr>
<tr class="separator:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#abac65416662f68d208674270c4fc2a95">Call4</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4)</td></tr>
<tr class="memdesc:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with four parameter.  <a href="#abac65416662f68d208674270c4fc2a95">More...</a><br /></td></tr>
<tr class="separator:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a72636f3f379105f9b98eb4644464c96c">Call5</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5)</td></tr>
<tr class="memdesc:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with five parameter.  <a href="#a72636f3f379105f9b98eb4644464c96c">More...</a><br /></td></tr>
<tr class="separator:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3634a9b8b7927122ec3b7e9f08f15be9">Call6</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p6)</td></tr>
<tr class="memdesc:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with six parameter.  <a href="#a3634a9b8b7927122ec3b7e9f08f15be9">More...</a><br /></td></tr>
<tr class="separator:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae7a3f18267d3af7513242e7247c8c40e">CallV</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">MVariant::VariantVector</a> &amp;params)</td></tr>
<tr class="memdesc:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant vector.  <a href="#ae7a3f18267d3af7513242e7247c8c40e">More...</a><br /></td></tr>
<tr class="separator:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99063368f3e5fb4189bcbd13339e47c0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a99063368f3e5fb4189bcbd13339e47c0">IsPropertyPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the property with the given name exists. <br /></td></tr>
<tr class="separator:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d10a068500c82809fcb6d97ea9611da"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a6d10a068500c82809fcb6d97ea9611da">IsServicePresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the service with the given name exists. <br /></td></tr>
<tr class="separator:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a0e84b79fc7c435e2b338f0f9a6239b45">GetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property value using name of the property.  <a href="#a0e84b79fc7c435e2b338f0f9a6239b45">More...</a><br /></td></tr>
<tr class="separator:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a4c04b41d6114e57b12447bd0e07e6af5">SetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="memdesc:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property using name of the property, and value.  <a href="#a4c04b41d6114e57b12447bd0e07e6af5">More...</a><br /></td></tr>
<tr class="separator:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a65eb2f14c14157a7aeead3d68550092f">SetPersistentPropertiesToDefault</a> ()</td></tr>
<tr class="memdesc:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties of the object to their default values.  <a href="#a65eb2f14c14157a7aeead3d68550092f">More...</a><br /></td></tr>
<tr class="separator:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a14384d8101f49cb7616bddd06fe6ecbd">GetPersistentPropertyDefaultValue</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default value of persistent property with the name given.  <a href="#a14384d8101f49cb7616bddd06fe6ecbd">More...</a><br /></td></tr>
<tr class="separator:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a76f62e685cf1f638da5aef8c41ca8586">SetPersistentPropertyToDefault</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent property with the name given to default value.  <a href="#a76f62e685cf1f638da5aef8c41ca8586">More...</a><br /></td></tr>
<tr class="separator:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03324a7bc9b626fe2860beb4b84b6bcc"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a03324a7bc9b626fe2860beb4b84b6bcc">GetType</a> () const </td></tr>
<tr class="memdesc:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the type for the object (could be the same as class name). <br /></td></tr>
<tr class="separator:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a164dbf0ffa4e8c65b9ceffbf1d6fb391">SetType</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;)</td></tr>
<tr class="memdesc:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally, it will set the name of the type for the object, but the service will not allow setting the name to anything other than the current name.  <a href="#a164dbf0ffa4e8c65b9ceffbf1d6fb391">More...</a><br /></td></tr>
<tr class="separator:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#af929f6afc9295557a8c5ead74c6c0b6a">Validate</a> ()</td></tr>
<tr class="memdesc:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate internal structures of the object.  <a href="#af929f6afc9295557a8c5ead74c6c0b6a">More...</a><br /></td></tr>
<tr class="separator:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1b249ae1c535217e1bcaa523ef01ac36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#a1b249ae1c535217e1bcaa523ef01ac36">DoStartSession</a> ()</td></tr>
<tr class="memdesc:a1b249ae1c535217e1bcaa523ef01ac36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously start the session, don't do service count.  <a href="#a1b249ae1c535217e1bcaa523ef01ac36">More...</a><br /></td></tr>
<tr class="separator:a1b249ae1c535217e1bcaa523ef01ac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f12222a06488962da5768fc970a83d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c1218.html#aa9f12222a06488962da5768fc970a83d">DoEndSession</a> ()</td></tr>
<tr class="memdesc:aa9f12222a06488962da5768fc970a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously end the session, don't do service count.  <a href="#aa9f12222a06488962da5768fc970a83d">More...</a><br /></td></tr>
<tr class="separator:aa9f12222a06488962da5768fc970a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_protocol_c12"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_protocol_c12')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_protocol_c12.html">MProtocolC12</a></td></tr>
<tr class="memitem:a8621b61dcdce80c57165aa941840a747 inherit pro_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a8621b61dcdce80c57165aa941840a747">MProtocolC12</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel, bool channelIsOwned=true)</td></tr>
<tr class="memdesc:a8621b61dcdce80c57165aa941840a747 inherit pro_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new abstract ANSI C12 protocol with the channel given.  <a href="#a8621b61dcdce80c57165aa941840a747">More...</a><br /></td></tr>
<tr class="separator:a8621b61dcdce80c57165aa941840a747 inherit pro_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:a84c83febc048cf02cb62cd89c30d933f inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a84c83febc048cf02cb62cd89c30d933f">MProtocol</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel, bool channelIsOwned=true)</td></tr>
<tr class="memdesc:a84c83febc048cf02cb62cd89c30d933f inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new abstract protocol with the channel given.  <a href="#a84c83febc048cf02cb62cd89c30d933f">More...</a><br /></td></tr>
<tr class="separator:a84c83febc048cf02cb62cd89c30d933f inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5713023f78fa29cef7dd4d447c46c13c inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5713023f78fa29cef7dd4d447c46c13c">DoTableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:a5713023f78fa29cef7dd4d447c46c13c inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter, don't do service count.  <a href="#a5713023f78fa29cef7dd4d447c46c13c">More...</a><br /></td></tr>
<tr class="separator:a5713023f78fa29cef7dd4d447c46c13c inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed51debc39d8bbf7f2ca1b5327f7bfc inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abed51debc39d8bbf7f2ca1b5327f7bfc">DoTableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:abed51debc39d8bbf7f2ca1b5327f7bfc inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write the whole table with number given as parameter, don't do service count.  <a href="#abed51debc39d8bbf7f2ca1b5327f7bfc">More...</a><br /></td></tr>
<tr class="separator:abed51debc39d8bbf7f2ca1b5327f7bfc inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df82b4dfb44ebf518616fa27d4feef7 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0df82b4dfb44ebf518616fa27d4feef7">DoTableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset, int size)</td></tr>
<tr class="memdesc:a0df82b4dfb44ebf518616fa27d4feef7 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read part of the table with number given as parameter, don't do service count.  <a href="#a0df82b4dfb44ebf518616fa27d4feef7">More...</a><br /></td></tr>
<tr class="separator:a0df82b4dfb44ebf518616fa27d4feef7 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1679a8d7a6ffc68b79aceddb89165d inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6f1679a8d7a6ffc68b79aceddb89165d">DoTableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a6f1679a8d7a6ffc68b79aceddb89165d inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write part of the table with number given as parameter, don't do service count.  <a href="#a6f1679a8d7a6ffc68b79aceddb89165d">More...</a><br /></td></tr>
<tr class="separator:a6f1679a8d7a6ffc68b79aceddb89165d inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac4a0d11d9d0a767103abf7da4db49a inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0ac4a0d11d9d0a767103abf7da4db49a">DoFunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a0ac4a0d11d9d0a767103abf7da4db49a inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with no parameters, the number of the function is given as parameter, don't do service count.  <a href="#a0ac4a0d11d9d0a767103abf7da4db49a">More...</a><br /></td></tr>
<tr class="separator:a0ac4a0d11d9d0a767103abf7da4db49a inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498d5dc0aecad07ce33fad05a051dffc inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a498d5dc0aecad07ce33fad05a051dffc">DoFunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:a498d5dc0aecad07ce33fad05a051dffc inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request data, the number of the function is given as parameter, don't do service count.  <a href="#a498d5dc0aecad07ce33fad05a051dffc">More...</a><br /></td></tr>
<tr class="separator:a498d5dc0aecad07ce33fad05a051dffc inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2765259b51fb263615753e0354284c4d inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2765259b51fb263615753e0354284c4d">DoFunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;response)</td></tr>
<tr class="memdesc:a2765259b51fb263615753e0354284c4d inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with response data, the number of the function is given as parameter, don't do service count.  <a href="#a2765259b51fb263615753e0354284c4d">More...</a><br /></td></tr>
<tr class="separator:a2765259b51fb263615753e0354284c4d inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638ffb840d26add215f782dedf9253a0 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a638ffb840d26add215f782dedf9253a0">DoFunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;response)</td></tr>
<tr class="memdesc:a638ffb840d26add215f782dedf9253a0 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request and response data, the number of the function is given as parameter, don't do service count.  <a href="#a638ffb840d26add215f782dedf9253a0">More...</a><br /></td></tr>
<tr class="separator:a638ffb840d26add215f782dedf9253a0 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99437b4f61294658ca525ebaf46b6c3b inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a99437b4f61294658ca525ebaf46b6c3b">DoIdentifyMeter</a> (bool sessionIsStarted, <a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *tablesRead)</td></tr>
<tr class="memdesc:a99437b4f61294658ca525ebaf46b6c3b inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command).  <a href="#a99437b4f61294658ca525ebaf46b6c3b">More...</a><br /></td></tr>
<tr class="separator:a99437b4f61294658ca525ebaf46b6c3b inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0daefaa99d91762fbf5da71033d87 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80a0daefaa99d91762fbf5da71033d87">DoTryPasswordOrPasswordList</a> ()</td></tr>
<tr class="memdesc:a80a0daefaa99d91762fbf5da71033d87 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try password or passwords for the protocol according to the PASSWORD and PasswordList settings.  <a href="#a80a0daefaa99d91762fbf5da71033d87">More...</a><br /></td></tr>
<tr class="separator:a80a0daefaa99d91762fbf5da71033d87 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab55c37d116010b499c3cb153c64781 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a8ab55c37d116010b499c3cb153c64781">DoTryPasswordEntry</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;entry)</td></tr>
<tr class="memdesc:a8ab55c37d116010b499c3cb153c64781 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try one password, throw if error.  <a href="#a8ab55c37d116010b499c3cb153c64781">More...</a><br /></td></tr>
<tr class="separator:a8ab55c37d116010b499c3cb153c64781 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e1791d3e8f1439f0e4ba228cb50a24 inherit pro_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad5e1791d3e8f1439f0e4ba228cb50a24">DoBuildComplexServiceName</a> (<a class="el" href="group___m_c_o_r_e.html#ga0cb232e7db5da70b9864e90ccdf41a1a">MChars</a> fullServiceName, <a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> serviceName, <a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int par1=-1, int par2=-1)</td></tr>
<tr class="memdesc:ad5e1791d3e8f1439f0e4ba228cb50a24 inherit pro_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build service name with a number and given parameters.  <a href="#ad5e1791d3e8f1439f0e4ba228cb50a24">More...</a><br /></td></tr>
<tr class="separator:ad5e1791d3e8f1439f0e4ba228cb50a24 inherit pro_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1387ff56bed4d3ce4ed3d7526ffb0eb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a1387ff56bed4d3ce4ed3d7526ffb0eb5">MCOMObject</a> ()</td></tr>
<tr class="memdesc:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fd4059be176487607315d88d715a97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a48fd4059be176487607315d88d715a97">MObject</a> ()</td></tr>
<tr class="memdesc:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a9160d5a51f8d3b85ace23e83f967f269">DoSetPersistentPropertiesToDefault</a> (const <a class="el" href="class_m_class.html">MClass</a> *staticClass)</td></tr>
<tr class="memdesc:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties to their default values for one object provided the class for that object.  <a href="#a9160d5a51f8d3b85ace23e83f967f269">More...</a><br /></td></tr>
<tr class="separator:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_m_protocol_c12"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_protocol_c12')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_protocol_c12.html">MProtocolC12</a></td></tr>
<tr class="memitem:ad085c2bdd954e2075edfa6bdb214c06f inherit pub_static_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ad085c2bdd954e2075edfa6bdb214c06f">StaticCalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buff)</td></tr>
<tr class="memdesc:ad085c2bdd954e2075edfa6bdb214c06f inherit pub_static_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the byte string given as parameters.  <a href="#ad085c2bdd954e2075edfa6bdb214c06f">More...</a><br /></td></tr>
<tr class="separator:ad085c2bdd954e2075edfa6bdb214c06f inherit pub_static_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6d64fb1f68e579d2d91556be61b81a inherit pub_static_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#aff6d64fb1f68e579d2d91556be61b81a">StaticCalculateChecksumFromBuffer</a> (const char *data, unsigned size)</td></tr>
<tr class="memdesc:aff6d64fb1f68e579d2d91556be61b81a inherit pub_static_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the buffer and length given as parameters.  <a href="#aff6d64fb1f68e579d2d91556be61b81a">More...</a><br /></td></tr>
<tr class="separator:aff6d64fb1f68e579d2d91556be61b81a inherit pub_static_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b5cbe42994ff3f5983f2f0eebfe561 inherit pub_static_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">static Muint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#a76b5cbe42994ff3f5983f2f0eebfe561">StaticCalculateCRC16FromBuffer</a> (const char *buffer, unsigned length)</td></tr>
<tr class="memdesc:a76b5cbe42994ff3f5983f2f0eebfe561 inherit pub_static_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-byte CRC calculation static procedure specific to C12 protocol.  <a href="#a76b5cbe42994ff3f5983f2f0eebfe561">More...</a><br /></td></tr>
<tr class="separator:a76b5cbe42994ff3f5983f2f0eebfe561 inherit pub_static_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac651a5b76f9a8cef7198219810db5843 inherit pub_static_methods_class_m_protocol_c12"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol_c12.html#ac651a5b76f9a8cef7198219810db5843">CRC16</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer)</td></tr>
<tr class="memdesc:ac651a5b76f9a8cef7198219810db5843 inherit pub_static_methods_class_m_protocol_c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but taking byte string, reflected.  <a href="#ac651a5b76f9a8cef7198219810db5843">More...</a><br /></td></tr>
<tr class="separator:ac651a5b76f9a8cef7198219810db5843 inherit pub_static_methods_class_m_protocol_c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_protocol"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_protocol')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_protocol.html">MProtocol</a></td></tr>
<tr class="memitem:aa87779c70f4bc9e1208066509d618203 inherit pub_static_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa87779c70f4bc9e1208066509d618203">StaticCalculateChecksumFromBuffer</a> (const char *buff, unsigned size)</td></tr>
<tr class="memdesc:aa87779c70f4bc9e1208066509d618203 inherit pub_static_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most popular one-byte checksum calculation procedure, a sum of all bytes.  <a href="#aa87779c70f4bc9e1208066509d618203">More...</a><br /></td></tr>
<tr class="separator:aa87779c70f4bc9e1208066509d618203 inherit pub_static_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a677751b4d8150a1b6236d3f699adf2 inherit pub_static_methods_class_m_protocol"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6a677751b4d8150a1b6236d3f699adf2">StaticCalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer)</td></tr>
<tr class="memdesc:a6a677751b4d8150a1b6236d3f699adf2 inherit pub_static_methods_class_m_protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the byte string given as parameters.  <a href="#a6a677751b4d8150a1b6236d3f699adf2">More...</a><br /></td></tr>
<tr class="separator:a6a677751b4d8150a1b6236d3f699adf2 inherit pub_static_methods_class_m_protocol"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#aeba892081e500e981d22a2c54b6a0100">GetStaticClass</a> ()</td></tr>
<tr class="memdesc:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the declared class of this particular object.  <a href="#aeba892081e500e981d22a2c54b6a0100">More...</a><br /></td></tr>
<tr class="separator:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a89f92d51d036637db84d57290616e98b">IsClassPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given class name is available.  <a href="#a89f92d51d036637db84d57290616e98b">More...</a><br /></td></tr>
<tr class="separator:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae930847fb891a40c903b0e5c0ac5bcf0"></a>
static const <a class="el" href="class_m_class.html">MClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae930847fb891a40c903b0e5c0ac5bcf0">s_class</a></td></tr>
<tr class="memdesc:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>. <br /></td></tr>
<tr class="separator:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. </p>
<p>ANSI Std C12.18-1996 "PROTOCOL SPECIFICATION FOR ANSI Type 2 OPTICAL Port", is intended as a single communications standard for Water, Gas, and Electricity meters that will work on any manufacturer's conforming product. The ANSI C12.18 is a point to point protocol developed to transport table data over an optical connection. A copy of the document can be obtained through NEMA or ANSI. <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a> is the protocol implementation of the ANSI C12.18 standard. It inherits properties from the abstract class <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>, which is common to all protocols. <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a> is intended for communications through the optical probe channel, <a class="el" href="class_m_channel_optical_probe.html" title="Optical probe is a channel based on serial port that is able to control the batteries of the probe (i...">MChannelOpticalProbe</a>. <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a> has extensions for working through modems and multi-drop networks. The Password is 20 characters long, refer to the Password help topic for padding rules. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a4173550ff10e858368ec6257c122fb3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4173550ff10e858368ec6257c122fb3bab9d961f95a7d7a796ea737245ddfd0b9"></a>SMALLEST_PACKET_SIZE&#160;</td><td class="fielddoc">
<p>Smallest packet size supported by the data link layer It shall be bigger than (BIGGEST_I2C_OPTION_BOARD_COMMAND + BIGGEST_I2C_PACKET_HEADER_OVERHEAD + 1) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4173550ff10e858368ec6257c122fb3ba857ae5f588ac2c3fedf5286dbe90e0e9"></a>BIGGEST_PACKET_SIZE&#160;</td><td class="fielddoc">
<p>Biggest packet size supported by the data link layer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4173550ff10e858368ec6257c122fb3bace656629f5449decd6caeb893bddebb4"></a>PACKET_HEADER_AND_FOOTER_LENGTH&#160;</td><td class="fielddoc">
<p>Consists of: stp8 reserved8 ctrl8 seq_nbr8 length16 data crc2. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4173550ff10e858368ec6257c122fb3ba4a7e9c7facfad14df4eca6081d5243e5"></a>MAXIMUM_BAD_PACKET_LENGTH_SLEEP&#160;</td><td class="fielddoc">
<p>Maximum time to wait after receiving bad packet length. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4173550ff10e858368ec6257c122fb3ba5c57c05602e03704eee26b280ad17ab2"></a>MAXIMUM_BAD_TOGGLE_BIT_SLEEP&#160;</td><td class="fielddoc">
<p>Maximum time to wait after receiving bad toggle bit. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa7e7ccc2efc24c9c07757cf3f41cc7a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MProtocolC1218::MProtocolC1218 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>channelIsOwned</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new C12.18 protocol with the channel given. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel allowed for this type of the protocol is compatible. Otherwise an exception is thrown. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa9f12222a06488962da5768fc970a83d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC1218::DoEndSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously end the session, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol. Depending on the particular protocol this leads to sequence of logoff and terminate commands.</p>
<p>See EndSession, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the protocol state allows ending the session. Otherwise exceptions can be thrown. </dd></dl>

<p>Reimplemented from <a class="el" href="class_m_protocol.html#aa6362a4ce7b3e94cfb464f9f393cebe4">MProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="a1b249ae1c535217e1bcaa523ef01ac36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC1218::DoStartSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously start the session, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol. Depending on the particular protocol this leads to sequence of handshake and logon commands.</p>
<p>See StartSession, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the protocol state allows starting the session. Otherwise exceptions can be thrown. </dd></dl>

<p>Reimplemented from <a class="el" href="class_m_protocol.html#ae7c2fcb6ca3c640a2fab27161c17b336">MProtocol</a>.</p>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1221.html#a14fdee822d3c9cef03a969c0a10e16dc">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="a63f65a558ca22cd976774a79cb755cf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetAcknowledgementTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of milliseconds to wait for the acknowledgement of the packet.</p>
<p>Should this amount of time be exceeded after the packet is sent, and there is no ACK seen (byte 0x06), a timeout condition will occur. Either a retry is triggered, or if the number of retries is zero already, an error is raised.</p>
<p>When <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> gets called, acknowledgement timeout is negotiated with the device to the precision of seconds. See <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> for more details.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>2000 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>, as defined by ANSI standard.</li>
<li>4000 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>, as defined by ANSI standard.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 255000 milliseconds, while values close to zero might not be practical.</dt><dd>The maximum value of 255000 milliseconds is constrained by C12.21 protocol service <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a>, where the timeout is negotiated with the client using byte representation of seconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1221.html#aa9ddd9aa715d44de2e4818834a32ff15">MProtocolC1221::GetIssueTimingSetupOnStartSession</a> - control whether TimingSetup is called at <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8" title="Synchronously start the session. ">StartSession</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447">MProtocolC1221::TimingSetup()</a> - negotiate timeouts and retries with the client, C12.21 only </dd></dl>

</div>
</div>
<a class="anchor" id="afefa52f53b7216835f4b83770a87a3b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetChannelTrafficTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of milliseconds the device waits for a valid packet before terminating the communications session.</p>
<p>Channel traffic timeout applies to the ANSI C12.18 and C12.21 protocols. When C12.21 is used, the value of this property can be agreed with the device by using <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a> service. The agreement leads to approximation of the timeout value to the precision of seconds, and the approximation is done towards the upper value. For example, channel traffic timeouts 5001, 5500 or 5900 will become 6000 after successful <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a>. Because the value is passed to the device as byte value of seconds, the maximum channel traffic timeout value is limited to 255000.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>6000 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a> as defined by ANSI standard.</li>
<li>30000 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a> as defined by ANSI standard.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. 255000 milliseconds, while the value 0 makes little sense as it assumes the device times out after every request</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1221.html#aa9ddd9aa715d44de2e4818834a32ff15">MProtocolC1221::GetIssueTimingSetupOnStartSession</a> - control whether TimingSetup is called at <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8" title="Synchronously start the session. ">StartSession</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447">MProtocolC1221::TimingSetup()</a> - negotiate timeouts and retries with the client, C12.21 only </dd></dl>

</div>
</div>
<a class="anchor" id="a8bc9f7f7b6cb31e73337ead3298b42d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetCheckIncomingToggleBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to check the incoming toggle bit or not.</p>
<p>This property is true by default. If it is false, the incoming toggle bit is ignored.</p>
<p>The ANSI C12.18 and C12.21 protocols define a toggle bit in the control field definition byte. This bit is used to detect duplicate packets. By setting this property to false, MeteringSDK can be forced to not check the toggle bit. This is useful for meters that do not properly implement the ANSI C12 toggle bit.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.0.5.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>True</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The incoming toggle bit is checked.</li>
<li>False [0] : The incoming toggle bit is NOT checked. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9469fd2294caa11aeddfc834a12d67ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetIdentifiedPropertiesPresent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if Identify command was successful, and IDENTIFIED properties are available. </p>
<p>Specifies whether or not the dynamic identified properties are available. The identified properties are only available after a successful start session sequence.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The identified properties are available.</li>
<li>False [0] : The identified properties are not available and querying them will result in an error being raised.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1218.html#a181c42f7f5e504399ef0d23733bb6925">GetIdentifiedReferenceStandard</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1218.html#a01ca7d32e7a31558d23923878790c8e6">GetIdentifiedStandardVersion</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1218.html#af037dec13c48e64314e9560624a6ff84">GetIdentifiedStandardRevision</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a181c42f7f5e504399ef0d23733bb6925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MProtocolC1218::GetIdentifiedReferenceStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reference standard, as identified by the C12.18 Identify command. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Identify is issued successfully, through direct call or through StartSession. Otherwise the exception is thrown.</dd></dl>
<p>The ANSI Reference Standard implemented by the meter. This property is available only after the ANSI C12 Identify request is executed (for example, through a start session sequence). The value of this property persists unchanged until the identification of a different meter is performed. If the property is queried before a successful Identify request, an error is raised. The property <a class="el" href="class_m_protocol_c1218.html#a9469fd2294caa11aeddfc834a12d67ac">GetIdentifiedPropertiesPresent</a> can be used to determine if the IdentifiedReferenceStandard is available.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>None. Must be read from meter during the start session sequence.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 : ANSI C12.18</li>
<li>1 : Used by Industry Canada</li>
<li>2 .. 255 : Reserved </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af037dec13c48e64314e9560624a6ff84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MProtocolC1218::GetIdentifiedStandardRevision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the standard revision, as identified by the C12.18 Identify command. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Identify is issued successfully, through direct call or through StartSession. Otherwise the exception is thrown.</dd></dl>
<p>The revision of the ANSI C12.xx protocol standard, as implemented by the meter. This property is important for scripts that are affected by the differences between revisions of the ANSI C12.xx standards.</p>
<p>This property is available only after the ANSI C12 Identify request is executed (for example, through a start session sequence). The value of this property persists unchanged until the identification of a different meter is performed. If the property is queried before a successful Identify request, an error is raised. The property <a class="el" href="class_m_protocol_c1218.html#a9469fd2294caa11aeddfc834a12d67ac">GetIdentifiedPropertiesPresent</a> can be used to determine if the IdentifiedStandardRevision is available.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>None. Must be read from meter during the start session sequence.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. 255 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a01ca7d32e7a31558d23923878790c8e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MProtocolC1218::GetIdentifiedStandardVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the standard version, as identified by the C12.18 Identify command. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Identify is issued successfully, through direct call or through StartSession. Otherwise the exception is thrown.</dd></dl>
<p>The version of the ANSI C12.xx protocol standard, as implemented by the meter. This property is important for scripts that are affected by the differences between versions of the ANSI C12.xx standards.</p>
<p>This property is available only after the ANSI C12 Identify request is executed (for example, through a start session sequence). The value of this property persists unchanged until the identification of a different meter is performed. If the property is queried before a successful Identify request, an error is raised. The property <a class="el" href="class_m_protocol_c1218.html#a9469fd2294caa11aeddfc834a12d67ac">GetIdentifiedPropertiesPresent</a> can be used to determine if the IdentifiedStandardVersion is available.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>None. Must be read from meter during the start session sequence.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. 255 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a44846efa76bfd1ae0a66034d98f1893a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetIntercharacterTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of milliseconds allowed between individual characters sent or received in the same packet.</p>
<p>Should this amount of time be exceeded in between any two characters in the packet, a timeout condition will occur. Either a retry is triggered, or if the number of retries is zero already, an error is raised.</p>
<p>Intercharacter timeout is not precisely guarded due to hardware constraints, however the implementation guarantees that the actual timeout will not be smaller than the value given to this property. Also, when <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> gets called, intercharacter timeout is negotiated with the device to the precision of seconds. See <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> for more details.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>500 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>, as defined by ANSI standard.</li>
<li>1000 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>, as defined by ANSI standard.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 255000 milliseconds, while values close to zero might not be practical.</dt><dd>The maximum value of 255000 milliseconds is constrained by C12.21 protocol service <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a>, where the timeout is negotiated with the client using byte representation of seconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1221.html#aa9ddd9aa715d44de2e4818834a32ff15">MProtocolC1221::GetIssueTimingSetupOnStartSession</a> - control whether TimingSetup is called at <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8" title="Synchronously start the session. ">StartSession</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447">MProtocolC1221::TimingSetup()</a> - negotiate timeouts and retries with the client, C12.21 only </dd></dl>

</div>
</div>
<a class="anchor" id="a70557df2ceb23bd0f4935392ed1e4eba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetIssueLogoffOnEndSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the Logoff C12 service shall be applied within EndSession sequence.</p>
<p>A standard C12.18 and C12.21 session can end with Terminate, optionally preceded by Logoff. This property allows omitting of Logoff when EndSession is called. The property has no effect on the <a class="el" href="class_m_protocol_c12.html#aeeedd60972e30daaa70274dcab5dd33d" title="Perform ANSI C12 Logoff service. ">Logoff()</a> method that can always be called directly.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.2.0.1720.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>True for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>.</li>
<li>True for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True : Logoff service is issued as part of EndSession sequence</li>
<li>False : Logoff service is issued as part of EndSession sequence. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6b03492e7d1d03f63b989c1d0c9a56d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetIssueNegotiateOnStartSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the Negotiate C12 service shall be applied within StartSession sequence.</p>
<p>When the negotiate service is issued (<a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> = 1), the values of the protocol properties <a class="el" href="class_m_protocol_c1218.html#afbd9cbde13d7bc09c3189b941540a269">GetSessionBaud</a>, <a class="el" href="class_m_protocol_c1218.html#aaa6e475b3ea0b5f309378a6cf848de3b">GetMaximumNumberOfPackets</a>, and <a class="el" href="class_m_protocol_c1218.html#a0ff7811021a55cb04c067f0f901fc759">GetPacketSize</a> are the communication parameters that are requested in the negotiate service. The device does not have to accept the requested communication parameters and may reject them by specifying different values to be used. To discover what values were actually used during communications, one can query the negotiated properties.</p>
<p>When the negotiate service is not issued (IssueNegotiateOnStartSession = 0), the default values of the protocol properties (as defined by the ANSI C12.18 and C12.21 standard) are used for communications. Setting the values of <a class="el" href="class_m_protocol_c1218.html#afbd9cbde13d7bc09c3189b941540a269">GetSessionBaud</a>, <a class="el" href="class_m_protocol_c1218.html#aaa6e475b3ea0b5f309378a6cf848de3b">GetMaximumNumberOfPackets</a>, and <a class="el" href="class_m_protocol_c1218.html#a0ff7811021a55cb04c067f0f901fc759">GetPacketSize</a>, does not affect communications, and reading these property values does not necessarily reflect the values used during communications.</p>
<p>Set IssueNegotiateOnStartSession to false [0] for devices that do not support the negotiate service. The ANSI C12.18 and C12.21 protocol specifies that the negotiate service is optional and devices can respond with Service Not Supported (SNS). When MeteringSDK receives an SNS from the device, it passes the error back to the caller and does not continue with communications.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.26.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>True</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The negotiate service is issued during start session.</li>
<li>False [0] : The negotiate service is NOT issued, <a class="el" href="class_m_protocol_c1218.html#af298e51508b98edcad7f94baa7c93345">GetNegotiatedPropertiesPresent</a> is False and the dynamic negotiated properties raise an error if accessed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaa6e475b3ea0b5f309378a6cf848de3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetMaximumNumberOfPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of link layer packets used by the protocol.</p>
<p>The maximum number of packets that will be requested in the negotiate service sent to the end device. The maximum number of packets is the maximum number of data link layer packets that can be assembled by the implementation into a single service request. After a successful negotiate service, the dynamic property <a class="el" href="class_m_protocol_c1218.html#af01365c27720fb6edf8630970f290461">GetNegotiatedMaximumNumberOfPackets</a> contains the actual value that is used during communication.</p>
<p>The MaximumNumberOfPackets property is only used when the negotiate service is sent to the end device. Whether or not the negotiate service is sent to the end device depends on the property <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a>.</p>
<p>If <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> = 0 [False], then MCOM uses the MaximumNumberOfPackets property value as set, even though the ANSI C12.18 and C12.21 standards define the default value as 1. This is useful for testing firmware.</p>
<p>For more details refer to the ANSI C12.18 and C12.21 standards.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>255 : This is the value that MeteringSDK defaults to. The default maximum number of packets as defined by the ANSI C12.18 and C12.21 standards is 1 packet.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. 255 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af01365c27720fb6edf8630970f290461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetNegotiatedMaximumNumberOfPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum number of packets, which was negotiated with the meter in the Negotiate command. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Negotiate is issued successfully, through direct call or through StartSession. Otherwise the exception is thrown.</dd></dl>
<p>The number of packets that was negotiated with the meter during the start session sequence. This dynamic property is available only after the completion of a successful start session sequence. The value of this property will persist unchanged until another start session sequence. If the property is queried before a successful start session sequence, an error will be raised. The property <a class="el" href="class_m_protocol_c1218.html#af298e51508b98edcad7f94baa7c93345">GetNegotiatedPropertiesPresent</a> can be used to determine if the NegotiatedMaximumNumberOfPackets is available.</p>
<p>During the Negotiate service, if the meter accepts the <a class="el" href="class_m_protocol_c1218.html#aaa6e475b3ea0b5f309378a6cf848de3b">GetMaximumNumberOfPackets</a> from MeteringSDK, then NegotiatedMaximumNumberOfPackets = MaximumNumberOfPackets.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. 255 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1f0a5dd20930b5dcddfd159dc0dcf60b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetNegotiatedPacketSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the packet size which was negotiated with the meter in the Negotiate command. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Negotiate is issued successfully, through direct call or through StartSession. Otherwise the exception is thrown.</dd></dl>
<p>The number of bytes in the packet that was negotiated with the meter during the start session sequence. This dynamic property is available only after the completion of a successful start session sequence. The value of this property will persist unchanged until another start session sequence. If the property is queried before a successful start session sequence, an error is raised. The property <a class="el" href="class_m_protocol_c1218.html#af298e51508b98edcad7f94baa7c93345">GetNegotiatedPropertiesPresent</a> can be used to determine if the NegotiatedPacketSize is available.</p>
<p>During the Negotiate service, if the meter accepts the <a class="el" href="class_m_protocol_c1218.html#a0ff7811021a55cb04c067f0f901fc759">GetPacketSize</a> from MeteringSDK, then NegotiatedPacketSize = PacketSize.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>32 .. 65535 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af298e51508b98edcad7f94baa7c93345"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetNegotiatedPropertiesPresent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if Negotiate command was successful, and negotiated properties are available. </p>
<p>Specifies whether or not the dynamic negotiated properties are available. The negotiated properties are only available after a successful start session sequence.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The negotiated properties are available.</li>
<li>False [0] : The negotiated properties are not available and querying them results in an error being raised.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1218.html#af01365c27720fb6edf8630970f290461">GetNegotiatedMaximumNumberOfPackets</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1218.html#a1f0a5dd20930b5dcddfd159dc0dcf60b">GetNegotiatedPacketSize</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1218.html#a6da583022c5a7bb127bd147619299b38">GetNegotiatedSessionBaud</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6da583022c5a7bb127bd147619299b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetNegotiatedSessionBaud </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the negotiated session baud, which was returned by the meter in the Negotiate command. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Negotiate is issued successfully, through direct call or through StartSession. Otherwise the exception is thrown.</dd></dl>
<p>The SessionBaud rate that was negotiated with the meter during a start session sequence. This dynamic property is available only after the completion of a successful start session sequence. The value of this property will persist unchanged until another start session sequence. If the property is queried before a successful start session sequence, an error is raised. The property <a class="el" href="class_m_protocol_c1218.html#af298e51508b98edcad7f94baa7c93345">GetNegotiatedPropertiesPresent</a> can be used to determine if the NegotiatedSessionBaud is available.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 128000, 256000 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a098e64d06dde8d9e9f0edccf7fdc2a75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetNextOutgoingToggleBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The value of the toggle bit that will be used in the next outgoing data link packet.</p>
<p>The ANSI C12.18 and C12.21 protocols define a toggle bit in the control field definition byte. The toggle bit is used to detect duplicate packets. The NextOutgoingToggleBit property tells what the state of the next toggle bit will be. When True, the next toggle bit will be set to 1. When False, the next toggle bit will be reset to 0.</p>
<p>The NextOutgoingToggleBit property is useful for clients who want to start a session with the meter using QStartSession, then create their own packet(s) to send to the meter (can be sent using channel WriteBytes service). These clients should set/reset the toggle bit of their control byte based on the value of this property. When they are done sending their own packets, they can set the NextOutgoingToggleBit property and the protocol will use this property to determine how to set the toggle bit in the next package it sends to the meter.</p>
<p>The object sets the NextOutgoingToggleBit to zero after an end session. During normal operations, where clients are using QEndSession to terminate the session, the start session will always start with the toggle bit set to zero making it easier to compare logs from different sessions. However, for clients that want to start the session with the toggle bit set to 1, they can do so by simply setting the NextOutgoingToggleBit to 1 prior to starting the session.</p>
<p>Note that when using the communication queues, the communication is executed on QCommit service. It is important to get the NextOutgoingToggleBit after the QCommit service completes, and to set it before starting the QCommit service.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.2.17.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The next outgoing toggle bit will be set to 1.</li>
<li>False [0] : The next outgoing toggle bit will be reset to 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0ff7811021a55cb04c067f0f901fc759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetPacketSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Packet size used by the ANSI protocol.</p>
<p>The packet size that will be requested in the negotiate service sent to the end device. The packet size is the maximum number of bytes allowed in the link layer packet. After a successful negotiate service, the dynamic property NegotiatedPacketSize contains the actual value that is used during communication.</p>
<p>If <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> = 0 [False], then MCOM uses the PacketSize property value as set, even though the ANSI C12.18 and C12.21 standards define the default value as 64 bytes. This is useful for testing firmware.</p>
<p>For more details refer to the ANSI C12.18 and C12.21 standards.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>1024 bytes for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>, different then the ANSI standard which defaults to 64 bytes.</li>
<li>1024 bytes for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>, different then the ANSI standard which defaults to 64 bytes.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>32 .. 8192 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abb05be2271c312b97c4577d6cd1315e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetProcedureInitiateTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of milliseconds which the application layer should wait while reading the ST_007 table.</p>
<p>The number of milliseconds to wait for the device to respond to a procedure initiate request, which is a table write to ST_007. Some procedures, on some devices, can take a long time to execute a procedure. Typically devices handle this by acknowledging the ST_007 write, then responding to the ST_008 table read (procedure response request) with the response code 'procedure accepted but not fully completed', which allows for <a class="el" href="class_m_protocol_c12.html#af584c3e57c6bc43ef22ea6ec4307d237">GetApplicationLayerProcedureRetries</a> to be utilized. However, some devices do not respond at all while executing the procedure, resulting in channel read timeout errors on the link layer where <a class="el" href="class_m_protocol_c12.html#a83cbf50c3fe4c8b5f882d3d6c41f860c">GetLinkLayerRetries</a> are utilized. The ProcedureInitiateTimeout value corrects this situation by temporarily increasing the number of Link Layer Retries so that <a class="el" href="class_m_protocol_c12.html#a83cbf50c3fe4c8b5f882d3d6c41f860c">GetLinkLayerRetries</a> * <a class="el" href="class_m_protocol_c1218.html#a63f65a558ca22cd976774a79cb755cf7">GetAcknowledgementTimeout</a> is not less than ProcedureInitiateTimeout.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.1.2.1690.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>20000 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT_MAX </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afbd9cbde13d7bc09c3189b941540a269"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocolC1218::GetSessionBaud </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Session baud, one which is negotiated with the meter during communication.</p>
<p>When the session baud is nonzero, the suggested baud rate is requested in the negotiate service sent to the device. After a successful negotiate service, the dynamic property <a class="el" href="class_m_protocol_c1218.html#a6da583022c5a7bb127bd147619299b38">GetNegotiatedSessionBaud</a> contains the actual value that is used during communication. Prior to the negotiate service, in case of optical probe the communications start at 9600 bps.</p>
<p>Whether or not the negotiate service is sent to the device depends on the property <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a>. Therefore, to change optical probe baud at negotiate, one shall set <a class="el" href="class_m_protocol_c1218.html#aa94499b1450b0f8a16f0e77c2dd6dcef">SetIssueNegotiateOnStartSession</a> to True, and <a class="el" href="class_m_protocol_c1218.html#a29ca39e3fcb8b56b63b4106bca774b1f">SetSessionBaud</a> shall be a nonzero value that is a valid baud rate accepted by this property, and by the device.</p>
<p>For more details refer to the ANSI C12.18 and C12.21 standards.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>9600</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 means session baud is not agreed on Negotiate.</li>
<li>300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 128000, 256000 - possible session baud rates. Not all optical probes are able to support the higher baud rates. Devices may not support all speeds. Support of 9600 is required because this is the speed that the session starts at. Device support for speeds is not necessarily hierarchical, for example a device might support 128000 but not 115200. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a326b8097ee0137143260810d072ddf89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocolC1218::GetWakeUpSharedOpticalPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to wake up the shared optical probe on start session.</p>
<p>Determines whether or not a garbage character (0x55) is sent before an identify request to 'wake up' the shared optical port. This property only needs to be set to True when the meter has a shared optical port. Sending the garbage character resolves the problem where the UART is connected to the remote port, the identify command is sent through the optical port, the meter receives the first character (0xEE) while connected to the remote port and switches the UART to the optical port and changes the bit rate, but the meter misses at least the first character of the packet. By sending a garbage character, the meter is given time to switch the UART to the optical port before it receives the first request.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.26.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The garbage character, 0x55, is sent before an identify request in the start session sequence.</li>
<li>False [0] : The garbage character is NOT sent before an identify request in the start session sequence. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5a272c467ccc7c59e7f0e456fdb004c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC1218::Identify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Identify request. </p>
<p>This service is called from StartSession, but it can also be called directly by the user for testing purpose.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Identify to be called. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1221.html#a5c695a7e5731dd19307c47cd0618f12e">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="aa301bc65a4b2ff7e6cde4886b9327d33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocolC1218::Negotiate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform ANSI C12 Negotiate request. </p>
<p>This service is called from StartSession, but it can also be called directly by the user for testing purpose. The implementation negotiates packet size, number of packets, and one baud rate (command 0x61).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, and the protocol state allows Negotiate to be called. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1221.html#aeb98e983e2c53e0b9d696de4f58694b5">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="aa2cacb35c92362f3dffa8636f9e2996f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetAcknowledgementTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of milliseconds to wait for the acknowledgement of the packet.</p>
<p>Should this amount of time be exceeded after the packet is sent, and there is no ACK seen (byte 0x06), a timeout condition will occur. Either a retry is triggered, or if the number of retries is zero already, an error is raised.</p>
<p>When <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> gets called, acknowledgement timeout is negotiated with the device to the precision of seconds. See <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> for more details.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>2000 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>, as defined by ANSI standard.</li>
<li>4000 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>, as defined by ANSI standard.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 255000 milliseconds, while values close to zero might not be practical.</dt><dd>The maximum value of 255000 milliseconds is constrained by C12.21 protocol service <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a>, where the timeout is negotiated with the client using byte representation of seconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1221.html#aa9ddd9aa715d44de2e4818834a32ff15">MProtocolC1221::GetIssueTimingSetupOnStartSession</a> - control whether TimingSetup is called at <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8" title="Synchronously start the session. ">StartSession</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447">MProtocolC1221::TimingSetup()</a> - negotiate timeouts and retries with the client, C12.21 only </dd></dl>

</div>
</div>
<a class="anchor" id="ab992758a4dbd69a8f38bf9138c5d219c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetChannelTrafficTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of milliseconds the device waits for a valid packet before terminating the communications session.</p>
<p>Channel traffic timeout applies to the ANSI C12.18 and C12.21 protocols. When C12.21 is used, the value of this property can be agreed with the device by using <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a> service. The agreement leads to approximation of the timeout value to the precision of seconds, and the approximation is done towards the upper value. For example, channel traffic timeouts 5001, 5500 or 5900 will become 6000 after successful <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a>. Because the value is passed to the device as byte value of seconds, the maximum channel traffic timeout value is limited to 255000.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>6000 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a> as defined by ANSI standard.</li>
<li>30000 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a> as defined by ANSI standard.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. 255000 milliseconds, while the value 0 makes little sense as it assumes the device times out after every request</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1221.html#aa9ddd9aa715d44de2e4818834a32ff15">MProtocolC1221::GetIssueTimingSetupOnStartSession</a> - control whether TimingSetup is called at <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8" title="Synchronously start the session. ">StartSession</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447">MProtocolC1221::TimingSetup()</a> - negotiate timeouts and retries with the client, C12.21 only </dd></dl>

</div>
</div>
<a class="anchor" id="a62cb15b4f7ce4901fedff404bd6e25bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetCheckIncomingToggleBit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doCheck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to check the incoming toggle bit or not.</p>
<p>This property is true by default. If it is false, the incoming toggle bit is ignored.</p>
<p>The ANSI C12.18 and C12.21 protocols define a toggle bit in the control field definition byte. This bit is used to detect duplicate packets. By setting this property to false, MeteringSDK can be forced to not check the toggle bit. This is useful for meters that do not properly implement the ANSI C12 toggle bit.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.0.5.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>True</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The incoming toggle bit is checked.</li>
<li>False [0] : The incoming toggle bit is NOT checked. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aecf4c1c08d369b34bbd6234a493ec168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetIntercharacterTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of milliseconds allowed between individual characters sent or received in the same packet.</p>
<p>Should this amount of time be exceeded in between any two characters in the packet, a timeout condition will occur. Either a retry is triggered, or if the number of retries is zero already, an error is raised.</p>
<p>Intercharacter timeout is not precisely guarded due to hardware constraints, however the implementation guarantees that the actual timeout will not be smaller than the value given to this property. Also, when <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> gets called, intercharacter timeout is negotiated with the device to the precision of seconds. See <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup</a> for more details.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>500 milliseconds for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>, as defined by ANSI standard.</li>
<li>1000 milliseconds for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>, as defined by ANSI standard.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values: 0 .. 255000 milliseconds, while values close to zero might not be practical.</dt><dd>The maximum value of 255000 milliseconds is constrained by C12.21 protocol service <a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447" title="Perform ANSI C12 TimingSetup request. ">MProtocolC1221::TimingSetup()</a>, where the timeout is negotiated with the client using byte representation of seconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol_c1221.html#aa9ddd9aa715d44de2e4818834a32ff15">MProtocolC1221::GetIssueTimingSetupOnStartSession</a> - control whether TimingSetup is called at <a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8" title="Synchronously start the session. ">StartSession</a> </dd>
<dd>
<a class="el" href="class_m_protocol_c1221.html#aad8c6e83fd1e877bd5169f9c82ff7447">MProtocolC1221::TimingSetup()</a> - negotiate timeouts and retries with the client, C12.21 only </dd></dl>

</div>
</div>
<a class="anchor" id="adc924303fb3c6d1c2065b64fa5b07c93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetIssueLogoffOnEndSession </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the Logoff C12 service shall be applied within EndSession sequence.</p>
<p>A standard C12.18 and C12.21 session can end with Terminate, optionally preceded by Logoff. This property allows omitting of Logoff when EndSession is called. The property has no effect on the <a class="el" href="class_m_protocol_c12.html#aeeedd60972e30daaa70274dcab5dd33d" title="Perform ANSI C12 Logoff service. ">Logoff()</a> method that can always be called directly.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.2.0.1720.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>True for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>.</li>
<li>True for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True : Logoff service is issued as part of EndSession sequence</li>
<li>False : Logoff service is issued as part of EndSession sequence. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa94499b1450b0f8a16f0e77c2dd6dcef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetIssueNegotiateOnStartSession </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the Negotiate C12 service shall be applied within StartSession sequence.</p>
<p>When the negotiate service is issued (<a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> = 1), the values of the protocol properties <a class="el" href="class_m_protocol_c1218.html#afbd9cbde13d7bc09c3189b941540a269">GetSessionBaud</a>, <a class="el" href="class_m_protocol_c1218.html#aaa6e475b3ea0b5f309378a6cf848de3b">GetMaximumNumberOfPackets</a>, and <a class="el" href="class_m_protocol_c1218.html#a0ff7811021a55cb04c067f0f901fc759">GetPacketSize</a> are the communication parameters that are requested in the negotiate service. The device does not have to accept the requested communication parameters and may reject them by specifying different values to be used. To discover what values were actually used during communications, one can query the negotiated properties.</p>
<p>When the negotiate service is not issued (IssueNegotiateOnStartSession = 0), the default values of the protocol properties (as defined by the ANSI C12.18 and C12.21 standard) are used for communications. Setting the values of <a class="el" href="class_m_protocol_c1218.html#afbd9cbde13d7bc09c3189b941540a269">GetSessionBaud</a>, <a class="el" href="class_m_protocol_c1218.html#aaa6e475b3ea0b5f309378a6cf848de3b">GetMaximumNumberOfPackets</a>, and <a class="el" href="class_m_protocol_c1218.html#a0ff7811021a55cb04c067f0f901fc759">GetPacketSize</a>, does not affect communications, and reading these property values does not necessarily reflect the values used during communications.</p>
<p>Set IssueNegotiateOnStartSession to false [0] for devices that do not support the negotiate service. The ANSI C12.18 and C12.21 protocol specifies that the negotiate service is optional and devices can respond with Service Not Supported (SNS). When MeteringSDK receives an SNS from the device, it passes the error back to the caller and does not continue with communications.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.26.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>True</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The negotiate service is issued during start session.</li>
<li>False [0] : The negotiate service is NOT issued, <a class="el" href="class_m_protocol_c1218.html#af298e51508b98edcad7f94baa7c93345">GetNegotiatedPropertiesPresent</a> is False and the dynamic negotiated properties raise an error if accessed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad2618879810d4595899ec61a211dfed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetMaximumNumberOfPackets </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of link layer packets used by the protocol.</p>
<p>The maximum number of packets that will be requested in the negotiate service sent to the end device. The maximum number of packets is the maximum number of data link layer packets that can be assembled by the implementation into a single service request. After a successful negotiate service, the dynamic property <a class="el" href="class_m_protocol_c1218.html#af01365c27720fb6edf8630970f290461">GetNegotiatedMaximumNumberOfPackets</a> contains the actual value that is used during communication.</p>
<p>The MaximumNumberOfPackets property is only used when the negotiate service is sent to the end device. Whether or not the negotiate service is sent to the end device depends on the property <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a>.</p>
<p>If <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> = 0 [False], then MCOM uses the MaximumNumberOfPackets property value as set, even though the ANSI C12.18 and C12.21 standards define the default value as 1. This is useful for testing firmware.</p>
<p>For more details refer to the ANSI C12.18 and C12.21 standards.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>255 : This is the value that MeteringSDK defaults to. The default maximum number of packets as defined by the ANSI C12.18 and C12.21 standards is 1 packet.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>1 .. 255 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a530ef727608be3cad6d5260de719c5d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetNextOutgoingToggleBit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The value of the toggle bit that will be used in the next outgoing data link packet.</p>
<p>The ANSI C12.18 and C12.21 protocols define a toggle bit in the control field definition byte. The toggle bit is used to detect duplicate packets. The NextOutgoingToggleBit property tells what the state of the next toggle bit will be. When True, the next toggle bit will be set to 1. When False, the next toggle bit will be reset to 0.</p>
<p>The NextOutgoingToggleBit property is useful for clients who want to start a session with the meter using QStartSession, then create their own packet(s) to send to the meter (can be sent using channel WriteBytes service). These clients should set/reset the toggle bit of their control byte based on the value of this property. When they are done sending their own packets, they can set the NextOutgoingToggleBit property and the protocol will use this property to determine how to set the toggle bit in the next package it sends to the meter.</p>
<p>The object sets the NextOutgoingToggleBit to zero after an end session. During normal operations, where clients are using QEndSession to terminate the session, the start session will always start with the toggle bit set to zero making it easier to compare logs from different sessions. However, for clients that want to start the session with the toggle bit set to 1, they can do so by simply setting the NextOutgoingToggleBit to 1 prior to starting the session.</p>
<p>Note that when using the communication queues, the communication is executed on QCommit service. It is important to get the NextOutgoingToggleBit after the QCommit service completes, and to set it before starting the QCommit service.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.2.17.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The next outgoing toggle bit will be set to 1.</li>
<li>False [0] : The next outgoing toggle bit will be reset to 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a40cccd7fddbbdda3278a0b4f46364844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetPacketSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>packetSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet size used by the ANSI protocol.</p>
<p>The packet size that will be requested in the negotiate service sent to the end device. The packet size is the maximum number of bytes allowed in the link layer packet. After a successful negotiate service, the dynamic property NegotiatedPacketSize contains the actual value that is used during communication.</p>
<p>If <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a> = 0 [False], then MCOM uses the PacketSize property value as set, even though the ANSI C12.18 and C12.21 standards define the default value as 64 bytes. This is useful for testing firmware.</p>
<p>For more details refer to the ANSI C12.18 and C12.21 standards.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>1024 bytes for <a class="el" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. ">MProtocolC1218</a>, different then the ANSI standard which defaults to 64 bytes.</li>
<li>1024 bytes for <a class="el" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. ">MProtocolC1221</a>, different then the ANSI standard which defaults to 64 bytes.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>32 .. 8192 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad72c6ce6de5a486159a7d9fa865beab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetProcedureInitiateTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>procedureInitiateTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of milliseconds which the application layer should wait while reading the ST_007 table.</p>
<p>The number of milliseconds to wait for the device to respond to a procedure initiate request, which is a table write to ST_007. Some procedures, on some devices, can take a long time to execute a procedure. Typically devices handle this by acknowledging the ST_007 write, then responding to the ST_008 table read (procedure response request) with the response code 'procedure accepted but not fully completed', which allows for <a class="el" href="class_m_protocol_c12.html#af584c3e57c6bc43ef22ea6ec4307d237">GetApplicationLayerProcedureRetries</a> to be utilized. However, some devices do not respond at all while executing the procedure, resulting in channel read timeout errors on the link layer where <a class="el" href="class_m_protocol_c12.html#a83cbf50c3fe4c8b5f882d3d6c41f860c">GetLinkLayerRetries</a> are utilized. The ProcedureInitiateTimeout value corrects this situation by temporarily increasing the number of Link Layer Retries so that <a class="el" href="class_m_protocol_c12.html#a83cbf50c3fe4c8b5f882d3d6c41f860c">GetLinkLayerRetries</a> * <a class="el" href="class_m_protocol_c1218.html#a63f65a558ca22cd976774a79cb755cf7">GetAcknowledgementTimeout</a> is not less than ProcedureInitiateTimeout.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.1.2.1690.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>20000 milliseconds</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT_MAX </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a29ca39e3fcb8b56b63b4106bca774b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetSessionBaud </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sessionBaud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Session baud, one which is negotiated with the meter during communication.</p>
<p>When the session baud is nonzero, the suggested baud rate is requested in the negotiate service sent to the device. After a successful negotiate service, the dynamic property <a class="el" href="class_m_protocol_c1218.html#a6da583022c5a7bb127bd147619299b38">GetNegotiatedSessionBaud</a> contains the actual value that is used during communication. Prior to the negotiate service, in case of optical probe the communications start at 9600 bps.</p>
<p>Whether or not the negotiate service is sent to the device depends on the property <a class="el" href="class_m_protocol_c1218.html#a6b03492e7d1d03f63b989c1d0c9a56d9">GetIssueNegotiateOnStartSession</a>. Therefore, to change optical probe baud at negotiate, one shall set <a class="el" href="class_m_protocol_c1218.html#aa94499b1450b0f8a16f0e77c2dd6dcef">SetIssueNegotiateOnStartSession</a> to True, and <a class="el" href="class_m_protocol_c1218.html#a29ca39e3fcb8b56b63b4106bca774b1f">SetSessionBaud</a> shall be a nonzero value that is a valid baud rate accepted by this property, and by the device.</p>
<p>For more details refer to the ANSI C12.18 and C12.21 standards.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>9600</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 means session baud is not agreed on Negotiate.</li>
<li>300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 128000, 256000 - possible session baud rates. Not all optical probes are able to support the higher baud rates. Devices may not support all speeds. Support of 9600 is required because this is the speed that the session starts at. Device support for speeds is not necessarily hierarchical, for example a device might support 128000 but not 115200. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7889aaf314926c451c2c5e13d57951fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocolC1218::SetWakeUpSharedOpticalPort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeUp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to wake up the shared optical probe on start session.</p>
<p>Determines whether or not a garbage character (0x55) is sent before an identify request to 'wake up' the shared optical port. This property only needs to be set to True when the meter has a shared optical port. Sending the garbage character resolves the problem where the UART is connected to the remote port, the identify command is sent through the optical port, the meter receives the first character (0xEE) while connected to the remote port and switches the UART to the optical port and changes the bit rate, but the meter misses at least the first character of the packet. By sending a garbage character, the meter is given time to switch the UART to the optical port before it receives the first request.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.26.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The garbage character, 0x55, is sent before an identify request in the start session sequence.</li>
<li>False [0] : The garbage character is NOT sent before an identify request in the start session sequence. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
