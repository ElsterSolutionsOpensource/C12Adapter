<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MBufferCircular Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_buffer_circular.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_buffer_circular-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MBufferCircular Class Reference<div class="ingroups"><a class="el" href="group___m_c_o_m.html">MCOM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Byte buffer with variable capacity that allows efficient buffering by having one reader/getter and one writer/putter.  
 <a href="class_m_buffer_circular.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3340008f21a4ea76e77ffc207796637f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_m_buffer_circular.html#a3340008f21a4ea76e77ffc207796637fa3bd2ee5eaa17ca75f9001e6f2597a67d">DEFAULT_INITIAL_CAPACITY</a> = 1024
 }</td></tr>
<tr class="separator:a3340008f21a4ea76e77ffc207796637f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab754892dcbf520080a0a8c12972117e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#ab754892dcbf520080a0a8c12972117e4">MBufferCircular</a> (unsigned initialCapacity=<a class="el" href="class_m_buffer_circular.html#a3340008f21a4ea76e77ffc207796637fa3bd2ee5eaa17ca75f9001e6f2597a67d">DEFAULT_INITIAL_CAPACITY</a>)</td></tr>
<tr class="memdesc:ab754892dcbf520080a0a8c12972117e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create buffer of a given initial capacity.  <a href="#ab754892dcbf520080a0a8c12972117e4">More...</a><br /></td></tr>
<tr class="separator:ab754892dcbf520080a0a8c12972117e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa393f700716f8dd65b8232e485dc71fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa393f700716f8dd65b8232e485dc71fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#aa393f700716f8dd65b8232e485dc71fe">~MBufferCircular</a> ()</td></tr>
<tr class="memdesc:aa393f700716f8dd65b8232e485dc71fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer destructor. <br /></td></tr>
<tr class="separator:aa393f700716f8dd65b8232e485dc71fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a8eb0421e9e8281d050ef67ac1a476"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75a8eb0421e9e8281d050ef67ac1a476"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#a75a8eb0421e9e8281d050ef67ac1a476">GetSize</a> () const </td></tr>
<tr class="memdesc:a75a8eb0421e9e8281d050ef67ac1a476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes buffered, available for getting. <br /></td></tr>
<tr class="separator:a75a8eb0421e9e8281d050ef67ac1a476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708601eb91e9dff7933773560e4d2786"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#a708601eb91e9dff7933773560e4d2786">CanPutWithoutResize</a> () const </td></tr>
<tr class="memdesc:a708601eb91e9dff7933773560e4d2786"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many bytes can be put into circular buffer without necessity to reallocate buffer.  <a href="#a708601eb91e9dff7933773560e4d2786">More...</a><br /></td></tr>
<tr class="separator:a708601eb91e9dff7933773560e4d2786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f9838ec32c1d568c676d9c45a84af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4f9838ec32c1d568c676d9c45a84af9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#aa4f9838ec32c1d568c676d9c45a84af9">Clear</a> ()</td></tr>
<tr class="memdesc:aa4f9838ec32c1d568c676d9c45a84af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the contents of the buffer so the size becomes zero. <br /></td></tr>
<tr class="separator:aa4f9838ec32c1d568c676d9c45a84af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501ceeade4a45f9b8262acaad9a46bfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#a501ceeade4a45f9b8262acaad9a46bfa">Resize</a> (unsigned newCapacity)</td></tr>
<tr class="memdesc:a501ceeade4a45f9b8262acaad9a46bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffer to given capacity.  <a href="#a501ceeade4a45f9b8262acaad9a46bfa">More...</a><br /></td></tr>
<tr class="separator:a501ceeade4a45f9b8262acaad9a46bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519d5a5cc4edc9c225a0907567b39bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#a519d5a5cc4edc9c225a0907567b39bc8">Put</a> (const char *buff, unsigned size)</td></tr>
<tr class="memdesc:a519d5a5cc4edc9c225a0907567b39bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the whole given buffer, grow object capacity if necessary.  <a href="#a519d5a5cc4edc9c225a0907567b39bc8">More...</a><br /></td></tr>
<tr class="separator:a519d5a5cc4edc9c225a0907567b39bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc74216447382c910a86ce8ce2d294a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_buffer_circular.html#a3fc74216447382c910a86ce8ce2d294a">Get</a> (char *buff, unsigned size)</td></tr>
<tr class="memdesc:a3fc74216447382c910a86ce8ce2d294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data given chunk from the circular buffer.  <a href="#a3fc74216447382c910a86ce8ce2d294a">More...</a><br /></td></tr>
<tr class="separator:a3fc74216447382c910a86ce8ce2d294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Byte buffer with variable capacity that allows efficient buffering by having one reader/getter and one writer/putter. </p>
<p>This is a slightly more efficient std::deque, which lacks methods to pop chunks of bytes. Grows as necessary to accommodate putting of any number of bytes. However, of course, one cannot get more bytes than available in the buffer. The class is low level and it does not throw exceptions as any would be a program error. Synchronization has to be provided outside. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a3340008f21a4ea76e77ffc207796637f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3340008f21a4ea76e77ffc207796637fa3bd2ee5eaa17ca75f9001e6f2597a67d"></a>DEFAULT_INITIAL_CAPACITY&#160;</td><td class="fielddoc">
<p>Default initial capacity of the buffer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab754892dcbf520080a0a8c12972117e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MBufferCircular::MBufferCircular </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>initialCapacity</em> = <code><a class="el" href="class_m_buffer_circular.html#a3340008f21a4ea76e77ffc207796637fa3bd2ee5eaa17ca75f9001e6f2597a67d">DEFAULT_INITIAL_CAPACITY</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create buffer of a given initial capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>Byte size of the initial buffer, will grow if necessary. Should be more than 2, typical is a power of 2 like 512. The default initial capacity is 1024. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a708601eb91e9dff7933773560e4d2786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MBufferCircular::CanPutWithoutResize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many bytes can be put into circular buffer without necessity to reallocate buffer. </p>
<p>This method is rarely needed as the buffer is reallocated at necessity. </p>

</div>
</div>
<a class="anchor" id="a3fc74216447382c910a86ce8ce2d294a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MBufferCircular::Get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data given chunk from the circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Buffer where to get the data. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the chunk. Size and offset should fit within the buffer length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of bytes got, could be zero if the buffer is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a519d5a5cc4edc9c225a0907567b39bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MBufferCircular::Put </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the whole given buffer, grow object capacity if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Buffer where the chunk is located. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the chunk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a501ceeade4a45f9b8262acaad9a46bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MBufferCircular::Resize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the buffer to given capacity. </p>
<p>Note that the real amount of bytes that can be put into the buffer is one less than its capacity. In most cases there is no need for this method to be called as the growth happens transparently when necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>New capacity of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_buffer_circular.html">MBufferCircular</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
