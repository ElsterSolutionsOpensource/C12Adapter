<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MAes Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_aes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_m_aes-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MAes Class Reference<div class="ingroups"><a class="el" href="group___m_c_o_r_e.html">MCORE</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>AES encryption and decryption class.  
 <a href="class_m_aes.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MAes:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_aes__inherit__graph.png" border="0" usemap="#_m_aes_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_aes_inherit__map" id="_m_aes_inherit__map">
<area shape="rect" id="node3" href="class_m_aes_eax.html" title="AES encryption and decryption in EAX mode with authentication. " alt="" coords="5,155,84,181"/>
<area shape="rect" id="node2" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars..." alt="" coords="9,5,80,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6bcd360ed1419453c0724e31814e4c9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_aes.html#a6bcd360ed1419453c0724e31814e4c9fa57b0460543f3b45f47af4d436c382e71">KeySize</a> = 16, 
<br />
&#160;&#160;<a class="el" href="class_m_aes.html#a6bcd360ed1419453c0724e31814e4c9fa565fc72a09011051c38a851bb9f76b03">BlockSize</a> = 16, 
<br />
&#160;&#160;<a class="el" href="class_m_aes.html#a6bcd360ed1419453c0724e31814e4c9fa1df239630a7f10f934856df2da1195c2">KeyWrapEncryptionExtraSize</a> = 8, 
<br />
&#160;&#160;<a class="el" href="class_m_aes.html#a6bcd360ed1419453c0724e31814e4c9fa6c2ef1f869bf3363cf8f62a3b4f86b81">KeyWrapMinimumSize</a> = KeySize, 
<br />
&#160;&#160;<a class="el" href="class_m_aes.html#a6bcd360ed1419453c0724e31814e4c9fa4e283d6439b594fb91b6bad9b216fc68">KeyWrapMaximumSize</a> = 2048
<br />
 }</td></tr>
<tr class="separator:a6bcd360ed1419453c0724e31814e4c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6080c7085120424347e135294f464401"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a6080c7085120424347e135294f464401">MAes</a> ()</td></tr>
<tr class="memdesc:a6080c7085120424347e135294f464401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create AES encryption class without setting the key.  <a href="#a6080c7085120424347e135294f464401">More...</a><br /></td></tr>
<tr class="separator:a6080c7085120424347e135294f464401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df21a53ff189da2857ba0b0516fc359"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a8df21a53ff189da2857ba0b0516fc359">MAes</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;key)</td></tr>
<tr class="memdesc:a8df21a53ff189da2857ba0b0516fc359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create AES encryption class with key, given as raw 16 bytes.  <a href="#a8df21a53ff189da2857ba0b0516fc359">More...</a><br /></td></tr>
<tr class="separator:a8df21a53ff189da2857ba0b0516fc359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7799208a771228d9272dd88fcceea982"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a7799208a771228d9272dd88fcceea982">MAes</a> (const <a class="el" href="class_m_aes.html">MAes</a> &amp;other)</td></tr>
<tr class="memdesc:a7799208a771228d9272dd88fcceea982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, creates a copy of a given object.  <a href="#a7799208a771228d9272dd88fcceea982">More...</a><br /></td></tr>
<tr class="separator:a7799208a771228d9272dd88fcceea982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c0c6a3e3954a79026439ad81b1c0d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12c0c6a3e3954a79026439ad81b1c0d8"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a12c0c6a3e3954a79026439ad81b1c0d8">~MAes</a> ()</td></tr>
<tr class="memdesc:a12c0c6a3e3954a79026439ad81b1c0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, reclaims memory allocated by the object. <br /></td></tr>
<tr class="separator:a12c0c6a3e3954a79026439ad81b1c0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab174f5135642f6ad4ca8957b1998f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_aes.html">MAes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#aab174f5135642f6ad4ca8957b1998f9c">operator=</a> (const <a class="el" href="class_m_aes.html">MAes</a> &amp;other)</td></tr>
<tr class="memdesc:aab174f5135642f6ad4ca8957b1998f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that copies the key from another class.  <a href="#aab174f5135642f6ad4ca8957b1998f9c">More...</a><br /></td></tr>
<tr class="separator:aab174f5135642f6ad4ca8957b1998f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd76af78e403dad5bd1b4d436f997fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a0dd76af78e403dad5bd1b4d436f997fb">Encrypt</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;plainText)</td></tr>
<tr class="memdesc:a0dd76af78e403dad5bd1b4d436f997fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a given chunk of data with AES using plain and simple ECB mode.  <a href="#a0dd76af78e403dad5bd1b4d436f997fb">More...</a><br /></td></tr>
<tr class="separator:a0dd76af78e403dad5bd1b4d436f997fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1531f11441a8249fe10b813ccda856f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ae1531f11441a8249fe10b813ccda856f">Decrypt</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;cipherText)</td></tr>
<tr class="memdesc:ae1531f11441a8249fe10b813ccda856f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a given chunk of data with AES using plain and simple ECB mode.  <a href="#ae1531f11441a8249fe10b813ccda856f">More...</a><br /></td></tr>
<tr class="separator:ae1531f11441a8249fe10b813ccda856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9444b26f7d5e75403a8e4c40a0203a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ad9444b26f7d5e75403a8e4c40a0203a7">KeyWrap</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;keys)</td></tr>
<tr class="memdesc:ad9444b26f7d5e75403a8e4c40a0203a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap the given key material, one or more keys, using RFC 3394 key wrap algorithm.  <a href="#ad9444b26f7d5e75403a8e4c40a0203a7">More...</a><br /></td></tr>
<tr class="separator:ad9444b26f7d5e75403a8e4c40a0203a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01ec1e86d1917599ccd231d98f34293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#aa01ec1e86d1917599ccd231d98f34293">KeyUnwrap</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;cipher)</td></tr>
<tr class="memdesc:aa01ec1e86d1917599ccd231d98f34293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap the given cipher and produce the original key material, one or more keys.  <a href="#aa01ec1e86d1917599ccd231d98f34293">More...</a><br /></td></tr>
<tr class="separator:aa01ec1e86d1917599ccd231d98f34293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3777cb0e78f463938508dec147b33c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ad3777cb0e78f463938508dec147b33c6">GetKey</a> () const </td></tr>
<tr class="separator:ad3777cb0e78f463938508dec147b33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bc9239036bc0e1ac6151ea4fe1eae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a93bc9239036bc0e1ac6151ea4fe1eae0">SetKey</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;)</td></tr>
<tr class="separator:a93bc9239036bc0e1ac6151ea4fe1eae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a677384cc592b33b55a61d84c28671ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a677384cc592b33b55a61d84c28671ee9">GetHexKey</a> () const </td></tr>
<tr class="separator:a677384cc592b33b55a61d84c28671ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c17995c865a7491f890e99c8e0c142f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a0c17995c865a7491f890e99c8e0c142f">SetHexKey</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;)</td></tr>
<tr class="separator:a0c17995c865a7491f890e99c8e0c142f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a56a91e87be48f615c939fc88d8780b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a56a91e87be48f615c939fc88d8780b6a">EncryptBuffer</a> (const Muint8 *plainText, Muint8 *cipherText)</td></tr>
<tr class="separator:a56a91e87be48f615c939fc88d8780b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af993ff7ae16d14dfb6789573385a976f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#af993ff7ae16d14dfb6789573385a976f">EncryptBuffer</a> (const char *plainText, char *cipherText)</td></tr>
<tr class="separator:af993ff7ae16d14dfb6789573385a976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2bbd071915c5d54ff39a40b53a16b10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a2bbd071915c5d54ff39a40b53a16b10a">DecryptBuffer</a> (const Muint8 *cipherText, Muint8 *plainText)</td></tr>
<tr class="separator:a2bbd071915c5d54ff39a40b53a16b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf084c56c5fa4a340cea196262eafa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a4bf084c56c5fa4a340cea196262eafa7">DecryptBuffer</a> (const char *cipherText, char *plainText)</td></tr>
<tr class="separator:a4bf084c56c5fa4a340cea196262eafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ade10b5a636ca7860ac7865bb2c92b846"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ade10b5a636ca7860ac7865bb2c92b846">KeyWrapBuffer</a> (const Muint8 *keyText, unsigned keyTextSize, Muint8 *cipherText)</td></tr>
<tr class="separator:ade10b5a636ca7860ac7865bb2c92b846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d4a8b6cd0d6d4259be79d8210ad6af"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a56d4a8b6cd0d6d4259be79d8210ad6af">KeyWrapBuffer</a> (const char *keyText, unsigned keyTextSize, char *cipherText)</td></tr>
<tr class="separator:a56d4a8b6cd0d6d4259be79d8210ad6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a883df6d2086af2c29c76a11255ce0184"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a883df6d2086af2c29c76a11255ce0184">KeyUnwrapBuffer</a> (const Muint8 *cipherText, unsigned cipherTextSize, Muint8 *keyText)</td></tr>
<tr class="separator:a883df6d2086af2c29c76a11255ce0184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa96f7f8578fccf184d9dbf26da830fd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#afa96f7f8578fccf184d9dbf26da830fd">KeyUnwrapBuffer</a> (const char *cipherText, unsigned cipherTextSize, char *keyText)</td></tr>
<tr class="separator:afa96f7f8578fccf184d9dbf26da830fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44959297f429d05d4408c88d7596afc4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a44959297f429d05d4408c88d7596afc4">~MObject</a> ()</td></tr>
<tr class="memdesc:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a297127a242f90a602d4ba24243591b52">GetClass</a> () const  =0</td></tr>
<tr class="memdesc:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final class of the object.  <a href="#a297127a242f90a602d4ba24243591b52">More...</a><br /></td></tr>
<tr class="separator:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a87705dec46a625badd4ceda29547b338">GetEmbeddedSizeof</a> () const </td></tr>
<tr class="memdesc:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">For embedded object types, return the size of the class.  <a href="#a87705dec46a625badd4ceda29547b338">More...</a><br /></td></tr>
<tr class="separator:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a203c3127403741b20df02335c1015532">IsEmbeddedObject</a> () const </td></tr>
<tr class="memdesc:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the object is of embedded kind.  <a href="#a203c3127403741b20df02335c1015532">More...</a><br /></td></tr>
<tr class="separator:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">SHOW_INTERNAL <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad752a5e3b6800212e453481287e28067">Call</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;params)</td></tr>
<tr class="memdesc:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant.  <a href="#ad752a5e3b6800212e453481287e28067">More...</a><br /></td></tr>
<tr class="separator:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a62a3a6bb2e0e64a644b0be916a502492">Call0</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with no parameters.  <a href="#a62a3a6bb2e0e64a644b0be916a502492">More...</a><br /></td></tr>
<tr class="separator:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3dafe0a11416dd435a4384678f9fe010">Call1</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1)</td></tr>
<tr class="memdesc:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with one parameter.  <a href="#a3dafe0a11416dd435a4384678f9fe010">More...</a><br /></td></tr>
<tr class="separator:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a47cced5e73d0558ac761367380efde52">Call2</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2)</td></tr>
<tr class="memdesc:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with two parameter.  <a href="#a47cced5e73d0558ac761367380efde52">More...</a><br /></td></tr>
<tr class="separator:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad5b38fa7d1eedf7640183ce1bf750479">Call3</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3)</td></tr>
<tr class="memdesc:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with three parameter.  <a href="#ad5b38fa7d1eedf7640183ce1bf750479">More...</a><br /></td></tr>
<tr class="separator:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#abac65416662f68d208674270c4fc2a95">Call4</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4)</td></tr>
<tr class="memdesc:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with four parameter.  <a href="#abac65416662f68d208674270c4fc2a95">More...</a><br /></td></tr>
<tr class="separator:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a72636f3f379105f9b98eb4644464c96c">Call5</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5)</td></tr>
<tr class="memdesc:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with five parameter.  <a href="#a72636f3f379105f9b98eb4644464c96c">More...</a><br /></td></tr>
<tr class="separator:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3634a9b8b7927122ec3b7e9f08f15be9">Call6</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p6)</td></tr>
<tr class="memdesc:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with six parameter.  <a href="#a3634a9b8b7927122ec3b7e9f08f15be9">More...</a><br /></td></tr>
<tr class="separator:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae7a3f18267d3af7513242e7247c8c40e">CallV</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">MVariant::VariantVector</a> &amp;params)</td></tr>
<tr class="memdesc:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant vector.  <a href="#ae7a3f18267d3af7513242e7247c8c40e">More...</a><br /></td></tr>
<tr class="separator:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99063368f3e5fb4189bcbd13339e47c0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a99063368f3e5fb4189bcbd13339e47c0">IsPropertyPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the property with the given name exists. <br /></td></tr>
<tr class="separator:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d10a068500c82809fcb6d97ea9611da"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a6d10a068500c82809fcb6d97ea9611da">IsServicePresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the service with the given name exists. <br /></td></tr>
<tr class="separator:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a0e84b79fc7c435e2b338f0f9a6239b45">GetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property value using name of the property.  <a href="#a0e84b79fc7c435e2b338f0f9a6239b45">More...</a><br /></td></tr>
<tr class="separator:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a4c04b41d6114e57b12447bd0e07e6af5">SetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="memdesc:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property using name of the property, and value.  <a href="#a4c04b41d6114e57b12447bd0e07e6af5">More...</a><br /></td></tr>
<tr class="separator:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae06fd77bef7ab1a46e21d61d78ecefc inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#aae06fd77bef7ab1a46e21d61d78ecefc">GetAllPropertyNames</a> () const </td></tr>
<tr class="memdesc:aae06fd77bef7ab1a46e21d61d78ecefc inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available properties, persistent or not.  <a href="#aae06fd77bef7ab1a46e21d61d78ecefc">More...</a><br /></td></tr>
<tr class="separator:aae06fd77bef7ab1a46e21d61d78ecefc inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef2d99c0ba3da5e94e9a150fe901a87 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#afef2d99c0ba3da5e94e9a150fe901a87">GetAllPersistentPropertyNames</a> () const </td></tr>
<tr class="memdesc:afef2d99c0ba3da5e94e9a150fe901a87 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of persistent properties.  <a href="#afef2d99c0ba3da5e94e9a150fe901a87">More...</a><br /></td></tr>
<tr class="separator:afef2d99c0ba3da5e94e9a150fe901a87 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a65eb2f14c14157a7aeead3d68550092f">SetPersistentPropertiesToDefault</a> ()</td></tr>
<tr class="memdesc:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties of the object to their default values.  <a href="#a65eb2f14c14157a7aeead3d68550092f">More...</a><br /></td></tr>
<tr class="separator:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a14384d8101f49cb7616bddd06fe6ecbd">GetPersistentPropertyDefaultValue</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default value of persistent property with the name given.  <a href="#a14384d8101f49cb7616bddd06fe6ecbd">More...</a><br /></td></tr>
<tr class="separator:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a76f62e685cf1f638da5aef8c41ca8586">SetPersistentPropertyToDefault</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent property with the name given to default value.  <a href="#a76f62e685cf1f638da5aef8c41ca8586">More...</a><br /></td></tr>
<tr class="separator:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03324a7bc9b626fe2860beb4b84b6bcc"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a03324a7bc9b626fe2860beb4b84b6bcc">GetType</a> () const </td></tr>
<tr class="memdesc:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the type for the object (could be the same as class name). <br /></td></tr>
<tr class="separator:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a164dbf0ffa4e8c65b9ceffbf1d6fb391">SetType</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;)</td></tr>
<tr class="memdesc:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally, it will set the name of the type for the object, but the service will not allow setting the name to anything other than the current name.  <a href="#a164dbf0ffa4e8c65b9ceffbf1d6fb391">More...</a><br /></td></tr>
<tr class="separator:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#af929f6afc9295557a8c5ead74c6c0b6a">Validate</a> ()</td></tr>
<tr class="memdesc:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate internal structures of the object.  <a href="#af929f6afc9295557a8c5ead74c6c0b6a">More...</a><br /></td></tr>
<tr class="separator:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a62d6a2d126e2f088a52161bcc5d522a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a62d6a2d126e2f088a52161bcc5d522a7">CheckKeySizeValid</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;key)</td></tr>
<tr class="memdesc:a62d6a2d126e2f088a52161bcc5d522a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the byte size of a given binary key is exactly 16 bytes.  <a href="#a62d6a2d126e2f088a52161bcc5d522a7">More...</a><br /></td></tr>
<tr class="separator:a62d6a2d126e2f088a52161bcc5d522a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b2270f9ed65e73723892e65860f996"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#af2b2270f9ed65e73723892e65860f996">CheckHexKeySizeValid</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;key)</td></tr>
<tr class="memdesc:af2b2270f9ed65e73723892e65860f996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify HEX representation and byte size of a given HEX key.  <a href="#af2b2270f9ed65e73723892e65860f996">More...</a><br /></td></tr>
<tr class="separator:af2b2270f9ed65e73723892e65860f996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf1537511c8582230d210ebbc040f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a13bf1537511c8582230d210ebbc040f5">StaticEncrypt</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;key, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;plainText)</td></tr>
<tr class="memdesc:a13bf1537511c8582230d210ebbc040f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of Encrypt that accepts key as parameter.  <a href="#a13bf1537511c8582230d210ebbc040f5">More...</a><br /></td></tr>
<tr class="separator:a13bf1537511c8582230d210ebbc040f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9bb1931b8789ef0f81deb2cd26f362"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#add9bb1931b8789ef0f81deb2cd26f362">StaticDecrypt</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;key, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;cipherText)</td></tr>
<tr class="memdesc:add9bb1931b8789ef0f81deb2cd26f362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of Decrypt that accepts key as parameter.  <a href="#add9bb1931b8789ef0f81deb2cd26f362">More...</a><br /></td></tr>
<tr class="separator:add9bb1931b8789ef0f81deb2cd26f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cdf0bdf51bda0bec434ebe8f7172fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a55cdf0bdf51bda0bec434ebe8f7172fa">StaticKeyWrap</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;key, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;keys)</td></tr>
<tr class="memdesc:a55cdf0bdf51bda0bec434ebe8f7172fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static variant of KeyWrap.  <a href="#a55cdf0bdf51bda0bec434ebe8f7172fa">More...</a><br /></td></tr>
<tr class="separator:a55cdf0bdf51bda0bec434ebe8f7172fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac074af848f4f36387816a17f4136b746"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ac074af848f4f36387816a17f4136b746">StaticKeyUnwrap</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;key, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;cipher)</td></tr>
<tr class="memdesc:ac074af848f4f36387816a17f4136b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static variant of KeyUnwrap.  <a href="#ac074af848f4f36387816a17f4136b746">More...</a><br /></td></tr>
<tr class="separator:ac074af848f4f36387816a17f4136b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec39af5aee78559108163e08c569ae0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___m_c_o_r_e.html#gafa5db05369b35075474e232a5cb2fbae">M_NORETURN_FUNC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#afec39af5aee78559108163e08c569ae0">ThrowValidationError</a> ()</td></tr>
<tr class="memdesc:afec39af5aee78559108163e08c569ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error that tells about a validation problem in the encrypted or authenticated message.  <a href="#afec39af5aee78559108163e08c569ae0">More...</a><br /></td></tr>
<tr class="separator:afec39af5aee78559108163e08c569ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8bd3f045399a3d28ffb94c0200619d57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a8bd3f045399a3d28ffb94c0200619d57">DestroySecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="separator:a8bd3f045399a3d28ffb94c0200619d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f27d6d250a3e74be2bc6e65b56ac979"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a7f27d6d250a3e74be2bc6e65b56ac979">DestroySecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;data)</td></tr>
<tr class="separator:a7f27d6d250a3e74be2bc6e65b56ac979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab208d6c6bd1a1dce05d2354dbfb11a75"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ab208d6c6bd1a1dce05d2354dbfb11a75">DestroySecureData</a> (Muint8 *data, unsigned size)</td></tr>
<tr class="separator:ab208d6c6bd1a1dce05d2354dbfb11a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6021ec9cd5bc04986c4b5b947861662"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ab6021ec9cd5bc04986c4b5b947861662">DestroySecureData</a> (char *data, unsigned size)</td></tr>
<tr class="separator:ab6021ec9cd5bc04986c4b5b947861662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5eb29be0fd94ed4c854fde0842f04f14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a5eb29be0fd94ed4c854fde0842f04f14">AssignSecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;destination, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;source)</td></tr>
<tr class="separator:a5eb29be0fd94ed4c854fde0842f04f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f1bee0cf6969e76f3318061bf62ebb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a44f1bee0cf6969e76f3318061bf62ebb">AssignSecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;destination, const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;source)</td></tr>
<tr class="separator:a44f1bee0cf6969e76f3318061bf62ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9535e8f7b65981da3c512c4262ba7a36"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a9535e8f7b65981da3c512c4262ba7a36">MoveSecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;destination, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;source)</td></tr>
<tr class="separator:a9535e8f7b65981da3c512c4262ba7a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5b5aa959507653b8568cf9017d0bbc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a8f5b5aa959507653b8568cf9017d0bbc">MoveSecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;destination, <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;source)</td></tr>
<tr class="separator:a8f5b5aa959507653b8568cf9017d0bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ddd1f48e84493923fa7a34cfcd555ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#a9ddd1f48e84493923fa7a34cfcd555ac">SwapSecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;v1, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;v2)</td></tr>
<tr class="separator:a9ddd1f48e84493923fa7a34cfcd555ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac120330a17980e91226053094b7a9f7b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_aes.html#ac120330a17980e91226053094b7a9f7b">SwapSecureData</a> (<a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;v1, <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;v2)</td></tr>
<tr class="separator:ac120330a17980e91226053094b7a9f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#aeba892081e500e981d22a2c54b6a0100">GetStaticClass</a> ()</td></tr>
<tr class="memdesc:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the declared class of this particular object.  <a href="#aeba892081e500e981d22a2c54b6a0100">More...</a><br /></td></tr>
<tr class="separator:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a89f92d51d036637db84d57290616e98b">IsClassPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given class name is available.  <a href="#a89f92d51d036637db84d57290616e98b">More...</a><br /></td></tr>
<tr class="separator:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae930847fb891a40c903b0e5c0ac5bcf0"></a>
static const <a class="el" href="class_m_class.html">MClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae930847fb891a40c903b0e5c0ac5bcf0">s_class</a></td></tr>
<tr class="memdesc:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>. <br /></td></tr>
<tr class="separator:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fd4059be176487607315d88d715a97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a48fd4059be176487607315d88d715a97">MObject</a> ()</td></tr>
<tr class="memdesc:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a9160d5a51f8d3b85ace23e83f967f269">DoSetPersistentPropertiesToDefault</a> (const <a class="el" href="class_m_class.html">MClass</a> *staticClass)</td></tr>
<tr class="memdesc:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties to their default values for one object provided the class for that object.  <a href="#a9160d5a51f8d3b85ace23e83f967f269">More...</a><br /></td></tr>
<tr class="separator:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AES encryption and decryption class. </p>
<p>Currently only 128-bit AES key is supported, but the interface is generic to support other sizes. Different from all the other MeteringSDK classes that accept AES key as a sequence of hexadecimal characters, this class is primarily using the key as a raw byte string exactly 16 bytes long. There is a special extra property <a class="el" href="class_m_aes.html#a677384cc592b33b55a61d84c28671ee9">GetHexKey</a> that does the necessary conversion.</p>
<p>This class implements the simplest possible ECB mode, in which every chunk of 16 bytes gets parameterless translation into cipher using key. ECB mode has known security issues as the 16-byte chunks of data with the same contents will produce the very same 16-byte chunks of cipher. This fact presents to an attacker the unwanted knowledge about the contents of plain text. ECB mode is still usable for cases when the data to encrypt has a good entropy, and never repeats, such as cryptographic hash or a key itself.</p>
<p>For EAX mode refer to <a class="el" href="class_m_aes_eax.html">MAesEax</a> There is also EAX-mode authentication.</p>
<p>Only one thread shall access this object at a time, however since encryption and decryption are long operations, it is a better design to have a per-thread instance of <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a>. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a6bcd360ed1419453c0724e31814e4c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6bcd360ed1419453c0724e31814e4c9fa57b0460543f3b45f47af4d436c382e71"></a>KeySize&#160;</td><td class="fielddoc">
<p>Supported binary key size in bytes of this AES algorithm. </p>
<p>Currently this is only 16 bytes, which corresponds to 128-bit AES. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6bcd360ed1419453c0724e31814e4c9fa565fc72a09011051c38a851bb9f76b03"></a>BlockSize&#160;</td><td class="fielddoc">
<p>AES encryption block size. </p>
<p>This is 16 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6bcd360ed1419453c0724e31814e4c9fa1df239630a7f10f934856df2da1195c2"></a>KeyWrapEncryptionExtraSize&#160;</td><td class="fielddoc">
<p>Extra size added to key material at wrapping. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6bcd360ed1419453c0724e31814e4c9fa6c2ef1f869bf3363cf8f62a3b4f86b81"></a>KeyWrapMinimumSize&#160;</td><td class="fielddoc">
<p>Maximum size of key material for key wrap. </p>
<p>The result encrypted key material will be KeyWrapMinimumSize + KeyWrapEncryptionExtraSize. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6bcd360ed1419453c0724e31814e4c9fa4e283d6439b594fb91b6bad9b216fc68"></a>KeyWrapMaximumSize&#160;</td><td class="fielddoc">
<p>Maximum size of key material for key wrap. </p>
<p>The result encrypted key material will be KeyWrapMaximumSize + KeyWrapEncryptionExtraSize. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6080c7085120424347e135294f464401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MAes::MAes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create AES encryption class without setting the key. </p>
<p>Any attempt to use this class prior to setting the key will fail with an exception. </p>

</div>
</div>
<a class="anchor" id="a8df21a53ff189da2857ba0b0516fc359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MAes::MAes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create AES encryption class with key, given as raw 16 bytes. </p>
<p>After successful initialization, assuming the key has correct size, the result object can be used for data encryption or decryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Raw 16 bytes, key to use during encryption or decryption. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7799208a771228d9272dd88fcceea982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MAes::MAes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_aes.html">MAes</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor, creates a copy of a given object. </p>
<p>The key gets copied, if the other object has it set. If the other object does not have key, the result <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> object will have to be assigned a key before using it for encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>An object from which to create a copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5eb29be0fd94ed4c854fde0842f04f14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::AssignSecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign one secure data such as key or password to another variable.</p>
<p>As the data size of a new buffer can be different as a safety measure the previous contents of the destination is erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Where to put the new secure material. </td></tr>
    <tr><td class="paramname">source</td><td>From which value to copy data. The source value does not change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a9535e8f7b65981da3c512c4262ba7a36">MoveSecureData(MByteString&amp; destination, MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a8f5b5aa959507653b8568cf9017d0bbc">MoveSecureData(MByteStringVector&amp; destination, MByteStringVector&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a9ddd1f48e84493923fa7a34cfcd555ac">SwapSecureData(MByteString&amp; v1, MByteString&amp; v2)</a>; </dd>
<dd>
<a class="el" href="class_m_aes.html#ac120330a17980e91226053094b7a9f7b">SwapSecureData(MByteStringVector&amp; v1, MByteStringVector&amp; v2)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44f1bee0cf6969e76f3318061bf62ebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::AssignSecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign one secure data such as key or password to another variable.</p>
<p>As the data size of a new buffer can be different as a safety measure the previous contents of the destination is erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Where to put the new secure material. </td></tr>
    <tr><td class="paramname">source</td><td>From which value to copy data. The source value does not change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a9535e8f7b65981da3c512c4262ba7a36">MoveSecureData(MByteString&amp; destination, MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a8f5b5aa959507653b8568cf9017d0bbc">MoveSecureData(MByteStringVector&amp; destination, MByteStringVector&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a9ddd1f48e84493923fa7a34cfcd555ac">SwapSecureData(MByteString&amp; v1, MByteString&amp; v2)</a>; </dd>
<dd>
<a class="el" href="class_m_aes.html#ac120330a17980e91226053094b7a9f7b">SwapSecureData(MByteStringVector&amp; v1, MByteStringVector&amp; v2)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af2b2270f9ed65e73723892e65860f996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::CheckHexKeySizeValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify HEX representation and byte size of a given HEX key. </p>
<p>For the call to succeed, the given string shall be a valid sequence of hex digits that evaluates into 16-byte raw data. Hex digits can have blanks, however no blank shall split the hex pair.</p>
<p>Examples of valid HEX key:</p><ul>
<li>"000102030405060708090A0B0C0D0E0F"</li>
<li>"0102 0304 0506 0708  090A 0B0C 0D0E 0F00"</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The hex representation of key which size is to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62d6a2d126e2f088a52161bcc5d522a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::CheckKeySizeValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify the byte size of a given binary key is exactly 16 bytes. </p>
<p>An exception is thrown if the given binary key has size other than 16 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key which size is to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1531f11441a8249fe10b813ccda856f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::Decrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>cipherText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt a given chunk of data with AES using plain and simple ECB mode. </p>
<p>ECB mode has known security issues as the 16-byte chunks of data with the same contents will produce the same 16-byte chunks of cipher. This fact presents to an attacker the unwanted knowledge about the contents of plain text. ECB mode is still usable for cases when the data to encrypt has a good entropy, and never repeats, such as cryptographic hash.</p>
<p>For cases other than encrypting random or pseudorandom data, EAX mode of AES is preferred, see class <a class="el" href="class_m_aes_eax.html">MAesEax</a>. This mode is also capable of handling data of sizes not divisible by 16.</p>
<p>When decryption is to be done once for a given key, <a class="el" href="class_m_aes.html#add9bb1931b8789ef0f81deb2cd26f362">StaticDecrypt()</a> call is more convenient, but when key has to be reused for decryption of many chunks, using <a class="el" href="class_m_aes.html#ae1531f11441a8249fe10b813ccda856f" title="Decrypt a given chunk of data with AES using plain and simple ECB mode. ">MAes::Decrypt()</a> yields better performance when it reuses the same <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> instance. This is because there is a key expansion algorithm that is performed per single key assignment.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Key shall be set to <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> instance, or an exception is thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipherText</td><td>Raw bytes of size divisible by 16. If the size is not divisible by 16, an exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MByteString - result plain text, same size as cipherText.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a0dd76af78e403dad5bd1b4d436f997fb" title="Encrypt a given chunk of data with AES using plain and simple ECB mode. ">Encrypt</a> - how to encrypt the data using ECB mode. </dd>
<dd>
<a class="el" href="class_m_aes.html#add9bb1931b8789ef0f81deb2cd26f362" title="Static version of Decrypt that accepts key as parameter. ">StaticDecrypt</a> - static version, method of a class that gets key as parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbd071915c5d54ff39a40b53a16b10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MAes::DecryptBuffer </td>
          <td>(</td>
          <td class="paramtype">const Muint8 *&#160;</td>
          <td class="paramname"><em>cipherText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Muint8 *&#160;</td>
          <td class="paramname"><em>plainText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrypt buffer of size equal to block size</p>
<p>Cipher text and plain text can be the same buffer in which case the plain text will be decrypted in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipherText</td><td>Buffer of size 16 bytes, previously encrypted with this key. </td></tr>
    <tr><td class="paramname">plainText</td><td>Result buffer of size 16 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bf084c56c5fa4a340cea196262eafa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MAes::DecryptBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cipherText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>plainText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrypt buffer of size equal to block size</p>
<p>Cipher text and plain text can be the same buffer in which case the plain text will be decrypted in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipherText</td><td>Buffer of size 16 bytes, previously encrypted with this key. </td></tr>
    <tr><td class="paramname">plainText</td><td>Result buffer of size 16 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bd3f045399a3d28ffb94c0200619d57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::DestroySecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy secure data such as key, password and so on.</p>
<p>The memory area denoted by the data will be filled with zeros. Only the data are erased, while the array sizes are unchanged. </p>

</div>
</div>
<a class="anchor" id="a7f27d6d250a3e74be2bc6e65b56ac979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::DestroySecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy secure data such as key, password and so on.</p>
<p>The memory area denoted by the data will be filled with zeros. Only the data are erased, while the array sizes are unchanged. </p>

</div>
</div>
<a class="anchor" id="ab208d6c6bd1a1dce05d2354dbfb11a75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::DestroySecureData </td>
          <td>(</td>
          <td class="paramtype">Muint8 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy secure data such as key, password and so on.</p>
<p>The memory area denoted by the data will be filled with zeros. Only the data are erased, while the array sizes are unchanged. </p>

</div>
</div>
<a class="anchor" id="ab6021ec9cd5bc04986c4b5b947861662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::DestroySecureData </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy secure data such as key, password and so on.</p>
<p>The memory area denoted by the data will be filled with zeros. Only the data are erased, while the array sizes are unchanged. </p>

</div>
</div>
<a class="anchor" id="a0dd76af78e403dad5bd1b4d436f997fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::Encrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>plainText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt a given chunk of data with AES using plain and simple ECB mode. </p>
<p>ECB mode has known security issues as the 16-byte chunks of data with the same contents will produce the same 16-byte chunks of cipher. This fact presents to an attacker the unwanted knowledge about the contents of plain text. ECB mode is still usable for cases when the data to encrypt has a good entropy, and never repeats, such as cryptographic hash.</p>
<p>For cases other than encrypting random or pseudorandom data, EAX mode of AES is preferred, see class <a class="el" href="class_m_aes_eax.html">MAesEax</a>. This mode is also capable of handling data of sizes not divisible by 16.</p>
<p>When decryption is to be done once for a given key, <a class="el" href="class_m_aes.html#add9bb1931b8789ef0f81deb2cd26f362">StaticDecrypt()</a> call is more convenient, but when key has to be reused for decryption of many chunks, using <a class="el" href="class_m_aes.html#ae1531f11441a8249fe10b813ccda856f" title="Decrypt a given chunk of data with AES using plain and simple ECB mode. ">MAes::Decrypt()</a> yields better performance when it reuses the same <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> instance. This is because there is a key expansion algorithm that is performed per single key assignment.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Key shall be set to <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> instance, or an exception is thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plainText</td><td>Raw bytes of size divisible by 16. If the size is not divisible by 16, an exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MByteString - result cipher text, same size as plainText.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ae1531f11441a8249fe10b813ccda856f" title="Decrypt a given chunk of data with AES using plain and simple ECB mode. ">Decrypt</a> - decrypting the data encrypted by this method. </dd>
<dd>
<a class="el" href="class_m_aes.html#a13bf1537511c8582230d210ebbc040f5" title="Static version of Encrypt that accepts key as parameter. ">StaticEncrypt</a> - static version, method of a class that gets key as parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a56a91e87be48f615c939fc88d8780b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MAes::EncryptBuffer </td>
          <td>(</td>
          <td class="paramtype">const Muint8 *&#160;</td>
          <td class="paramname"><em>plainText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Muint8 *&#160;</td>
          <td class="paramname"><em>cipherText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encrypt buffer of size equal to block size.</p>
<p>Plain text and cipher text can be the same buffer in which case the plain text will be encrypted in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plainText</td><td>Buffer of size 16 bytes. </td></tr>
    <tr><td class="paramname">cipherText</td><td>Result buffer of size 16 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af993ff7ae16d14dfb6789573385a976f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MAes::EncryptBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>plainText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cipherText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypt buffer of size equal to block size.</p>
<p>Plain text and cipher text can be the same buffer in which case the plain text will be encrypted in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plainText</td><td>Buffer of size 16 bytes. </td></tr>
    <tr><td class="paramname">cipherText</td><td>Result buffer of size 16 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a677384cc592b33b55a61d84c28671ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MAes::GetHexKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AES Key to use by the class, hexadecimal representation.</p>
<p>The key has binary form, not hex, which is different from all the other MeteringSDK classes that accept AES key as a sequence of hexadecimal characters.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.0.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>When assigning to this property, the given key must be a proper hexadecimal string that evaluates into exactly 16 bytes in size, or an invalid size exception will be thrown. Hexadecimal string can have blanks for clarity, but such blanks must not split pairs of hexadecimal digits that represent the key.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ad3777cb0e78f463938508dec147b33c6">GetKey</a> property for handling key given as raw bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3777cb0e78f463938508dec147b33c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&amp; MAes::GetKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>AES Key to use by the class, binary representation.</p>
<p>The key has binary form, not hex, which is different from all the other MeteringSDK classes that accept AES key as a sequence of hexadecimal characters.</p>
<dl class="section pre"><dt>Precondition</dt><dd>When assigning to this property, the given key must be exactly 16 bytes in size, or an invalid size exception will be thrown.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a677384cc592b33b55a61d84c28671ee9">GetHexKey</a> property for handling key given as a sequence of hexadecimal characters. </dd></dl>

</div>
</div>
<a class="anchor" id="aa01ec1e86d1917599ccd231d98f34293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::KeyUnwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap the given cipher and produce the original key material, one or more keys. </p>
<p>The key unwrap function takes a pointer to the full encrypted data including the encrypted header.</p>
<p>The return value is true if there was no error (i.e. the prefix matches the fixed prefix that we know we started with) or false if there was an error. In the case of error, the data is overwritten with zeros to avoid leaking information which might be used to guess the key (such as a known ciphertext attack).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>Input that contains wrapped key material.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes - keys, the size is 8 bytes shorter than the given cipher.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ad9444b26f7d5e75403a8e4c40a0203a7" title="Wrap the given key material, one or more keys, using RFC 3394 key wrap algorithm. ...">KeyWrap</a> - reverse operation. </dd>
<dd>
<a class="el" href="class_m_aes.html#ac074af848f4f36387816a17f4136b746" title="Static variant of KeyUnwrap. ">StaticKeyUnwrap</a> - version that accepts key directly. </dd></dl>

</div>
</div>
<a class="anchor" id="a883df6d2086af2c29c76a11255ce0184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MAes::KeyUnwrapBuffer </td>
          <td>(</td>
          <td class="paramtype">const Muint8 *&#160;</td>
          <td class="paramname"><em>cipherText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cipherTextSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Muint8 *&#160;</td>
          <td class="paramname"><em>keyText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrypt key material with AES key wrap algorithm.</p>
<p>If the key is not correct an exception will be thrown as the verification will not be successful. Plain text and cipher text can be the same buffer in which case the plain text will be decrypted in-place. However remember the size of cipher text buffer should be bigger by 8 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipherText</td><td>Encrypted buffer with key material that has to be decrypted and verified. </td></tr>
    <tr><td class="paramname">cipherTextSize</td><td>Size of the encrypted buffer. </td></tr>
    <tr><td class="paramname">keyText</td><td>Result cipher text, the buffer should be 8 bytes bigger than keyTextSize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keyTextSize - 8 is returned, keyText buffer size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#aa01ec1e86d1917599ccd231d98f34293" title="Unwrap the given cipher and produce the original key material, one or more keys. ">KeyUnwrap</a> for complete description of functionality. </dd></dl>

</div>
</div>
<a class="anchor" id="afa96f7f8578fccf184d9dbf26da830fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MAes::KeyUnwrapBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cipherText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cipherTextSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>keyText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrypt key material with AES key wrap algorithm.</p>
<p>If the key is not correct an exception will be thrown as the verification will not be successful. Plain text and cipher text can be the same buffer in which case the plain text will be decrypted in-place. However remember the size of cipher text buffer should be bigger by 8 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipherText</td><td>Encrypted buffer with key material that has to be decrypted and verified. </td></tr>
    <tr><td class="paramname">cipherTextSize</td><td>Size of the encrypted buffer. </td></tr>
    <tr><td class="paramname">keyText</td><td>Result cipher text, the buffer should be 8 bytes bigger than keyTextSize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keyTextSize - 8 is returned, keyText buffer size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#aa01ec1e86d1917599ccd231d98f34293" title="Unwrap the given cipher and produce the original key material, one or more keys. ">KeyUnwrap</a> for complete description of functionality. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9444b26f7d5e75403a8e4c40a0203a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::KeyWrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap the given key material, one or more keys, using RFC 3394 key wrap algorithm. </p>
<p>The key wrapping algorithm is described in a NIST document dated 16 November 2001 and titled "AES Key Wrap Specification" It is later accepted as RFC 3394.</p>
<p>The algorithm, as implemented here, is intended to be able to wrap an arbitrary number of 128-byte blocks (the specification allows for 64-bit blocks, but this is a simplification).</p>
<p>Key wrap:</p><ol type="1">
<li>initialize variables A_0 = IV (0xA6A6A6...) <div class="fragment"><div class="line"><span class="keywordflow">for</span> i=1...n, R_i^0 = P_i </div></div><!-- fragment --></li>
<li>calculate intermediate values <div class="fragment"><div class="line"><span class="keywordflow">for</span> j=0...5</div><div class="line">  <span class="keywordflow">for</span> i=1...n</div><div class="line">     B = AES_K(A | R_i)</div><div class="line">     A = MSB_{64}(B) xor t, where t= (n*j)+1</div><div class="line">     R_i = LSB_{64}(B)</div></div><!-- fragment --></li>
<li>Output the results <div class="fragment"><div class="line">C_0 = A</div><div class="line"><span class="keywordflow">for</span> i=1...n</div><div class="line">  C_i = R_i</div></div><!-- fragment --></li>
</ol>
<p>Note that passed data pointer must start with 8 bytes of padding in front of the actual data, and that the data length must be an integral multiple of 8 bytes. In other words, if you have two 128-bit (16-byte) keys you need to wrap, the data pointer must point to a 24-byte buffer (16+8) with the actual data starting at offset 8. The code will then process the data in place (so it cannot be ROM) and uses the key encryption key (kek) which can be in ROM. When the algorithm completes, the entire buffer must be transmitted since the 8 prepended bytes are required to assure that the data has arrived intact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>One or more keys, should be 16 bytes or more, size divisible by 8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes - cipher, which is 8 bytes longer than the keys string given.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#aa01ec1e86d1917599ccd231d98f34293" title="Unwrap the given cipher and produce the original key material, one or more keys. ">KeyUnwrap</a> - reverse operation. </dd>
<dd>
<a class="el" href="class_m_aes.html#a55cdf0bdf51bda0bec434ebe8f7172fa" title="Static variant of KeyWrap. ">StaticKeyWrap</a> - version that accepts key directly. </dd></dl>

</div>
</div>
<a class="anchor" id="ade10b5a636ca7860ac7865bb2c92b846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MAes::KeyWrapBuffer </td>
          <td>(</td>
          <td class="paramtype">const Muint8 *&#160;</td>
          <td class="paramname"><em>keyText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>keyTextSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Muint8 *&#160;</td>
          <td class="paramname"><em>cipherText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encrypt key material with AES key wrap algorithm.</p>
<p>Cipher text and plain text can be the same buffer in which case the plain text will be decrypted in-place. However remember the size of cipher text buffer should be bigger by 8 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyText</td><td>Buffer with key material that has to be wrapped. </td></tr>
    <tr><td class="paramname">keyTextSize</td><td>Size of the buffer with key material. </td></tr>
    <tr><td class="paramname">cipherText</td><td>Result cipher text, the buffer should be 8 bytes bigger than keyTextSize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keyTextSize + 8 is returned, cipherText buffer size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ad9444b26f7d5e75403a8e4c40a0203a7" title="Wrap the given key material, one or more keys, using RFC 3394 key wrap algorithm. ...">KeyWrap</a> for complete description of functionality. </dd></dl>

</div>
</div>
<a class="anchor" id="a56d4a8b6cd0d6d4259be79d8210ad6af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MAes::KeyWrapBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>keyTextSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cipherText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypt key material with AES key wrap algorithm.</p>
<p>Cipher text and plain text can be the same buffer in which case the plain text will be decrypted in-place. However remember the size of cipher text buffer should be bigger by 8 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyText</td><td>Buffer with key material that has to be wrapped. </td></tr>
    <tr><td class="paramname">keyTextSize</td><td>Size of the buffer with key material. </td></tr>
    <tr><td class="paramname">cipherText</td><td>Result cipher text, the buffer should be 8 bytes bigger than keyTextSize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>keyTextSize + 8 is returned, cipherText buffer size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ad9444b26f7d5e75403a8e4c40a0203a7" title="Wrap the given key material, one or more keys, using RFC 3394 key wrap algorithm. ...">KeyWrap</a> for complete description of functionality. </dd></dl>

</div>
</div>
<a class="anchor" id="a9535e8f7b65981da3c512c4262ba7a36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::MoveSecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move one secure data such as key or password into another variable, destroy source value.</p>
<p>As the data size of a new buffer can be different as a safety measure the previous contents of the destination is erased. The contents of the source is destroyed after assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Where to put the new secure material. </td></tr>
    <tr><td class="paramname">source</td><td>From which value to copy data. The source value is destroyed after assignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a5eb29be0fd94ed4c854fde0842f04f14">AssignSecureData(MByteString&amp; destination, const MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a44f1bee0cf6969e76f3318061bf62ebb">AssignSecureData(MByteStringVector&amp; destination, const MByteStringVector&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a9ddd1f48e84493923fa7a34cfcd555ac">SwapSecureData(MByteString&amp; v1, MByteString&amp; v2)</a>; </dd>
<dd>
<a class="el" href="class_m_aes.html#ac120330a17980e91226053094b7a9f7b">SwapSecureData(MByteStringVector&amp; v1, MByteStringVector&amp; v2)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f5b5aa959507653b8568cf9017d0bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::MoveSecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move one secure data such as key or password into another variable, destroy source value.</p>
<p>As the data size of a new buffer can be different as a safety measure the previous contents of the destination is erased. The contents of the source is destroyed after assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Where to put the new secure material. </td></tr>
    <tr><td class="paramname">source</td><td>From which value to copy data. The source value is destroyed after assignment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a5eb29be0fd94ed4c854fde0842f04f14">AssignSecureData(MByteString&amp; destination, const MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a44f1bee0cf6969e76f3318061bf62ebb">AssignSecureData(MByteStringVector&amp; destination, const MByteStringVector&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a9ddd1f48e84493923fa7a34cfcd555ac">SwapSecureData(MByteString&amp; v1, MByteString&amp; v2)</a>; </dd>
<dd>
<a class="el" href="class_m_aes.html#ac120330a17980e91226053094b7a9f7b">SwapSecureData(MByteStringVector&amp; v1, MByteStringVector&amp; v2)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab174f5135642f6ad4ca8957b1998f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_aes.html">MAes</a>&amp; MAes::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_aes.html">MAes</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator that copies the key from another class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other object from which to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c17995c865a7491f890e99c8e0c142f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MAes::SetHexKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AES Key to use by the class, hexadecimal representation.</p>
<p>The key has binary form, not hex, which is different from all the other MeteringSDK classes that accept AES key as a sequence of hexadecimal characters.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 5.0.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>When assigning to this property, the given key must be a proper hexadecimal string that evaluates into exactly 16 bytes in size, or an invalid size exception will be thrown. Hexadecimal string can have blanks for clarity, but such blanks must not split pairs of hexadecimal digits that represent the key.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ad3777cb0e78f463938508dec147b33c6">GetKey</a> property for handling key given as raw bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a93bc9239036bc0e1ac6151ea4fe1eae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MAes::SetKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AES Key to use by the class, binary representation.</p>
<p>The key has binary form, not hex, which is different from all the other MeteringSDK classes that accept AES key as a sequence of hexadecimal characters.</p>
<dl class="section pre"><dt>Precondition</dt><dd>When assigning to this property, the given key must be exactly 16 bytes in size, or an invalid size exception will be thrown.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a677384cc592b33b55a61d84c28671ee9">GetHexKey</a> property for handling key given as a sequence of hexadecimal characters. </dd></dl>

</div>
</div>
<a class="anchor" id="add9bb1931b8789ef0f81deb2cd26f362"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::StaticDecrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>cipherText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static version of Decrypt that accepts key as parameter. </p>
<p>ECB mode has known security issues as the 16-byte chunks of data with the same contents will produce the same 16-byte chunks of cipher. This fact presents to an attacker the unwanted knowledge about the contents of plain text. ECB mode is still usable for cases when the data to encrypt has a good entropy, and never repeats, such as cryptographic hash.</p>
<p>For cases other than encrypting random or pseudorandom data, EAX mode of AES is preferred, see class <a class="el" href="class_m_aes_eax.html">MAesEax</a>. This mode is also capable of handling data of sizes not divisible by 16.</p>
<p>When encryption is to be done once for a given key, <a class="el" href="class_m_aes.html#add9bb1931b8789ef0f81deb2cd26f362">StaticDecrypt()</a> call is more convenient, but when key has to be reused for encryption of many chunks, using <a class="el" href="class_m_aes.html#ae1531f11441a8249fe10b813ccda856f" title="Decrypt a given chunk of data with AES using plain and simple ECB mode. ">MAes::Decrypt()</a> yields better performance when it reuses the same <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> instance. This is because there is a key expansion algorithm that is performed per single key assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Shall be exactly 16 bytes, binary. Notice, the difference from all other MeteringSDK classes is that Key property of <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> is binary, not a hex string.</td></tr>
    <tr><td class="paramname">cipherText</td><td>Raw bytes of size divisible by 16. If the size is not divisible by 16, an exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MByteString - result plain text, same size as cipherText.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ae1531f11441a8249fe10b813ccda856f" title="Decrypt a given chunk of data with AES using plain and simple ECB mode. ">Decrypt</a> - object version of <a class="el" href="class_m_aes.html#a13bf1537511c8582230d210ebbc040f5" title="Static version of Encrypt that accepts key as parameter. ">StaticEncrypt</a>. </dd>
<dd>
<a class="el" href="class_m_aes.html#a13bf1537511c8582230d210ebbc040f5" title="Static version of Encrypt that accepts key as parameter. ">StaticEncrypt</a> - static version, method of a class that gets key as parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a13bf1537511c8582230d210ebbc040f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::StaticEncrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>plainText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static version of Encrypt that accepts key as parameter. </p>
<p>ECB mode has known security issues as the 16-byte chunks of data with the same contents will produce the same 16-byte chunks of cipher. This fact presents to an attacker the unwanted knowledge about the contents of plain text. ECB mode is still usable for cases when the data to encrypt has a good entropy, and never repeats, such as cryptographic hash.</p>
<p>For cases other than encrypting random or pseudorandom data, EAX mode of AES is preferred, see class <a class="el" href="class_m_aes_eax.html">MAesEax</a>. This mode is also capable of handling data of sizes not divisible by 16.</p>
<p>When encryption is to be done once for a given key, <a class="el" href="class_m_aes.html#a13bf1537511c8582230d210ebbc040f5">StaticEncrypt()</a> call is more convenient, but when key has to be reused for encryption of many chunks, using <a class="el" href="class_m_aes.html#a0dd76af78e403dad5bd1b4d436f997fb" title="Encrypt a given chunk of data with AES using plain and simple ECB mode. ">MAes::Encrypt()</a> yields better performance when it reuses the same <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> instance. This is because there is a key expansion algorithm that is performed per single key assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Shall be exactly 16 bytes, binary. Notice, the difference from all other MeteringSDK classes is that Key property of <a class="el" href="class_m_aes.html" title="AES encryption and decryption class. ">MAes</a> is binary, not a hex string.</td></tr>
    <tr><td class="paramname">plainText</td><td>Raw bytes of size divisible by 16. If the size is not divisible by 16, an exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MByteString - result cipher text, same size as plainText.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a0dd76af78e403dad5bd1b4d436f997fb" title="Encrypt a given chunk of data with AES using plain and simple ECB mode. ">Encrypt</a> - object version of <a class="el" href="class_m_aes.html#a13bf1537511c8582230d210ebbc040f5" title="Static version of Encrypt that accepts key as parameter. ">StaticEncrypt</a>. </dd>
<dd>
<a class="el" href="class_m_aes.html#add9bb1931b8789ef0f81deb2cd26f362" title="Static version of Decrypt that accepts key as parameter. ">StaticDecrypt</a> - static version, method of a class that gets key as parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ac074af848f4f36387816a17f4136b746"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::StaticKeyUnwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>cipher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static variant of KeyUnwrap. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#aa01ec1e86d1917599ccd231d98f34293" title="Unwrap the given cipher and produce the original key material, one or more keys. ">KeyUnwrap</a> - object version that accepts key as property. </dd>
<dd>
<a class="el" href="class_m_aes.html#a55cdf0bdf51bda0bec434ebe8f7172fa" title="Static variant of KeyWrap. ">StaticKeyWrap</a> - reverse static operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Encryption key to use in key unwrap, should be the same as the one in the wrap call.</td></tr>
    <tr><td class="paramname">cipher</td><td>Cipher text as produced by keys wrap call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes - byte string of keys, which is 8 bytes shorter than the cipher given. </dd></dl>

</div>
</div>
<a class="anchor" id="a55cdf0bdf51bda0bec434ebe8f7172fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MAes::StaticKeyWrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static variant of KeyWrap. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#ad9444b26f7d5e75403a8e4c40a0203a7" title="Wrap the given key material, one or more keys, using RFC 3394 key wrap algorithm. ...">KeyWrap</a> - object version that accepts key as property. </dd>
<dd>
<a class="el" href="class_m_aes.html#ac074af848f4f36387816a17f4136b746" title="Static variant of KeyUnwrap. ">StaticKeyUnwrap</a> - reverse static operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Encryption key to use in key wrap, should be the same as the one in the unwrap call.</td></tr>
    <tr><td class="paramname">keys</td><td>One or more 16-byte keys to wrap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes - cipher, which is 8 bytes longer than the keys string given. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ddd1f48e84493923fa7a34cfcd555ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::SwapSecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap secure data such as key or password with another data.</p>
<p>As the data sizes of these can be different, the data gets erased to make sure nothing stays in memory after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Data to be swapped with v2. </td></tr>
    <tr><td class="paramname">v2</td><td>Data to be swapped with v1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a5eb29be0fd94ed4c854fde0842f04f14">AssignSecureData(MByteString&amp; destination, const MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a44f1bee0cf6969e76f3318061bf62ebb">AssignSecureData(MByteStringVector&amp; destination, const MByteStringVector&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a9535e8f7b65981da3c512c4262ba7a36">MoveSecureData(MByteString&amp; destination, MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a8f5b5aa959507653b8568cf9017d0bbc">MoveSecureData(MByteStringVector&amp; destination, MByteStringVector&amp; source)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac120330a17980e91226053094b7a9f7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MAes::SwapSecureData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap secure data such as key or password with another data.</p>
<p>As the data sizes of these can be different, the data gets erased to make sure nothing stays in memory after the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Data to be swapped with v2. </td></tr>
    <tr><td class="paramname">v2</td><td>Data to be swapped with v1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_aes.html#a5eb29be0fd94ed4c854fde0842f04f14">AssignSecureData(MByteString&amp; destination, const MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a44f1bee0cf6969e76f3318061bf62ebb">AssignSecureData(MByteStringVector&amp; destination, const MByteStringVector&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a9535e8f7b65981da3c512c4262ba7a36">MoveSecureData(MByteString&amp; destination, MByteString&amp; source)</a> </dd>
<dd>
<a class="el" href="class_m_aes.html#a8f5b5aa959507653b8568cf9017d0bbc">MoveSecureData(MByteStringVector&amp; destination, MByteStringVector&amp; source)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afec39af5aee78559108163e08c569ae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___m_c_o_r_e.html#gafa5db05369b35075474e232a5cb2fbae">M_NORETURN_FUNC</a> void MAes::ThrowValidationError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an error that tells about a validation problem in the encrypted or authenticated message. </p>
<p>Validation is supported in EAX mode of AES, as supported by child class <a class="el" href="class_m_aes_eax.html">MAesEax</a>, and by key unwrap procedures. The user might decide to throw this error if there is a separate way of validating the encrypted buffer, such as MD5 checksum.</p>
<p>The message thrown mentions that the problem can result from tampering. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_aes.html">MAes</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
