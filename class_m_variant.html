<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MVariant Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_variant.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_m_variant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MVariant Class Reference<div class="ingroups"><a class="el" href="group___m_c_o_r_e.html">MCORE</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Variant data type, where the particular value type is dynamically determined at runtime.  
 <a href="class_m_variant.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant_1_1_object_by_value.html">ObjectByValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local placeholder class, used for passing small objects by value.  <a href="class_m_variant_1_1_object_by_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant_1_1_pointer_bytes_type.html">PointerBytesType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hidden type of pointer size.  <a href="class_m_variant_1_1_pointer_bytes_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8756bf657736cb48a0e46012354172fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">Type</a> { <br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba3155ed3e3de66143efd2f31fe1bb00c7">VAR_EMPTY</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba8bc00b670a68d47750b994b6a9781eab">VAR_BOOL</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba74ba28367c7f304ead25ea8c3abb0e1f">VAR_BYTE</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fbafc0efef59e124f99353c8c2b741ccc93">VAR_CHAR</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fbae105635606f4ad9cd5c021b874352c6f">VAR_UINT</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fbae996a7ccdb59d1df196bda97683315c0">VAR_INT</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba053cdbd4c8d0876bd861d9518a576b02">VAR_DOUBLE</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba8ad6ed215c522ff8a7fd91df3cddeb94">VAR_BYTE_STRING</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fbaae5e54d615520fad1d1504c87a1bc27d">VAR_STRING</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba93ad8e71f79e6f827053bd4033cb3a14">VAR_STRING_COLLECTION</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba7b28d181de01f302ea11c922a58fd862">VAR_OBJECT</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba3c99a1bdf4bbcdaa793c9ea40907481e">VAR_OBJECT_EMBEDDED</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fbab7e417ad36403c6d8f73379ee9fb8a2f">VAR_VARIANT_COLLECTION</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fba87ba3709865371ba4f8f0ea3c9f7976d">VAR_MAP</a>, 
<br />
&#160;&#160;<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fbae2fbb184f69387f36806ce51db7734f9">VAR_VARIANT</a>
<br />
 }<tr class="memdesc:a8756bf657736cb48a0e46012354172fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible value types, sorted in the order of their promotional conversion.  <a href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8756bf657736cb48a0e46012354172fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaae155d0949b43a16647cbb24179759"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaae155d0949b43a16647cbb24179759"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aaaae155d0949b43a16647cbb24179759">AcceptByteStringType</a> { <b>ACCEPT_BYTE_STRING</b>
 }<tr class="memdesc:aaaae155d0949b43a16647cbb24179759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that allows telling byte string constructor from the standard string constructor. <br /></td></tr>
</td></tr>
<tr class="separator:aaaae155d0949b43a16647cbb24179759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553204ca98f00d04c8f3dca3caca432c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a553204ca98f00d04c8f3dca3caca432c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a553204ca98f00d04c8f3dca3caca432c">AcceptByteStringCollectionType</a> { <b>ACCEPT_BYTE_STRING_COLLECTION</b>
 }<tr class="memdesc:a553204ca98f00d04c8f3dca3caca432c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that allows telling byte string constructor from the standard string constructor. <br /></td></tr>
</td></tr>
<tr class="separator:a553204ca98f00d04c8f3dca3caca432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a51a803ca6662b3784ea1623d634d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a51a803ca6662b3784ea1623d634d7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a66a51a803ca6662b3784ea1623d634d7">AcceptStringType</a> { <b>ACCEPT_STRING</b>
 }<tr class="memdesc:a66a51a803ca6662b3784ea1623d634d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that allows telling string constructor from the byte string constructor. <br /></td></tr>
</td></tr>
<tr class="separator:a66a51a803ca6662b3784ea1623d634d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8cadf5ff38042e6ada9c9889fbfc66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8cadf5ff38042e6ada9c9889fbfc66"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a2d8cadf5ff38042e6ada9c9889fbfc66">AcceptObjectEmbedded</a> { <b>ACCEPT_OBJECT_EMBEDDED</b>
 }<tr class="memdesc:a2d8cadf5ff38042e6ada9c9889fbfc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that allows telling an embedded object from an ordinary object. <br /></td></tr>
</td></tr>
<tr class="separator:a2d8cadf5ff38042e6ada9c9889fbfc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98faca84b5c7da406105995fedbe1c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac98faca84b5c7da406105995fedbe1c3"></a>
typedef std::vector&lt; <a class="el" href="class_m_variant.html">MVariant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">VariantVector</a></td></tr>
<tr class="memdesc:ac98faca84b5c7da406105995fedbe1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Externally visible collection of variants. <br /></td></tr>
<tr class="separator:ac98faca84b5c7da406105995fedbe1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a187d38abd85255cc6cd8a4188912c952"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a187d38abd85255cc6cd8a4188912c952"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a187d38abd85255cc6cd8a4188912c952">MVariant</a> ()</td></tr>
<tr class="memdesc:a187d38abd85255cc6cd8a4188912c952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default object constructor. <br /></td></tr>
<tr class="separator:a187d38abd85255cc6cd8a4188912c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4ce7529a50973e1c4b0f4cc4cd0f31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4ce7529a50973e1c4b0f4cc4cd0f31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a9a4ce7529a50973e1c4b0f4cc4cd0f31">MVariant</a> (<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">Type</a> type)</td></tr>
<tr class="memdesc:a9a4ce7529a50973e1c4b0f4cc4cd0f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor that creates an empty object of a given type. <br /></td></tr>
<tr class="separator:a9a4ce7529a50973e1c4b0f4cc4cd0f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b1029a5b207a393d7f3bf488bbbbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf6b1029a5b207a393d7f3bf488bbbbc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#adf6b1029a5b207a393d7f3bf488bbbbc">MVariant</a> (bool n)</td></tr>
<tr class="memdesc:adf6b1029a5b207a393d7f3bf488bbbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type bool with the value specified. <br /></td></tr>
<tr class="separator:adf6b1029a5b207a393d7f3bf488bbbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed1b27797ef86fdbfbd0662730501fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abed1b27797ef86fdbfbd0662730501fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#abed1b27797ef86fdbfbd0662730501fa">MVariant</a> (char c)</td></tr>
<tr class="memdesc:abed1b27797ef86fdbfbd0662730501fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type char with the value specified. <br /></td></tr>
<tr class="separator:abed1b27797ef86fdbfbd0662730501fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf429abd3737d983d74ea9317edc9883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf429abd3737d983d74ea9317edc9883"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#adf429abd3737d983d74ea9317edc9883">MVariant</a> (wchar_t c)</td></tr>
<tr class="memdesc:adf429abd3737d983d74ea9317edc9883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type char with the value specified. <br /></td></tr>
<tr class="separator:adf429abd3737d983d74ea9317edc9883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384b5dd93d7c5ce9a7dc06c4f8f66302"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384b5dd93d7c5ce9a7dc06c4f8f66302"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a384b5dd93d7c5ce9a7dc06c4f8f66302">MVariant</a> (Muint8 b)</td></tr>
<tr class="memdesc:a384b5dd93d7c5ce9a7dc06c4f8f66302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type Muint8 with the value specified. <br /></td></tr>
<tr class="separator:a384b5dd93d7c5ce9a7dc06c4f8f66302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53282929764dc82c3d026fb6ca2d6c03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53282929764dc82c3d026fb6ca2d6c03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a53282929764dc82c3d026fb6ca2d6c03">MVariant</a> (int n)</td></tr>
<tr class="memdesc:a53282929764dc82c3d026fb6ca2d6c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type int with the value specified. <br /></td></tr>
<tr class="separator:a53282929764dc82c3d026fb6ca2d6c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab272022e593f89955cf8f0cdd54ad9c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab272022e593f89955cf8f0cdd54ad9c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ab272022e593f89955cf8f0cdd54ad9c4">MVariant</a> (unsigned n)</td></tr>
<tr class="memdesc:ab272022e593f89955cf8f0cdd54ad9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type unsigned int with the value specified. <br /></td></tr>
<tr class="separator:ab272022e593f89955cf8f0cdd54ad9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b841d0191ebb088ec56ececa264a709"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b841d0191ebb088ec56ececa264a709"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1b841d0191ebb088ec56ececa264a709">MVariant</a> (long n)</td></tr>
<tr class="memdesc:a1b841d0191ebb088ec56ececa264a709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type long with the value specified. <br /></td></tr>
<tr class="separator:a1b841d0191ebb088ec56ececa264a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab41b9c0c2c8f8a3779570630bc4e46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abab41b9c0c2c8f8a3779570630bc4e46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#abab41b9c0c2c8f8a3779570630bc4e46">MVariant</a> (unsigned long n)</td></tr>
<tr class="memdesc:abab41b9c0c2c8f8a3779570630bc4e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type unsigned long with the value specified. <br /></td></tr>
<tr class="separator:abab41b9c0c2c8f8a3779570630bc4e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffd85f4d16b6602ac3ddaed83241f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2ffd85f4d16b6602ac3ddaed83241f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aa2ffd85f4d16b6602ac3ddaed83241f2">MVariant</a> (Mint64 n)</td></tr>
<tr class="memdesc:aa2ffd85f4d16b6602ac3ddaed83241f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value from 64-bit signed integer. <br /></td></tr>
<tr class="separator:aa2ffd85f4d16b6602ac3ddaed83241f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7a1ab540930352874826880fb730cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a7a1ab540930352874826880fb730cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a7a7a1ab540930352874826880fb730cc">MVariant</a> (Muint64 n)</td></tr>
<tr class="memdesc:a7a7a1ab540930352874826880fb730cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value from 64-bit signed integer. <br /></td></tr>
<tr class="separator:a7a7a1ab540930352874826880fb730cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00793d25cc625e4bfa86788e9c5007f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac00793d25cc625e4bfa86788e9c5007f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ac00793d25cc625e4bfa86788e9c5007f">MVariant</a> (double n)</td></tr>
<tr class="memdesc:ac00793d25cc625e4bfa86788e9c5007f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type double with the value specified. <br /></td></tr>
<tr class="separator:ac00793d25cc625e4bfa86788e9c5007f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06afd34bdacca7941719bbd137ff4cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aa06afd34bdacca7941719bbd137ff4cc">MVariant</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;s)</td></tr>
<tr class="memdesc:aa06afd34bdacca7941719bbd137ff4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type string with the value specified as MStdString.  <a href="#aa06afd34bdacca7941719bbd137ff4cc">More...</a><br /></td></tr>
<tr class="separator:aa06afd34bdacca7941719bbd137ff4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918c4b673564ed2c3311ec9824b6b54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af918c4b673564ed2c3311ec9824b6b54">MVariant</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;s, <a class="el" href="class_m_variant.html#aaaae155d0949b43a16647cbb24179759">AcceptByteStringType</a>)</td></tr>
<tr class="memdesc:af918c4b673564ed2c3311ec9824b6b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type byte string, giving the byte string as first parameter.  <a href="#af918c4b673564ed2c3311ec9824b6b54">More...</a><br /></td></tr>
<tr class="separator:af918c4b673564ed2c3311ec9824b6b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4d24640cf80103c9f7d42e8906cfa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a0c4d24640cf80103c9f7d42e8906cfa6">MVariant</a> (const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;v, <a class="el" href="class_m_variant.html#a553204ca98f00d04c8f3dca3caca432c">AcceptByteStringCollectionType</a>)</td></tr>
<tr class="memdesc:a0c4d24640cf80103c9f7d42e8906cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type byte string vector, giving the byte string vector as first parameter.  <a href="#a0c4d24640cf80103c9f7d42e8906cfa6">More...</a><br /></td></tr>
<tr class="separator:a0c4d24640cf80103c9f7d42e8906cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247e5f696fcb2b47677b8417277e08a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a247e5f696fcb2b47677b8417277e08a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a247e5f696fcb2b47677b8417277e08a9">MVariant</a> (const <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a> &amp;v)</td></tr>
<tr class="memdesc:a247e5f696fcb2b47677b8417277e08a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type string collection with the value specified as parameter. <br /></td></tr>
<tr class="separator:a247e5f696fcb2b47677b8417277e08a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61a6eb6577b78f0c200f8118d54e4d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae61a6eb6577b78f0c200f8118d54e4d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ae61a6eb6577b78f0c200f8118d54e4d7">MVariant</a> (const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">VariantVector</a> &amp;v)</td></tr>
<tr class="memdesc:ae61a6eb6577b78f0c200f8118d54e4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type variant collection with the value specified as parameter. <br /></td></tr>
<tr class="separator:ae61a6eb6577b78f0c200f8118d54e4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd057fa15f7fd73072dde10c56c993a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a2bd057fa15f7fd73072dde10c56c993a">MVariant</a> (<a class="el" href="class_m_object.html">MObject</a> *o)</td></tr>
<tr class="memdesc:a2bd057fa15f7fd73072dde10c56c993a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value of type object, which references the object given.  <a href="#a2bd057fa15f7fd73072dde10c56c993a">More...</a><br /></td></tr>
<tr class="separator:a2bd057fa15f7fd73072dde10c56c993a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4261b3d144547f9aa41d9de9abc29c"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a7d4261b3d144547f9aa41d9de9abc29c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a7d4261b3d144547f9aa41d9de9abc29c">MVariant</a> (const C *o, <a class="el" href="class_m_variant.html#a2d8cadf5ff38042e6ada9c9889fbfc66">AcceptObjectEmbedded</a>)</td></tr>
<tr class="memdesc:a7d4261b3d144547f9aa41d9de9abc29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the embedded object to the variant.  <a href="#a7d4261b3d144547f9aa41d9de9abc29c">More...</a><br /></td></tr>
<tr class="separator:a7d4261b3d144547f9aa41d9de9abc29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197e461c84d60c0c0a89a473ae674fed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a197e461c84d60c0c0a89a473ae674fed">MVariant</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;v)</td></tr>
<tr class="memdesc:a197e461c84d60c0c0a89a473ae674fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the value from the copy.  <a href="#a197e461c84d60c0c0a89a473ae674fed">More...</a><br /></td></tr>
<tr class="separator:a197e461c84d60c0c0a89a473ae674fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2bdf1054d8817d68157d3398c00ecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d2bdf1054d8817d68157d3398c00ecf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a3d2bdf1054d8817d68157d3398c00ecf">~MVariant</a> ()</td></tr>
<tr class="memdesc:a3d2bdf1054d8817d68157d3398c00ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the variant object, reclaim memory if the value is of type string. <br /></td></tr>
<tr class="separator:a3d2bdf1054d8817d68157d3398c00ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173cd3cf7b28e85aef99759be2ec7ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6173cd3cf7b28e85aef99759be2ec7ff"></a>
<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">MVariant::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a6173cd3cf7b28e85aef99759be2ec7ff">GetType</a> () const </td></tr>
<tr class="memdesc:a6173cd3cf7b28e85aef99759be2ec7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the variant object. <br /></td></tr>
<tr class="separator:a6173cd3cf7b28e85aef99759be2ec7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588cff51556d6846eb60a5a79c6e51d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a588cff51556d6846eb60a5a79c6e51d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a588cff51556d6846eb60a5a79c6e51d0">IsEmpty</a> () const </td></tr>
<tr class="memdesc:a588cff51556d6846eb60a5a79c6e51d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the variant is of type VAR_EMPTY, which means it is not initialized with any value. <br /></td></tr>
<tr class="separator:a588cff51556d6846eb60a5a79c6e51d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b331de209f1dd70ff74635c26d9cbe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a9b331de209f1dd70ff74635c26d9cbe2">IsNumeric</a> () const </td></tr>
<tr class="memdesc:a9b331de209f1dd70ff74635c26d9cbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the variant is of numeric type, so the arithmetic operations can be performed.  <a href="#a9b331de209f1dd70ff74635c26d9cbe2">More...</a><br /></td></tr>
<tr class="separator:a9b331de209f1dd70ff74635c26d9cbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ed63628b3e7233c802284033e68fea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8ed63628b3e7233c802284033e68fea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ac8ed63628b3e7233c802284033e68fea">IsIndexed</a> () const </td></tr>
<tr class="memdesc:ac8ed63628b3e7233c802284033e68fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the variant can be indexed. <br /></td></tr>
<tr class="separator:ac8ed63628b3e7233c802284033e68fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd17f36c9cedfaa8078c9f7270ad91f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd17f36c9cedfaa8078c9f7270ad91f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a8cd17f36c9cedfaa8078c9f7270ad91f">IsCollection</a> () const </td></tr>
<tr class="memdesc:a8cd17f36c9cedfaa8078c9f7270ad91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the variant is a collection, array, or a map (which is a key-indexed collection). <br /></td></tr>
<tr class="separator:a8cd17f36c9cedfaa8078c9f7270ad91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd5ea59023b732cbd86acf0fc2f4474"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbd5ea59023b732cbd86acf0fc2f4474"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#adbd5ea59023b732cbd86acf0fc2f4474">IsObject</a> () const </td></tr>
<tr class="memdesc:adbd5ea59023b732cbd86acf0fc2f4474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the variant has an object reference. <br /></td></tr>
<tr class="separator:adbd5ea59023b732cbd86acf0fc2f4474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fffc36756e00734a6d70f98db8d2b23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fffc36756e00734a6d70f98db8d2b23"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a5fffc36756e00734a6d70f98db8d2b23">operator=</a> (bool b)</td></tr>
<tr class="memdesc:a5fffc36756e00734a6d70f98db8d2b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type bool. <br /></td></tr>
<tr class="separator:a5fffc36756e00734a6d70f98db8d2b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21665297626a21301bb1c30749070cfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21665297626a21301bb1c30749070cfe"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a21665297626a21301bb1c30749070cfe">operator=</a> (char c)</td></tr>
<tr class="memdesc:a21665297626a21301bb1c30749070cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type char. <br /></td></tr>
<tr class="separator:a21665297626a21301bb1c30749070cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6620dcdfeadd49fb9812cd117e80455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6620dcdfeadd49fb9812cd117e80455"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad6620dcdfeadd49fb9812cd117e80455">operator=</a> (wchar_t c)</td></tr>
<tr class="memdesc:ad6620dcdfeadd49fb9812cd117e80455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type char. <br /></td></tr>
<tr class="separator:ad6620dcdfeadd49fb9812cd117e80455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6711b80113fbadc2a3718f0ef74c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f6711b80113fbadc2a3718f0ef74c02"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a7f6711b80113fbadc2a3718f0ef74c02">operator=</a> (Muint8 b)</td></tr>
<tr class="memdesc:a7f6711b80113fbadc2a3718f0ef74c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type byte. <br /></td></tr>
<tr class="separator:a7f6711b80113fbadc2a3718f0ef74c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099f8c5a5f02f15142692d52a9c94d33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a099f8c5a5f02f15142692d52a9c94d33"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a099f8c5a5f02f15142692d52a9c94d33">operator=</a> (int n)</td></tr>
<tr class="memdesc:a099f8c5a5f02f15142692d52a9c94d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type int. <br /></td></tr>
<tr class="separator:a099f8c5a5f02f15142692d52a9c94d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834579aef51ab11f20649a62937df030"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834579aef51ab11f20649a62937df030"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a834579aef51ab11f20649a62937df030">operator=</a> (unsigned n)</td></tr>
<tr class="memdesc:a834579aef51ab11f20649a62937df030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type unsigned int. <br /></td></tr>
<tr class="separator:a834579aef51ab11f20649a62937df030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1126a0332722ae6d16083ce7aa8d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c1126a0332722ae6d16083ce7aa8d1f"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1c1126a0332722ae6d16083ce7aa8d1f">operator=</a> (long n)</td></tr>
<tr class="memdesc:a1c1126a0332722ae6d16083ce7aa8d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type long. <br /></td></tr>
<tr class="separator:a1c1126a0332722ae6d16083ce7aa8d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384cb242bee2dc250cfd0757be5ab1ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384cb242bee2dc250cfd0757be5ab1ad"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a384cb242bee2dc250cfd0757be5ab1ad">operator=</a> (unsigned long n)</td></tr>
<tr class="memdesc:a384cb242bee2dc250cfd0757be5ab1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type unsigned long. <br /></td></tr>
<tr class="separator:a384cb242bee2dc250cfd0757be5ab1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f2e555d66277eb3c67eb748448071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad13f2e555d66277eb3c67eb748448071"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad13f2e555d66277eb3c67eb748448071">operator=</a> (Mint64 v)</td></tr>
<tr class="memdesc:ad13f2e555d66277eb3c67eb748448071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of 64-bit integer type. <br /></td></tr>
<tr class="separator:ad13f2e555d66277eb3c67eb748448071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3619ba9c85aceede7027fde6388b529d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3619ba9c85aceede7027fde6388b529d"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a3619ba9c85aceede7027fde6388b529d">operator=</a> (Muint64 v)</td></tr>
<tr class="memdesc:a3619ba9c85aceede7027fde6388b529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of 64-bit unsigned integer type. <br /></td></tr>
<tr class="separator:a3619ba9c85aceede7027fde6388b529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389bf5e15c2208958719213871f43e50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a389bf5e15c2208958719213871f43e50"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a389bf5e15c2208958719213871f43e50">operator=</a> (double f)</td></tr>
<tr class="memdesc:a389bf5e15c2208958719213871f43e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type double. <br /></td></tr>
<tr class="separator:a389bf5e15c2208958719213871f43e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dbf824aebb8635fc21e9441de96595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90dbf824aebb8635fc21e9441de96595"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a90dbf824aebb8635fc21e9441de96595">operator=</a> (<a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> p)</td></tr>
<tr class="memdesc:a90dbf824aebb8635fc21e9441de96595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type pointer to the constant zero terminated string. <br /></td></tr>
<tr class="separator:a90dbf824aebb8635fc21e9441de96595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf1c8208476dfe1cada598d51b0bcc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf1c8208476dfe1cada598d51b0bcc3"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a2cf1c8208476dfe1cada598d51b0bcc3">operator=</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;s)</td></tr>
<tr class="memdesc:a2cf1c8208476dfe1cada598d51b0bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type string. <br /></td></tr>
<tr class="separator:a2cf1c8208476dfe1cada598d51b0bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8577c57797864a630f17ca676a07da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8577c57797864a630f17ca676a07da"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#acc8577c57797864a630f17ca676a07da">operator=</a> (const <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a> &amp;s)</td></tr>
<tr class="memdesc:acc8577c57797864a630f17ca676a07da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type string collection. <br /></td></tr>
<tr class="separator:acc8577c57797864a630f17ca676a07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a77c70358bac44de3f55b97f9297f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a77c70358bac44de3f55b97f9297f2"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af4a77c70358bac44de3f55b97f9297f2">operator=</a> (const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">VariantVector</a> &amp;s)</td></tr>
<tr class="memdesc:af4a77c70358bac44de3f55b97f9297f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type variant vector. <br /></td></tr>
<tr class="separator:af4a77c70358bac44de3f55b97f9297f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6ed5fa3d530787de272f985ce1ac53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e6ed5fa3d530787de272f985ce1ac53"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a0e6ed5fa3d530787de272f985ce1ac53">operator=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;v)</td></tr>
<tr class="memdesc:a0e6ed5fa3d530787de272f985ce1ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type <a class="el" href="class_m_variant.html" title="Variant data type, where the particular value type is dynamically determined at runtime. ">MVariant</a>. <br /></td></tr>
<tr class="separator:a0e6ed5fa3d530787de272f985ce1ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905b5e9b51519f53b683e6edcf107a9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905b5e9b51519f53b683e6edcf107a9a"></a>
<a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a905b5e9b51519f53b683e6edcf107a9a">operator=</a> (const <a class="el" href="class_m_variant_1_1_object_by_value.html">ObjectByValue</a> &amp;o)</td></tr>
<tr class="memdesc:a905b5e9b51519f53b683e6edcf107a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes <a class="el" href="class_m_variant_1_1_object_by_value.html" title="Local placeholder class, used for passing small objects by value. ">ObjectByValue</a> stub, as handled by reflection. <br /></td></tr>
<tr class="separator:a905b5e9b51519f53b683e6edcf107a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26a05e728221b953a05fd80d6860897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26a05e728221b953a05fd80d6860897"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ac26a05e728221b953a05fd80d6860897">AssignByteString</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;v)</td></tr>
<tr class="memdesc:ac26a05e728221b953a05fd80d6860897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the byte string to the variant type. <br /></td></tr>
<tr class="separator:ac26a05e728221b953a05fd80d6860897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad734cf2743702b61dd1bc8e16112a062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad734cf2743702b61dd1bc8e16112a062"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad734cf2743702b61dd1bc8e16112a062">AssignByteStringCollection</a> (const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;v)</td></tr>
<tr class="memdesc:ad734cf2743702b61dd1bc8e16112a062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the byte string vector to the variant type. <br /></td></tr>
<tr class="separator:ad734cf2743702b61dd1bc8e16112a062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c20cdcca9b3868dc3cddb93865b7b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97c20cdcca9b3868dc3cddb93865b7b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a97c20cdcca9b3868dc3cddb93865b7b8">Assign</a> (const Muint8 *p, unsigned len)</td></tr>
<tr class="memdesc:a97c20cdcca9b3868dc3cddb93865b7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the byte string to the variant type. <br /></td></tr>
<tr class="separator:a97c20cdcca9b3868dc3cddb93865b7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b1736b69384b823d5be50466994d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a068b1736b69384b823d5be50466994d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a068b1736b69384b823d5be50466994d1">Assign</a> (const char *p, unsigned len)</td></tr>
<tr class="memdesc:a068b1736b69384b823d5be50466994d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the byte string to the variant type. <br /></td></tr>
<tr class="separator:a068b1736b69384b823d5be50466994d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32f8a68ecce8cdcba53e3bb4d3fcfa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af32f8a68ecce8cdcba53e3bb4d3fcfa0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af32f8a68ecce8cdcba53e3bb4d3fcfa0">AssignString</a> (<a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> p, unsigned len)</td></tr>
<tr class="memdesc:af32f8a68ecce8cdcba53e3bb4d3fcfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the string to the variant type. <br /></td></tr>
<tr class="separator:af32f8a68ecce8cdcba53e3bb4d3fcfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3d0c350d70112d0e8b708c469c9aa0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:abf3d0c350d70112d0e8b708c469c9aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_variant.html#abf3d0c350d70112d0e8b708c469c9aa0">AssignObjectEmbedded</a> (const C *o)</td></tr>
<tr class="memdesc:abf3d0c350d70112d0e8b708c469c9aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the byte embedded object to the variant type.  <a href="#abf3d0c350d70112d0e8b708c469c9aa0">More...</a><br /></td></tr>
<tr class="separator:abf3d0c350d70112d0e8b708c469c9aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45edfc0a713195dab465502aa4134903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a45edfc0a713195dab465502aa4134903">operator=</a> (const <a class="el" href="class_m_object.html">MObject</a> *v)</td></tr>
<tr class="memdesc:a45edfc0a713195dab465502aa4134903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator that takes variable of type <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>.  <a href="#a45edfc0a713195dab465502aa4134903">More...</a><br /></td></tr>
<tr class="separator:a45edfc0a713195dab465502aa4134903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d72bed00c7f1c47eb70a1b121824b1f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a0d72bed00c7f1c47eb70a1b121824b1f">AsConstChars</a> () const </td></tr>
<tr class="memdesc:a0d72bed00c7f1c47eb70a1b121824b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret string related values of this variant as zero terminated string.  <a href="#a0d72bed00c7f1c47eb70a1b121824b1f">More...</a><br /></td></tr>
<tr class="separator:a0d72bed00c7f1c47eb70a1b121824b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62092e72736d30c8ac9e3616d248b0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ae62092e72736d30c8ac9e3616d248b0e">AsBool</a> () const </td></tr>
<tr class="memdesc:ae62092e72736d30c8ac9e3616d248b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as type bool, if possible.  <a href="#ae62092e72736d30c8ac9e3616d248b0e">More...</a><br /></td></tr>
<tr class="separator:ae62092e72736d30c8ac9e3616d248b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cf57642cf3859006b01f408e8f0d12"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a32cf57642cf3859006b01f408e8f0d12">AsByte</a> () const </td></tr>
<tr class="memdesc:a32cf57642cf3859006b01f408e8f0d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as byte, if possible.  <a href="#a32cf57642cf3859006b01f408e8f0d12">More...</a><br /></td></tr>
<tr class="separator:a32cf57642cf3859006b01f408e8f0d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5811ff34f6a7f4964db18e7da7db2e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga1976cff572b7c48d658f604b87764853">MChar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aa5811ff34f6a7f4964db18e7da7db2e8">AsChar</a> () const </td></tr>
<tr class="memdesc:aa5811ff34f6a7f4964db18e7da7db2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as type MChar, if possible.  <a href="#aa5811ff34f6a7f4964db18e7da7db2e8">More...</a><br /></td></tr>
<tr class="separator:aa5811ff34f6a7f4964db18e7da7db2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884c6eeb62e155138e72e5536eccfc68"><td class="memItemLeft" align="right" valign="top">Muint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a884c6eeb62e155138e72e5536eccfc68">AsDWord</a> () const </td></tr>
<tr class="memdesc:a884c6eeb62e155138e72e5536eccfc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as double word.  <a href="#a884c6eeb62e155138e72e5536eccfc68">More...</a><br /></td></tr>
<tr class="separator:a884c6eeb62e155138e72e5536eccfc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57be6dc2d3d003559eeeb7c521d6d9c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a57be6dc2d3d003559eeeb7c521d6d9c8">AsInt</a> () const </td></tr>
<tr class="memdesc:a57be6dc2d3d003559eeeb7c521d6d9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as integer type, if possible.  <a href="#a57be6dc2d3d003559eeeb7c521d6d9c8">More...</a><br /></td></tr>
<tr class="separator:a57be6dc2d3d003559eeeb7c521d6d9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e904ee893f54df1c2323ad483d9234b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a7e904ee893f54df1c2323ad483d9234b">AsUInt</a> () const </td></tr>
<tr class="memdesc:a7e904ee893f54df1c2323ad483d9234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as unsigned integer type, if possible.  <a href="#a7e904ee893f54df1c2323ad483d9234b">More...</a><br /></td></tr>
<tr class="separator:a7e904ee893f54df1c2323ad483d9234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bfd03872fa514ecf767184d5e71f64"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a50bfd03872fa514ecf767184d5e71f64">AsLong</a> () const </td></tr>
<tr class="memdesc:a50bfd03872fa514ecf767184d5e71f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as long integer type, if possible.  <a href="#a50bfd03872fa514ecf767184d5e71f64">More...</a><br /></td></tr>
<tr class="separator:a50bfd03872fa514ecf767184d5e71f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6094597b2bd8d346c74dff954dcd99"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#afb6094597b2bd8d346c74dff954dcd99">AsULong</a> () const </td></tr>
<tr class="memdesc:afb6094597b2bd8d346c74dff954dcd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as unsigned long integer type, if possible.  <a href="#afb6094597b2bd8d346c74dff954dcd99">More...</a><br /></td></tr>
<tr class="separator:afb6094597b2bd8d346c74dff954dcd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9aea379dfcc63bcc9618f76f696770"><td class="memItemLeft" align="right" valign="top">Mint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ade9aea379dfcc63bcc9618f76f696770">AsInt64</a> () const </td></tr>
<tr class="memdesc:ade9aea379dfcc63bcc9618f76f696770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as 64-bit integer type, if possible.  <a href="#ade9aea379dfcc63bcc9618f76f696770">More...</a><br /></td></tr>
<tr class="separator:ade9aea379dfcc63bcc9618f76f696770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b5fc164d7e491b956ba9cf043b2321"><td class="memItemLeft" align="right" valign="top">Muint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a67b5fc164d7e491b956ba9cf043b2321">AsUInt64</a> () const </td></tr>
<tr class="memdesc:a67b5fc164d7e491b956ba9cf043b2321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as unsigned long integer type, if possible.  <a href="#a67b5fc164d7e491b956ba9cf043b2321">More...</a><br /></td></tr>
<tr class="separator:a67b5fc164d7e491b956ba9cf043b2321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf9067e2ffa684230fac074ce05ec5f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#accf9067e2ffa684230fac074ce05ec5f">AsSizeT</a> () const </td></tr>
<tr class="memdesc:accf9067e2ffa684230fac074ce05ec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as an integer type equivalent to size_t, if possible.  <a href="#accf9067e2ffa684230fac074ce05ec5f">More...</a><br /></td></tr>
<tr class="separator:accf9067e2ffa684230fac074ce05ec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2670788bbde43329396519580a6407d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ae2670788bbde43329396519580a6407d">AsDouble</a> () const </td></tr>
<tr class="memdesc:ae2670788bbde43329396519580a6407d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as double precision floating point, if possible.  <a href="#ae2670788bbde43329396519580a6407d">More...</a><br /></td></tr>
<tr class="separator:ae2670788bbde43329396519580a6407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53150ff574068ff61f61e2473d5908ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a53150ff574068ff61f61e2473d5908ee">AsByteString</a> () const </td></tr>
<tr class="memdesc:a53150ff574068ff61f61e2473d5908ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as byte string, if possible.  <a href="#a53150ff574068ff61f61e2473d5908ee">More...</a><br /></td></tr>
<tr class="separator:a53150ff574068ff61f61e2473d5908ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab01bb59ad807fbfeb554304e8a07d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1ab01bb59ad807fbfeb554304e8a07d5">AsString</a> () const </td></tr>
<tr class="memdesc:a1ab01bb59ad807fbfeb554304e8a07d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as string, if possible.  <a href="#a1ab01bb59ad807fbfeb554304e8a07d5">More...</a><br /></td></tr>
<tr class="separator:a1ab01bb59ad807fbfeb554304e8a07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2928059cffeba9b94aa751e90c05a803"><td class="memItemLeft" align="right" valign="top">MSharedString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a2928059cffeba9b94aa751e90c05a803">AsSharedString</a> () const </td></tr>
<tr class="memdesc:a2928059cffeba9b94aa751e90c05a803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as shared string, if possible.  <a href="#a2928059cffeba9b94aa751e90c05a803">More...</a><br /></td></tr>
<tr class="separator:a2928059cffeba9b94aa751e90c05a803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612a41aa9c193bc93f320e67df041a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a612a41aa9c193bc93f320e67df041a09">AsString</a> (unsigned mask) const </td></tr>
<tr class="memdesc:a612a41aa9c193bc93f320e67df041a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as string, if possible, using mask that specifies the conversions to make.  <a href="#a612a41aa9c193bc93f320e67df041a09">More...</a><br /></td></tr>
<tr class="separator:a612a41aa9c193bc93f320e67df041a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a4c4c2abcbfa4c97f3e92c21fb1e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a32a4c4c2abcbfa4c97f3e92c21fb1e4e">AsEscapedString</a> () const </td></tr>
<tr class="memdesc:a32a4c4c2abcbfa4c97f3e92c21fb1e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as a string with C escapes, if possible.  <a href="#a32a4c4c2abcbfa4c97f3e92c21fb1e4e">More...</a><br /></td></tr>
<tr class="separator:a32a4c4c2abcbfa4c97f3e92c21fb1e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b74d0cdf67b360ef93919455a1c4a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a82b74d0cdf67b360ef93919455a1c4a5">AsStringCollection</a> () const </td></tr>
<tr class="memdesc:a82b74d0cdf67b360ef93919455a1c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as string collection, if possible.  <a href="#a82b74d0cdf67b360ef93919455a1c4a5">More...</a><br /></td></tr>
<tr class="separator:a82b74d0cdf67b360ef93919455a1c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb99170106c9b09666f0e2b50495767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a5eb99170106c9b09666f0e2b50495767">AsByteStringCollection</a> () const </td></tr>
<tr class="memdesc:a5eb99170106c9b09666f0e2b50495767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as byte string collection, if possible.  <a href="#a5eb99170106c9b09666f0e2b50495767">More...</a><br /></td></tr>
<tr class="separator:a5eb99170106c9b09666f0e2b50495767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd2f98a128cfc2e99728732d06fdb86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">VariantVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aadd2f98a128cfc2e99728732d06fdb86">AsVariantCollection</a> () const </td></tr>
<tr class="memdesc:aadd2f98a128cfc2e99728732d06fdb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the variant value as variant collection, if possible.  <a href="#aadd2f98a128cfc2e99728732d06fdb86">More...</a><br /></td></tr>
<tr class="separator:aadd2f98a128cfc2e99728732d06fdb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758d71332ef4314a347f1cbcdf95980"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0758d71332ef4314a347f1cbcdf95980"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a0758d71332ef4314a347f1cbcdf95980">SetEmpty</a> ()</td></tr>
<tr class="memdesc:a0758d71332ef4314a347f1cbcdf95980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the value of the variant type. <br /></td></tr>
<tr class="separator:a0758d71332ef4314a347f1cbcdf95980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6ad7a90aa701022988637ec1cf095e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a6f6ad7a90aa701022988637ec1cf095e">SetEmptyWithObjectDelete</a> ()</td></tr>
<tr class="memdesc:a6f6ad7a90aa701022988637ec1cf095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the value of the variant type, and if it is an object, delete it.  <a href="#a6f6ad7a90aa701022988637ec1cf095e">More...</a><br /></td></tr>
<tr class="separator:a6f6ad7a90aa701022988637ec1cf095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977933d4130faca1b2e76e3ba60246d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a977933d4130faca1b2e76e3ba60246d3">SetToNull</a> (<a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">MVariant::Type</a> type)</td></tr>
<tr class="memdesc:a977933d4130faca1b2e76e3ba60246d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the value of the variant type, and set it to null, either empty or zero value depending on the given type.  <a href="#a977933d4130faca1b2e76e3ba60246d3">More...</a><br /></td></tr>
<tr class="separator:a977933d4130faca1b2e76e3ba60246d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20523aae0912472603b9b0bfd09858d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a20523aae0912472603b9b0bfd09858d7">ReserveElements</a> (int count)</td></tr>
<tr class="memdesc:a20523aae0912472603b9b0bfd09858d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve the number of elements in the variant when variant is indexed.  <a href="#a20523aae0912472603b9b0bfd09858d7">More...</a><br /></td></tr>
<tr class="separator:a20523aae0912472603b9b0bfd09858d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac07bb940d365e6f7201c9b9acf7a817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac07bb940d365e6f7201c9b9acf7a817"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aac07bb940d365e6f7201c9b9acf7a817">Swap</a> (<a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:aac07bb940d365e6f7201c9b9acf7a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently swap the value with the given value. <br /></td></tr>
<tr class="separator:aac07bb940d365e6f7201c9b9acf7a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe316f92b8f84aa1f0545b8af01acd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#abfe316f92b8f84aa1f0545b8af01acd7">MoveFrom</a> (<a class="el" href="class_m_variant.html">MVariant</a> &amp;other)</td></tr>
<tr class="memdesc:abfe316f92b8f84aa1f0545b8af01acd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast method that moves the value to another variant, and sets the other variant type to Empty.  <a href="#abfe316f92b8f84aa1f0545b8af01acd7">More...</a><br /></td></tr>
<tr class="separator:abfe316f92b8f84aa1f0545b8af01acd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c21ead46c8019205062835d8fd35598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1c21ead46c8019205062835d8fd35598">Pow</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a1c21ead46c8019205062835d8fd35598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this object with the power of the object given.  <a href="#a1c21ead46c8019205062835d8fd35598">More...</a><br /></td></tr>
<tr class="separator:a1c21ead46c8019205062835d8fd35598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2cb632ca131dc17e098ae6a65ee827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#acd2cb632ca131dc17e098ae6a65ee827">GetAllMapKeys</a> () const </td></tr>
<tr class="memdesc:acd2cb632ca131dc17e098ae6a65ee827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a variant vector of keys in this map.  <a href="#acd2cb632ca131dc17e098ae6a65ee827">More...</a><br /></td></tr>
<tr class="separator:acd2cb632ca131dc17e098ae6a65ee827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69469e41db28f90de47acec598c99be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a69469e41db28f90de47acec598c99be3">GetAllMapValues</a> () const </td></tr>
<tr class="memdesc:a69469e41db28f90de47acec598c99be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a variant vector of values in this map.  <a href="#a69469e41db28f90de47acec598c99be3">More...</a><br /></td></tr>
<tr class="separator:a69469e41db28f90de47acec598c99be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f6f830f743384f5248d4e68277f70"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a245f6f830f743384f5248d4e68277f70">GetMapKeyByIndex</a> (int i) const </td></tr>
<tr class="memdesc:a245f6f830f743384f5248d4e68277f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a key in the map by its index.  <a href="#a245f6f830f743384f5248d4e68277f70">More...</a><br /></td></tr>
<tr class="separator:a245f6f830f743384f5248d4e68277f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad531ecad85510168ac1ddb472a5ee480"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad531ecad85510168ac1ddb472a5ee480">GetMapValueByIndex</a> (int i) const </td></tr>
<tr class="memdesc:ad531ecad85510168ac1ddb472a5ee480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a key in the map by its index.  <a href="#ad531ecad85510168ac1ddb472a5ee480">More...</a><br /></td></tr>
<tr class="separator:ad531ecad85510168ac1ddb472a5ee480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc03c44754452635e8c22569e7faa76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#adc03c44754452635e8c22569e7faa76a">SwapItems</a> (int index1, int index2)</td></tr>
<tr class="memdesc:adc03c44754452635e8c22569e7faa76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two indexed items in the array or collection.  <a href="#adc03c44754452635e8c22569e7faa76a">More...</a><br /></td></tr>
<tr class="separator:adc03c44754452635e8c22569e7faa76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ac5f7c76ec24550a294701414d49ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a34ac5f7c76ec24550a294701414d49ad">IsPresent</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;it) const </td></tr>
<tr class="memdesc:a34ac5f7c76ec24550a294701414d49ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given item is in the variant.  <a href="#a34ac5f7c76ec24550a294701414d49ad">More...</a><br /></td></tr>
<tr class="separator:a34ac5f7c76ec24550a294701414d49ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fcc93e4880feab8b4236ef2b0bb962"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a59fcc93e4880feab8b4236ef2b0bb962">FindIndexOf</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;, bool reverse=false) const </td></tr>
<tr class="memdesc:a59fcc93e4880feab8b4236ef2b0bb962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index of the given element in the indexed variant.  <a href="#a59fcc93e4880feab8b4236ef2b0bb962">More...</a><br /></td></tr>
<tr class="separator:a59fcc93e4880feab8b4236ef2b0bb962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2f9d1a99195a9e3402ec4da62787d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a14f2f9d1a99195a9e3402ec4da62787d">AddToVariantCollection</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;v)</td></tr>
<tr class="memdesc:a14f2f9d1a99195a9e3402ec4da62787d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given variant as a whole to the collection.  <a href="#a14f2f9d1a99195a9e3402ec4da62787d">More...</a><br /></td></tr>
<tr class="separator:a14f2f9d1a99195a9e3402ec4da62787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1503ecea600b4ad215d6fd1d30794f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a6d1503ecea600b4ad215d6fd1d30794f">GetSlice</a> (int from, int to) const </td></tr>
<tr class="memdesc:a6d1503ecea600b4ad215d6fd1d30794f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the slice of values for types that support subscripts.  <a href="#a6d1503ecea600b4ad215d6fd1d30794f">More...</a><br /></td></tr>
<tr class="separator:a6d1503ecea600b4ad215d6fd1d30794f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec74022c498995e1eda089c5bd42da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a9ec74022c498995e1eda089c5bd42da6">SetSlice</a> (int from, int to, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;values)</td></tr>
<tr class="memdesc:a9ec74022c498995e1eda089c5bd42da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the slice of values for types that support subscripts.  <a href="#a9ec74022c498995e1eda089c5bd42da6">More...</a><br /></td></tr>
<tr class="separator:a9ec74022c498995e1eda089c5bd42da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6911af9d20b70ca576a1d38cb13b1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aed6911af9d20b70ca576a1d38cb13b1a">operator==</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:aed6911af9d20b70ca576a1d38cb13b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#aed6911af9d20b70ca576a1d38cb13b1a">More...</a><br /></td></tr>
<tr class="separator:aed6911af9d20b70ca576a1d38cb13b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d117e0d643851c216d0cecddf5a40d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a2d117e0d643851c216d0cecddf5a40d3">operator!=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;other) const </td></tr>
<tr class="memdesc:a2d117e0d643851c216d0cecddf5a40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a2d117e0d643851c216d0cecddf5a40d3">More...</a><br /></td></tr>
<tr class="separator:a2d117e0d643851c216d0cecddf5a40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73ac2f2e81395d955f4e41a4af11f10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad73ac2f2e81395d955f4e41a4af11f10">operator&lt;</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:ad73ac2f2e81395d955f4e41a4af11f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator.  <a href="#ad73ac2f2e81395d955f4e41a4af11f10">More...</a><br /></td></tr>
<tr class="separator:ad73ac2f2e81395d955f4e41a4af11f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb4dd10f9cabee1565dfe5f8385d619"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#afdb4dd10f9cabee1565dfe5f8385d619">operator&gt;</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:afdb4dd10f9cabee1565dfe5f8385d619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator.  <a href="#afdb4dd10f9cabee1565dfe5f8385d619">More...</a><br /></td></tr>
<tr class="separator:afdb4dd10f9cabee1565dfe5f8385d619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769a4b62d1533fe1aee9e2c60fbcc9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad769a4b62d1533fe1aee9e2c60fbcc9c">operator&lt;=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;v) const </td></tr>
<tr class="memdesc:ad769a4b62d1533fe1aee9e2c60fbcc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than operator.  <a href="#ad769a4b62d1533fe1aee9e2c60fbcc9c">More...</a><br /></td></tr>
<tr class="separator:ad769a4b62d1533fe1aee9e2c60fbcc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00d8323e65b1e246b2297d4f6476247"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aa00d8323e65b1e246b2297d4f6476247">operator&gt;=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;v) const </td></tr>
<tr class="memdesc:aa00d8323e65b1e246b2297d4f6476247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than operator.  <a href="#aa00d8323e65b1e246b2297d4f6476247">More...</a><br /></td></tr>
<tr class="separator:aa00d8323e65b1e246b2297d4f6476247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a985d1b79098278489affa5f7e2be6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a5a985d1b79098278489affa5f7e2be6d">operator|</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a5a985d1b79098278489affa5f7e2be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator OR.  <a href="#a5a985d1b79098278489affa5f7e2be6d">More...</a><br /></td></tr>
<tr class="separator:a5a985d1b79098278489affa5f7e2be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b377ff1a974696f839dbacba4d4e10e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a9b377ff1a974696f839dbacba4d4e10e">operator&amp;</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a9b377ff1a974696f839dbacba4d4e10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator AND.  <a href="#a9b377ff1a974696f839dbacba4d4e10e">More...</a><br /></td></tr>
<tr class="separator:a9b377ff1a974696f839dbacba4d4e10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af463241a52645d919448418d4394cdf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af463241a52645d919448418d4394cdf6">operator^</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:af463241a52645d919448418d4394cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator XOR.  <a href="#af463241a52645d919448418d4394cdf6">More...</a><br /></td></tr>
<tr class="separator:af463241a52645d919448418d4394cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04043791ccbb040f52f6935927ed3d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a04043791ccbb040f52f6935927ed3d4d">operator!</a> () const </td></tr>
<tr class="memdesc:a04043791ccbb040f52f6935927ed3d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary operator NOT.  <a href="#a04043791ccbb040f52f6935927ed3d4d">More...</a><br /></td></tr>
<tr class="separator:a04043791ccbb040f52f6935927ed3d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2581b210ee1c531a4445367de7afe64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af2581b210ee1c531a4445367de7afe64">operator-</a> () const </td></tr>
<tr class="memdesc:af2581b210ee1c531a4445367de7afe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary operator minus.  <a href="#af2581b210ee1c531a4445367de7afe64">More...</a><br /></td></tr>
<tr class="separator:af2581b210ee1c531a4445367de7afe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402412b9de6d2792470c1c91a7e1c27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a402412b9de6d2792470c1c91a7e1c27c">operator+</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a402412b9de6d2792470c1c91a7e1c27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator plus.  <a href="#a402412b9de6d2792470c1c91a7e1c27c">More...</a><br /></td></tr>
<tr class="separator:a402412b9de6d2792470c1c91a7e1c27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aee340143b96b6d86ba0e7a7c9fb9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a00aee340143b96b6d86ba0e7a7c9fb9c">operator-</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a00aee340143b96b6d86ba0e7a7c9fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator minus.  <a href="#a00aee340143b96b6d86ba0e7a7c9fb9c">More...</a><br /></td></tr>
<tr class="separator:a00aee340143b96b6d86ba0e7a7c9fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6755a03342771c59c5c02e3c5d21c5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a6755a03342771c59c5c02e3c5d21c5a2">operator*</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a6755a03342771c59c5c02e3c5d21c5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary multiplication operator.  <a href="#a6755a03342771c59c5c02e3c5d21c5a2">More...</a><br /></td></tr>
<tr class="separator:a6755a03342771c59c5c02e3c5d21c5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2bb85c185500163329bcc06fb190b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a4af2bb85c185500163329bcc06fb190b">operator/</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a4af2bb85c185500163329bcc06fb190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary division operator.  <a href="#a4af2bb85c185500163329bcc06fb190b">More...</a><br /></td></tr>
<tr class="separator:a4af2bb85c185500163329bcc06fb190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f2fa82538227eaf1135c5dc18f798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1e0f2fa82538227eaf1135c5dc18f798">operator%</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a1e0f2fa82538227eaf1135c5dc18f798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary modulus operator.  <a href="#a1e0f2fa82538227eaf1135c5dc18f798">More...</a><br /></td></tr>
<tr class="separator:a1e0f2fa82538227eaf1135c5dc18f798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b73767ea96569dc5749e2c366e227f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a17b73767ea96569dc5749e2c366e227f">operator&lt;&lt;</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:a17b73767ea96569dc5749e2c366e227f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift operator.  <a href="#a17b73767ea96569dc5749e2c366e227f">More...</a><br /></td></tr>
<tr class="separator:a17b73767ea96569dc5749e2c366e227f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61762613c09a4fce083c42ef4ed1047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad61762613c09a4fce083c42ef4ed1047">operator&gt;&gt;</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;) const </td></tr>
<tr class="memdesc:ad61762613c09a4fce083c42ef4ed1047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift operator.  <a href="#ad61762613c09a4fce083c42ef4ed1047">More...</a><br /></td></tr>
<tr class="separator:ad61762613c09a4fce083c42ef4ed1047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7c32da760eb711e8545e1d1abf136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a41a7c32da760eb711e8545e1d1abf136">operator++</a> ()</td></tr>
<tr class="memdesc:a41a7c32da760eb711e8545e1d1abf136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator.  <a href="#a41a7c32da760eb711e8545e1d1abf136">More...</a><br /></td></tr>
<tr class="separator:a41a7c32da760eb711e8545e1d1abf136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7fb03b48fa43e360dee4a52824e66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a7d7fb03b48fa43e360dee4a52824e66b">operator--</a> ()</td></tr>
<tr class="memdesc:a7d7fb03b48fa43e360dee4a52824e66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator.  <a href="#a7d7fb03b48fa43e360dee4a52824e66b">More...</a><br /></td></tr>
<tr class="separator:a7d7fb03b48fa43e360dee4a52824e66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfdf21c8474dd6073cdc651d0adc898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aebfdf21c8474dd6073cdc651d0adc898">operator+=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:aebfdf21c8474dd6073cdc651d0adc898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator increment self by value.  <a href="#aebfdf21c8474dd6073cdc651d0adc898">More...</a><br /></td></tr>
<tr class="separator:aebfdf21c8474dd6073cdc651d0adc898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed243e52cce7d1eab663363afe67686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1ed243e52cce7d1eab663363afe67686">operator-=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:a1ed243e52cce7d1eab663363afe67686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator decrement self by value.  <a href="#a1ed243e52cce7d1eab663363afe67686">More...</a><br /></td></tr>
<tr class="separator:a1ed243e52cce7d1eab663363afe67686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fed1af5245d3178485811321b5c654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af9fed1af5245d3178485811321b5c654">operator*=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:af9fed1af5245d3178485811321b5c654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator multiply self by value.  <a href="#af9fed1af5245d3178485811321b5c654">More...</a><br /></td></tr>
<tr class="separator:af9fed1af5245d3178485811321b5c654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3a568eb4659c0cc3f12adf2185b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a59f3a568eb4659c0cc3f12adf2185b0c">operator/=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:a59f3a568eb4659c0cc3f12adf2185b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator divide self by value.  <a href="#a59f3a568eb4659c0cc3f12adf2185b0c">More...</a><br /></td></tr>
<tr class="separator:a59f3a568eb4659c0cc3f12adf2185b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f6056b4a85b486c0069386ef34cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ada7f6056b4a85b486c0069386ef34cba">operator%=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:ada7f6056b4a85b486c0069386ef34cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator modulus self by value.  <a href="#ada7f6056b4a85b486c0069386ef34cba">More...</a><br /></td></tr>
<tr class="separator:ada7f6056b4a85b486c0069386ef34cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d98b382b2dddb8b73f19ac4ad0be33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a14d98b382b2dddb8b73f19ac4ad0be33">operator&gt;&gt;=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:a14d98b382b2dddb8b73f19ac4ad0be33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator right shift self by value.  <a href="#a14d98b382b2dddb8b73f19ac4ad0be33">More...</a><br /></td></tr>
<tr class="separator:a14d98b382b2dddb8b73f19ac4ad0be33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd4c9d4d6f87d6536f4901ad7c8f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a00cd4c9d4d6f87d6536f4901ad7c8f14">operator&lt;&lt;=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:a00cd4c9d4d6f87d6536f4901ad7c8f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator left shift self by value.  <a href="#a00cd4c9d4d6f87d6536f4901ad7c8f14">More...</a><br /></td></tr>
<tr class="separator:a00cd4c9d4d6f87d6536f4901ad7c8f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f0f3c7c097957a47373158ab3c3ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a66f0f3c7c097957a47373158ab3c3ed8">operator|=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:a66f0f3c7c097957a47373158ab3c3ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator, binary or logical 'or' of self by value.  <a href="#a66f0f3c7c097957a47373158ab3c3ed8">More...</a><br /></td></tr>
<tr class="separator:a66f0f3c7c097957a47373158ab3c3ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a149d15dca98e27bb5d243347bf73f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a96a149d15dca98e27bb5d243347bf73f">operator&amp;=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:a96a149d15dca98e27bb5d243347bf73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator, binary or logical 'and' of self by value.  <a href="#a96a149d15dca98e27bb5d243347bf73f">More...</a><br /></td></tr>
<tr class="separator:a96a149d15dca98e27bb5d243347bf73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184d79d3e948381303b3bdd8d0e79b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ac184d79d3e948381303b3bdd8d0e79b4">operator^=</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;)</td></tr>
<tr class="memdesc:ac184d79d3e948381303b3bdd8d0e79b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator, binary or logical 'xor' of self by value.  <a href="#ac184d79d3e948381303b3bdd8d0e79b4">More...</a><br /></td></tr>
<tr class="separator:ac184d79d3e948381303b3bdd8d0e79b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a897113c03a80b7547b5386d6772951e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a897113c03a80b7547b5386d6772951e4">MVariant</a> (<a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> s)</td></tr>
<tr class="separator:a897113c03a80b7547b5386d6772951e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af165410365af925576d7f2e5ffc180e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af165410365af925576d7f2e5ffc180e1">MVariant</a> (<a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> s, unsigned len, <a class="el" href="class_m_variant.html#a66a51a803ca6662b3784ea1623d634d7">AcceptStringType</a>)</td></tr>
<tr class="separator:af165410365af925576d7f2e5ffc180e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad6c0c9568cde2f92f1a29460891e3426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad6c0c9568cde2f92f1a29460891e3426">MVariant</a> (const wchar_t *s)</td></tr>
<tr class="separator:ad6c0c9568cde2f92f1a29460891e3426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494f9803a5be65262669555f4d8d441d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a494f9803a5be65262669555f4d8d441d">MVariant</a> (const wchar_t *s, unsigned len, <a class="el" href="class_m_variant.html#a66a51a803ca6662b3784ea1623d634d7">AcceptStringType</a>=ACCEPT_STRING)</td></tr>
<tr class="separator:a494f9803a5be65262669555f4d8d441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac506a387a07c30745b6acaf1107b9658"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ac506a387a07c30745b6acaf1107b9658">MVariant</a> (const <a class="el" href="group___m_c_o_r_e.html#ga7efa11b093245ad26d7897d8c87f90f5">MWideString</a> &amp;s)</td></tr>
<tr class="separator:ac506a387a07c30745b6acaf1107b9658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4a53086b24d779c60a543257b0052b54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a4a53086b24d779c60a543257b0052b54">MVariant</a> (const char *p, unsigned len)</td></tr>
<tr class="separator:a4a53086b24d779c60a543257b0052b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1287489df2991aa103833b058c00181d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1287489df2991aa103833b058c00181d">MVariant</a> (const Muint8 *p, unsigned len)</td></tr>
<tr class="separator:a1287489df2991aa103833b058c00181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae35ba74ba664891580be8be0ad6490dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ae35ba74ba664891580be8be0ad6490dc">GetCount</a> () const </td></tr>
<tr class="separator:ae35ba74ba664891580be8be0ad6490dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6f6900b7f80150e39c6d03c8e7d446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aed6f6900b7f80150e39c6d03c8e7d446">SetCount</a> (int count)</td></tr>
<tr class="separator:aed6f6900b7f80150e39c6d03c8e7d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af0d3eec551c4884a502263c57da8e4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_object.html">MObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#af0d3eec551c4884a502263c57da8e4bc">AsObject</a> ()</td></tr>
<tr class="separator:af0d3eec551c4884a502263c57da8e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48827945a271aee26a13c8fa0b9ce039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_object.html">MObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a48827945a271aee26a13c8fa0b9ce039">AsObject</a> () const </td></tr>
<tr class="separator:a48827945a271aee26a13c8fa0b9ce039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaa5f538393249ee879c4100d7136690d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_object.html">MObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aaa5f538393249ee879c4100d7136690d">AsExistingObject</a> ()</td></tr>
<tr class="separator:aaa5f538393249ee879c4100d7136690d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ee77c8c0bad534467bdb1c3654ed88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_object.html">MObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a15ee77c8c0bad534467bdb1c3654ed88">AsExistingObject</a> () const </td></tr>
<tr class="separator:a15ee77c8c0bad534467bdb1c3654ed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aabc94e3694076fe328620a087e702ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;index) const </td></tr>
<tr class="separator:aabc94e3694076fe328620a087e702ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac002f07ed0cbbe0793d29aa245b8505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aac002f07ed0cbbe0793d29aa245b8505">GetItem</a> (int index) const </td></tr>
<tr class="separator:aac002f07ed0cbbe0793d29aa245b8505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d97f005b395038822fb7293a55368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a873d97f005b395038822fb7293a55368">GetItem</a> (unsigned index) const </td></tr>
<tr class="separator:a873d97f005b395038822fb7293a55368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a27dd698914c2a851054076ef263b5448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a27dd698914c2a851054076ef263b5448">SetItem</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;index, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="separator:a27dd698914c2a851054076ef263b5448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e382028084131560bc7fdf87a6b5a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a97e382028084131560bc7fdf87a6b5a5">SetItem</a> (int index, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="separator:a97e382028084131560bc7fdf87a6b5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acfffd994fc561b13220397f06bc527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a9acfffd994fc561b13220397f06bc527">SetItem</a> (unsigned index, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="separator:a9acfffd994fc561b13220397f06bc527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a35a4ff26d51edd66fb9ac167afd07f81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a35a4ff26d51edd66fb9ac167afd07f81">AccessItem</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;index)</td></tr>
<tr class="separator:a35a4ff26d51edd66fb9ac167afd07f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe9345270116e3b4d04cd186952217f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#afbe9345270116e3b4d04cd186952217f">AccessItem</a> (int index)</td></tr>
<tr class="separator:afbe9345270116e3b4d04cd186952217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bff0a7037930ce498d848c63d67c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ad8bff0a7037930ce498d848c63d67c9c">AccessItem</a> (unsigned index)</td></tr>
<tr class="separator:ad8bff0a7037930ce498d848c63d67c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbca768096633250fa2c79e9de60b10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a1bbca768096633250fa2c79e9de60b10">AccessItem</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;index) const </td></tr>
<tr class="separator:a1bbca768096633250fa2c79e9de60b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0330f5b334e29bf9b9f48d980d141af7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a0330f5b334e29bf9b9f48d980d141af7">AccessItem</a> (int index) const </td></tr>
<tr class="separator:a0330f5b334e29bf9b9f48d980d141af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6e70c8864fc353e18f5791d16d867"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a83b6e70c8864fc353e18f5791d16d867">AccessItem</a> (unsigned index) const </td></tr>
<tr class="separator:a83b6e70c8864fc353e18f5791d16d867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa7c25534c820d89ba64f625f5455a6ce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#aa7c25534c820d89ba64f625f5455a6ce">AdjustIndex</a> (int &amp;index, unsigned count)</td></tr>
<tr class="memdesc:aa7c25534c820d89ba64f625f5455a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust a given index so the negative index will mean counting from the end of the array.  <a href="#aa7c25534c820d89ba64f625f5455a6ce">More...</a><br /></td></tr>
<tr class="separator:aa7c25534c820d89ba64f625f5455a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412cf1a1b3f265adfe8572b67af6bc8f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a412cf1a1b3f265adfe8572b67af6bc8f">AdjustSlice</a> (int &amp;from, int &amp;to, unsigned count)</td></tr>
<tr class="memdesc:a412cf1a1b3f265adfe8572b67af6bc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust a given slice so the negative index will mean counting from the end of the array.  <a href="#a412cf1a1b3f265adfe8572b67af6bc8f">More...</a><br /></td></tr>
<tr class="separator:a412cf1a1b3f265adfe8572b67af6bc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8521343c35049ca6f0b3dea469c8bcf9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a8521343c35049ca6f0b3dea469c8bcf9">StaticIsObject</a> (const <a class="el" href="class_m_variant.html">MVariant</a> *var)</td></tr>
<tr class="separator:a8521343c35049ca6f0b3dea469c8bcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bf59ef6c8ae153239b240308798d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#ae47bf59ef6c8ae153239b240308798d8">StaticIsObject</a> (const <a class="el" href="class_m_variant.html">MVariant</a> &amp;var)</td></tr>
<tr class="separator:ae47bf59ef6c8ae153239b240308798d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2c1951d3efc6d8941fd4e740e95fefb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c1951d3efc6d8941fd4e740e95fefb9"></a>
static const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#a2c1951d3efc6d8941fd4e740e95fefb9">s_emptyString</a></td></tr>
<tr class="memdesc:a2c1951d3efc6d8941fd4e740e95fefb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty string that is used in many places through the code. <br /></td></tr>
<tr class="separator:a2c1951d3efc6d8941fd4e740e95fefb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa8f755d9d067272e72b619ea1c12ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affa8f755d9d067272e72b619ea1c12ca"></a>
static const <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_variant.html#affa8f755d9d067272e72b619ea1c12ca">s_null</a></td></tr>
<tr class="memdesc:affa8f755d9d067272e72b619ea1c12ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty variant, the same as NULL for pointers. <br /></td></tr>
<tr class="separator:affa8f755d9d067272e72b619ea1c12ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Variant data type, where the particular value type is dynamically determined at runtime. </p>
<p>The uninitialized variant variable would be of empty type, and should not participate in operations other than the assignment into it, or an exception is thrown. When performing value based operations, the class performs type conversions. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8756bf657736cb48a0e46012354172fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">MVariant::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible value types, sorted in the order of their promotional conversion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba3155ed3e3de66143efd2f31fe1bb00c7"></a>VAR_EMPTY&#160;</td><td class="fielddoc">
<p>No value in the variant. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba8bc00b670a68d47750b994b6a9781eab"></a>VAR_BOOL&#160;</td><td class="fielddoc">
<p>Variant has Boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba74ba28367c7f304ead25ea8c3abb0e1f"></a>VAR_BYTE&#160;</td><td class="fielddoc">
<p>Variant has Byte value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fbafc0efef59e124f99353c8c2b741ccc93"></a>VAR_CHAR&#160;</td><td class="fielddoc">
<p>Variant has Character value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fbae105635606f4ad9cd5c021b874352c6f"></a>VAR_UINT&#160;</td><td class="fielddoc">
<p>Variant has unsigned integer value. Its conversion rate is smaller than INT, not like in C. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fbae996a7ccdb59d1df196bda97683315c0"></a>VAR_INT&#160;</td><td class="fielddoc">
<p>Variant has integer value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba053cdbd4c8d0876bd861d9518a576b02"></a>VAR_DOUBLE&#160;</td><td class="fielddoc">
<p>Variant has double value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba8ad6ed215c522ff8a7fd91df3cddeb94"></a>VAR_BYTE_STRING&#160;</td><td class="fielddoc">
<p>Variant has the byte string. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fbaae5e54d615520fad1d1504c87a1bc27d"></a>VAR_STRING&#160;</td><td class="fielddoc">
<p>Variant has string value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba93ad8e71f79e6f827053bd4033cb3a14"></a>VAR_STRING_COLLECTION&#160;</td><td class="fielddoc">
<p>Variant has string collection value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba7b28d181de01f302ea11c922a58fd862"></a>VAR_OBJECT&#160;</td><td class="fielddoc">
<p>Variant has an object. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba3c99a1bdf4bbcdaa793c9ea40907481e"></a>VAR_OBJECT_EMBEDDED&#160;</td><td class="fielddoc">
<p>Object, embedded into the variant, can be copied with memory copy operation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fbab7e417ad36403c6d8f73379ee9fb8a2f"></a>VAR_VARIANT_COLLECTION&#160;</td><td class="fielddoc">
<p>Array of any type of elements, array of variants. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fba87ba3709865371ba4f8f0ea3c9f7976d"></a>VAR_MAP&#160;</td><td class="fielddoc">
<p>Map of key:value pairs, both are variants. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8756bf657736cb48a0e46012354172fbae2fbb184f69387f36806ce51db7734f9"></a>VAR_VARIANT&#160;</td><td class="fielddoc">
<p>Variant type by itself. Used externally by applications to denote variant as the whole type. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a897113c03a80b7547b5386d6772951e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type string with the value specified as the constant character pointer. </p>

</div>
</div>
<a class="anchor" id="af165410365af925576d7f2e5ffc180e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_variant.html#a66a51a803ca6662b3784ea1623d634d7">AcceptStringType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type string with the value specified as the constant character pointer. </p>

</div>
</div>
<a class="anchor" id="ad6c0c9568cde2f92f1a29460891e3426"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type string with the value specified as the constant character pointer. </p>

</div>
</div>
<a class="anchor" id="a494f9803a5be65262669555f4d8d441d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_variant.html#a66a51a803ca6662b3784ea1623d634d7">AcceptStringType</a>&#160;</td>
          <td class="paramname"> = <code>ACCEPT_STRING</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type string with the value specified as the constant character pointer. </p>

</div>
</div>
<a class="anchor" id="ac506a387a07c30745b6acaf1107b9658"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga7efa11b093245ad26d7897d8c87f90f5">MWideString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type string with the value specified as the constant character pointer. </p>

</div>
</div>
<a class="anchor" id="aa06afd34bdacca7941719bbd137ff4cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the value of type string with the value specified as MStdString. </p>
<p>Note that MByteString might have the same implementation as MStdString, and it would be not obvious that the constructor from byte string creates the variant with type VAR_STRING. </p>

</div>
</div>
<a class="anchor" id="a4a53086b24d779c60a543257b0052b54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type byte string, with the value specified as the constant pointer with length. Note that this is the way to create a variant of type VAR_BYTE_STRING with the non-copy constructor. This is because the implementation with MStdString might be the same as one of MByteString. </p>

</div>
</div>
<a class="anchor" id="a1287489df2991aa103833b058c00181d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const Muint8 *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the value of type byte string, with the value specified as the constant pointer with length. Note that this is the way to create a variant of type VAR_BYTE_STRING with the non-copy constructor. This is because the implementation with MStdString might be the same as one of MByteString. </p>

</div>
</div>
<a class="anchor" id="af918c4b673564ed2c3311ec9824b6b54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_variant.html#aaaae155d0949b43a16647cbb24179759">AcceptByteStringType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the value of type byte string, giving the byte string as first parameter. </p>
<p>The second parameter should always be MVariant::ACCEPT_BYTE_STRING. Note that this is the way to create a variant of type VAR_BYTE_STRING with the non-copy constructor. This is because the implementation with MStdString might be the same as one of MByteString. </p>

</div>
</div>
<a class="anchor" id="a0c4d24640cf80103c9f7d42e8906cfa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_variant.html#a553204ca98f00d04c8f3dca3caca432c">AcceptByteStringCollectionType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the value of type byte string vector, giving the byte string vector as first parameter. </p>
<p>The second parameter should always be MVariant::ACCEPT_BYTE_STRING_VECTOR. The internal representation of a byte string vector is a variant collection. </p>

</div>
</div>
<a class="anchor" id="a2bd057fa15f7fd73072dde10c56c993a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_object.html">MObject</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the value of type object, which references the object given. </p>
<p>Note that the variant does not own the object, and it is the responsibility of the application to ensure that the object is not discarded before its reference. </p>

</div>
</div>
<a class="anchor" id="a7d4261b3d144547f9aa41d9de9abc29c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const C *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_variant.html#a2d8cadf5ff38042e6ada9c9889fbfc66">AcceptObjectEmbedded</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the embedded object to the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given embedded object shall be nonzero, or there is a debug check. </dd></dl>

</div>
</div>
<a class="anchor" id="a197e461c84d60c0c0a89a473ae674fed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MVariant::MVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the value from the copy. </p>
<p>Initialize the object with the attributes of the other object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a35a4ff26d51edd66fb9ac167afd07f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::AccessItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access constant element by index, efficient call.</p>
<p>This is the same as GetItem, but it works only for variant collection and a map. Constant reference is returned, therefore, it is more efficient than GetItem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbe9345270116e3b4d04cd186952217f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::AccessItem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access constant element by index, efficient call.</p>
<p>This is the same as GetItem, but it works only for variant collection and a map. Constant reference is returned, therefore, it is more efficient than GetItem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8bff0a7037930ce498d848c63d67c9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::AccessItem </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access constant element by index, efficient call.</p>
<p>This is the same as GetItem, but it works only for variant collection and a map. Constant reference is returned, therefore, it is more efficient than GetItem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bbca768096633250fa2c79e9de60b10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::AccessItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access constant element by index, efficient call.</p>
<p>This is the same as GetItem, but it works only for variant collection and a map. Constant reference is returned, therefore, it is more efficient than GetItem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0330f5b334e29bf9b9f48d980d141af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::AccessItem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access constant element by index, efficient call.</p>
<p>This is the same as GetItem, but it works only for variant collection and a map. Constant reference is returned, therefore, it is more efficient than GetItem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a83b6e70c8864fc353e18f5791d16d867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::AccessItem </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access constant element by index, efficient call.</p>
<p>This is the same as GetItem, but it works only for variant collection and a map. Constant reference is returned, therefore, it is more efficient than GetItem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#aabc94e3694076fe328620a087e702ed0">GetItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14f2f9d1a99195a9e3402ec4da62787d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::AddToVariantCollection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the given variant as a whole to the collection. </p>
<p>This call is different from operator+=, as it does not unroll the collection items if the given parameter is a collection.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type of the variant shall be VARIANT_COLLECTION, there is a debug check. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7c25534c820d89ba64f625f5455a6ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MVariant::AdjustIndex </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust a given index so the negative index will mean counting from the end of the array. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The index shall be in range -count to count - 1, where count is a signed integer, otherwise an exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a412cf1a1b3f265adfe8572b67af6bc8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int MVariant::AdjustSlice </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust a given slice so the negative index will mean counting from the end of the array. </p>
<p>A negative slice will mean no elements.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Slice is always adjusted correctly. </dd></dl>

</div>
</div>
<a class="anchor" id="ae62092e72736d30c8ac9e3616d248b0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::AsBool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as type bool, if possible. </p>
<p>The type of the value should allow conversion of it into boolean. It should either be boolean itself, or numeric. If the value is numeric, nonzero would mean TRUE. Also, string, byte string, and string collection, if empty, will yield to False. If they are not empty, their conversion to Long will be attempted as the result compared with zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. If the current value is of incompatible type, bad conversion is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a32cf57642cf3859006b01f408e8f0d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint8 MVariant::AsByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as byte, if possible. </p>
<p>The type of the value should fit within one byte.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a53150ff574068ff61f61e2473d5908ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MVariant::AsByteString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as byte string, if possible. </p>
<p>The only value that cannot be interpreted as byte string is an empty value.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eb99170106c9b09666f0e2b50495767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> MVariant::AsByteStringCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as byte string collection, if possible. </p>
<p>The only value that cannot be interpreted as string is an empty value. For the rest, AsByteString is attempted for each element.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5811ff34f6a7f4964db18e7da7db2e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga1976cff572b7c48d658f604b87764853">MChar</a> MVariant::AsChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as type MChar, if possible. </p>
<p>The type of the value should allow conversion of it into MChar. It should either be VAR_CHAR itself, or it should be numeric with the allowed range, or it should be a string with the size 1.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d72bed00c7f1c47eb70a1b121824b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* MVariant::AsConstChars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret string related values of this variant as zero terminated string. </p>
<p>The type of the value should only be a string, a byte string, a char, or a byte.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. If the current value is of incompatible type, bad conversion is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2670788bbde43329396519580a6407d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MVariant::AsDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as double precision floating point, if possible. </p>
<p>The type of the value should allow conversion of it into double precision floating point. If this is the string, the string has to be the valid string representation of double precision number.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a884c6eeb62e155138e72e5536eccfc68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint32 MVariant::AsDWord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as double word. </p>
<p>This service is like AsInt or AsUInt, but it will ignore the sign and never throw an exception or overflow.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a32a4c4c2abcbfa4c97f3e92c21fb1e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MVariant::AsEscapedString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as a string with C escapes, if possible. </p>
<p>The only value that cannot be interpreted as string is an empty value. If the variant is an object, its AsString method is called, then converted to escaped string. For Boolean value, its string representations are numeric: 1 or 0.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa5f538393249ee879c4100d7136690d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_object.html">MObject</a>* MVariant::AsExistingObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpret the variant value as an existing non-NULL object reference, if possible. The only value that can be interpreted as object is an object itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An exception is thrown in case the value is not of type object. If the object is NULL, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a15ee77c8c0bad534467bdb1c3654ed88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_object.html">MObject</a>* MVariant::AsExistingObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpret the variant value as an existing non-NULL object reference, if possible. The only value that can be interpreted as object is an object itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An exception is thrown in case the value is not of type object. If the object is NULL, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a57be6dc2d3d003559eeeb7c521d6d9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MVariant::AsInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as integer type, if possible. </p>
<p>The type of the value should allow conversion of it into integer. The numeric type has to fit within the range of integer, and the string has to be the valid string representation of integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="ade9aea379dfcc63bcc9618f76f696770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mint64 MVariant::AsInt64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as 64-bit integer type, if possible. </p>
<p>The type of the value should allow conversion of it into 64-bit integer. The numeric type has to fit within the range of 64-bit integer, and the string has to be the valid string representation of such integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a50bfd03872fa514ecf767184d5e71f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long MVariant::AsLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the variant value as long integer type, if possible. </p>
<p>The type of the value should allow conversion of it into long integer. The numeric type has to fit within the range of integer, and the string has to be the valid string representation of long integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="af0d3eec551c4884a502263c57da8e4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_object.html">MObject</a>* MVariant::AsObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpret the variant value as object reference, if possible. The only value that can be interpreted as object is an object itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An exception is thrown in case the value is not of type object. </dd></dl>

</div>
</div>
<a class="anchor" id="a48827945a271aee26a13c8fa0b9ce039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_object.html">MObject</a>* MVariant::AsObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpret the variant value as object reference, if possible. The only value that can be interpreted as object is an object itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An exception is thrown in case the value is not of type object. </dd></dl>

</div>
</div>
<a class="anchor" id="a2928059cffeba9b94aa751e90c05a803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MSharedString MVariant::AsSharedString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as shared string, if possible. </p>
<p>The only value that cannot be interpreted as shared string is an empty value. If the variant is an object, its AsString method is called. For Boolean value, its string representations are numeric: 1 or 0.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="abf3d0c350d70112d0e8b708c469c9aa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::AssignObjectEmbedded </td>
          <td>(</td>
          <td class="paramtype">const C *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the byte embedded object to the variant type. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given object value is not null, there is a debug check. </dd></dl>

</div>
</div>
<a class="anchor" id="accf9067e2ffa684230fac074ce05ec5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MVariant::AsSizeT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the variant value as an integer type equivalent to size_t, if possible. </p>
<p>The type of the value should allow conversion of it into size_t. The numeric type has to fit within the range of size_t, and the string has to be the valid string representation of size_t.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab01bb59ad807fbfeb554304e8a07d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MVariant::AsString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as string, if possible. </p>
<p>The only value that cannot be interpreted as string is an empty value. If the variant is an object, its AsString method is called. For Boolean value, its string representations are numeric: 1 or 0.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a612a41aa9c193bc93f320e67df041a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MVariant::AsString </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as string, if possible, using mask that specifies the conversions to make. </p>
<p>The only value that cannot be interpreted as string is an empty value. If the variant is an object, its AsString method is called. For Boolean value, its string representations are numeric: 1 or 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The mask of type MStr::Mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a82b74d0cdf67b360ef93919455a1c4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a> MVariant::AsStringCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as string collection, if possible. </p>
<p>The string collection returns directly. The only value that cannot be interpreted as string is an empty value. For the rest, AsString is attempted and the resulting collection will have only one string in it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e904ee893f54df1c2323ad483d9234b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MVariant::AsUInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as unsigned integer type, if possible. </p>
<p>The type of the value should allow conversion of it into unsigned integer. The numeric type has to fit within the range of integer, and the string has to be the valid string representation of unsigned integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="a67b5fc164d7e491b956ba9cf043b2321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint64 MVariant::AsUInt64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as unsigned long integer type, if possible. </p>
<p>The type of the value should allow conversion of it into unsigned long integer. The numeric type has to fit within the range of integer, and the string has to be the valid string representation of unsigned long integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="afb6094597b2bd8d346c74dff954dcd99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MVariant::AsULong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the variant value as unsigned long integer type, if possible. </p>
<p>The type of the value should allow conversion of it into unsigned long integer. The numeric type has to fit within the range of integer, and the string has to be the valid string representation of unsigned long integer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The conversion should be possible. Bad conversion can be thrown in cases such as the type is incompatible or the range is bad. </dd></dl>

</div>
</div>
<a class="anchor" id="aadd2f98a128cfc2e99728732d06fdb86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">VariantVector</a> MVariant::AsVariantCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpret the variant value as variant collection, if possible. </p>
<p>The variant collection returns directly. The only value that cannot be interpreted as variant is an empty value. For the rest, the resulting collection will have only one element.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the value of the variant is not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a59fcc93e4880feab8b4236ef2b0bb962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MVariant::FindIndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index of the given element in the indexed variant. </p>
<p>If there is no such item, -1 is returned.</p>
<p>If this variant is a map, this method returns ordinal index of the given key.</p>
<p>If this variant is a collection of any kind, index of element is returned. </p>

</div>
</div>
<a class="anchor" id="acd2cb632ca131dc17e098ae6a65ee827"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::GetAllMapKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a variant vector of keys in this map. </p>
<p>Keys are unique in the result collection.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The object should be of map type, or an error is thrown.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Variant of type collection of objects, possibly empty.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#a69469e41db28f90de47acec598c99be3" title="Return a variant vector of values in this map. ">GetAllMapValues</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a69469e41db28f90de47acec598c99be3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::GetAllMapValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a variant vector of values in this map. </p>
<p>Values are not necessarily unique, and therefore the count of values returned is the same as the count of keys of the same map.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The object should be of map type, or an error is thrown.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Variant of type collection of objects, possibly empty.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_variant.html#acd2cb632ca131dc17e098ae6a65ee827" title="Return a variant vector of keys in this map. ">GetAllMapKeys</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae35ba74ba664891580be8be0ad6490dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MVariant::GetCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count of elements in the variant, if they can be indexed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>IsIndexed should be true, or the attempt to use this operation will cause an exception to be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aabc94e3694076fe328620a087e702ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::GetItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get element by index. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name Item. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aac002f07ed0cbbe0793d29aa245b8505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::GetItem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get element by index. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name Item. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a873d97f005b395038822fb7293a55368"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::GetItem </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get element by index. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name Item. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a245f6f830f743384f5248d4e68277f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::GetMapKeyByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a key in the map by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index in range 0 .. GetCount.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key with the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="ad531ecad85510168ac1ddb472a5ee480"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::GetMapValueByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a key in the map by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index in range 0 .. GetCount.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value with the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d1503ecea600b4ad215d6fd1d30794f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::GetSlice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the slice of values for types that support subscripts. </p>
<p>One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name SetItem. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b331de209f1dd70ff74635c26d9cbe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::IsNumeric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the variant is of numeric type, so the arithmetic operations can be performed. </p>
<p>The following types are arithmetic: VAR_BOOL, VAR_CHAR, VAR_INT, VAR_UINT, and VAR_DOUBLE. Empty and string types are not numeric. </p>

</div>
</div>
<a class="anchor" id="a34ac5f7c76ec24550a294701414d49ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::IsPresent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given item is in the variant. </p>
<p>If this variant is a map, this method checks if the given key is present.</p>
<p>If this variant is a collection of any kind, true will mean the parameter is contained it in.</p>
<p>It does not matter how many duplicate items are present in either of the values. </p>

</div>
</div>
<a class="anchor" id="abfe316f92b8f84aa1f0545b8af01acd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::MoveFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast method that moves the value to another variant, and sets the other variant type to Empty. </p>
<p>This is possible only because variant values can always be moved. </p>

</div>
</div>
<a class="anchor" id="a04043791ccbb040f52f6935927ed3d4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary operator NOT. </p>
<p>Note that there is no difference between logical NOT and bitwise NOT. Logical NOT is applied for bool operands, and the resulting value is bool. For all the other numeric values the bitwise NOT is performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be convertible to either bool or unsigned integer. Otherwise a bad conversion exception is raised. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d117e0d643851c216d0cecddf5a40d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_m_variant.html#a04043791ccbb040f52f6935927ed3d4d">MVariant::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0f2fa82538227eaf1135c5dc18f798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary modulus operator. </p>
<p>Applicable for numerics only. Modulus produces a reminder value from the division operator if both arguments are positive.</p>
<p>First the conversion is applied. Preconditions apply for the conversion. The converted values should be of numeric type.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation (be numeric). Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. If the second argument is zero, the Division By Zero exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ada7f6056b4a85b486c0069386ef34cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator modulus self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b377ff1a974696f839dbacba4d4e10e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator AND. </p>
<p>Standard conversions apply. Note that there is no difference between logical AND and bitwise AND. Logical AND is applied for bool operands, and the resulting value is bool. For all the other numeric values the bitwise AND is performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The operand types should be convertible to BOOL or numeric. Otherwise a bad conversion exception is raised. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a96a149d15dca98e27bb5d243347bf73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator, binary or logical 'and' of self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a6755a03342771c59c5c02e3c5d21c5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary multiplication operator. </p>
<p>Applicable for numerics or sets only.</p>
<p>First the conversion is applied. Preconditions apply for the conversion. The converted values should be of numeric type.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="af9fed1af5245d3178485811321b5c654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator multiply self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a402412b9de6d2792470c1c91a7e1c27c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator plus. </p>
<p>The interpretation depends on the context.</p>
<p>First the conversion is applied. Preconditions apply for the conversion. If the converted values are of type TYPE_STRING, then the strings are concatenated. If the converted values are of the numeric type, the values are added. The result value is returned, and this object is not changed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a41a7c32da760eb711e8545e1d1abf136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix increment operator. </p>
<p>It never attempts to change the type of this variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow incrementing, which means it is numeric. Otherwise the exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aebfdf21c8474dd6073cdc651d0adc898"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator increment self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="af2581b210ee1c531a4445367de7afe64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary operator minus. </p>
<p>Please note that the unary operator plus is not defined for <a class="el" href="class_m_variant.html" title="Variant data type, where the particular value type is dynamically determined at runtime. ">MVariant</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. It should be arithmetic. Otherwise a bad conversion exception is raised. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a00aee340143b96b6d86ba0e7a7c9fb9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator minus. </p>
<p>Applicable for numerics or sets only.</p>
<p>First the conversion is applied. Preconditions apply for the conversion. The converted values should be of numeric type.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7fb03b48fa43e360dee4a52824e66b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix decrement operator. </p>
<p>It never attempts to change the type of this variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow incrementing, which means it is numeric. Otherwise the exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ed243e52cce7d1eab663363afe67686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator decrement self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a4af2bb85c185500163329bcc06fb190b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary division operator. </p>
<p>Applicable for numerics only.</p>
<p>First the conversion is applied. Preconditions apply for the conversion. The converted values should be of numeric type.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation, which means to be convertible to numeric type. Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. If the second argument is zero, the Division By Zero exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a59f3a568eb4659c0cc3f12adf2185b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator divide self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ad73ac2f2e81395d955f4e41a4af11f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a17b73767ea96569dc5749e2c366e227f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise left shift operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation, which means to be numeric. Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a00cd4c9d4d6f87d6536f4901ad7c8f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator left shift self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ad769a4b62d1533fe1aee9e2c60fbcc9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a45edfc0a713195dab465502aa4134903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_object.html">MObject</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator that takes variable of type <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>. </p>
<p>Note that the variant does not own the object, and it is the responsibility of the application to ensure that the object is not discarded before its reference. </p>

</div>
</div>
<a class="anchor" id="aed6911af9d20b70ca576a1d38cb13b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="afdb4dd10f9cabee1565dfe5f8385d619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="aa00d8323e65b1e246b2297d4f6476247"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MVariant::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ad61762613c09a4fce083c42ef4ed1047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise right shift operator. </p>
<p>Standard conversions apply.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation, which means to be numeric. Otherwise the conversion exception is thrown. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a14d98b382b2dddb8b73f19ac4ad0be33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator right shift self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="af463241a52645d919448418d4394cdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator XOR. </p>
<p>Standard conversions apply. Note that there is no difference between logical XOR and bitwise XOR. Logical XOR is applied for bool operands, and the resulting value is bool. For all the other numeric values the bitwise XOR is performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The operand types should be convertible to BOOL or numeric. Otherwise a bad conversion exception is raised. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ac184d79d3e948381303b3bdd8d0e79b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator, binary or logical 'xor' of self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a985d1b79098278489affa5f7e2be6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator OR. </p>
<p>Standard conversions apply.</p>
<p>Note that there is no difference between logical OR and bitwise OR. Logical OR is applied for bool operands, and the resulting value is bool. For all the other numeric values the bitwise OR is performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The operand types should be convertible to BOOL or numeric. Otherwise a bad conversion exception is raised. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a66f0f3c7c097957a47373158ab3c3ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a>&amp; MVariant::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary operator, binary or logical 'or' of self by value. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the operation. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c21ead46c8019205062835d8fd35598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_variant.html">MVariant</a> MVariant::Pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return this object with the power of the object given. </p>
<p>The power type returned is always DOUBLE.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should be compatible with the power operation. The compatible types are those that can be cast to DOUBLE. If not, the bad conversion is thrown. If any of the values are not initialized, the No Value exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a20523aae0912472603b9b0bfd09858d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::ReserveElements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve the number of elements in the variant when variant is indexed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements to reserve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The variant type should be indexed. </dd></dl>

</div>
</div>
<a class="anchor" id="aed6f6900b7f80150e39c6d03c8e7d446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count of elements in the variant, if they can be indexed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>IsIndexed should be true, or the attempt to use this operation will cause an exception to be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f6ad7a90aa701022988637ec1cf095e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetEmptyWithObjectDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the value of the variant type, and if it is an object, delete it. </p>
<p>This corresponds to a concept of owned variant. </p>

</div>
</div>
<a class="anchor" id="a27dd698914c2a851054076ef263b5448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set element by index. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name SetItem. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a97e382028084131560bc7fdf87a6b5a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetItem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set element by index. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name SetItem. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a9acfffd994fc561b13220397f06bc527"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetItem </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set element by index. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name SetItem. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec74022c498995e1eda089c5bd42da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetSlice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the slice of values for types that support subscripts. </p>
<p>Shrink or grow the number of items if necessary. One can check IsIndexed property to know if the variant can be indexed. Also there is a GetCount, which is callable only for IsIndexed, and will return the number of items in the variant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. If an item is an object, it shall have a reflected service with the name SetItem. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a977933d4130faca1b2e76e3ba60246d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SetToNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_variant.html#a8756bf657736cb48a0e46012354172fb">MVariant::Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the value of the variant type, and set it to null, either empty or zero value depending on the given type. </p>
<p>The null value will depend on the given type. For string it is an empty string, and for an integer it is zero. If no parameter is given, the type is preserved while its value becomes NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to use to set the value to null, where the type determines whether that is an empty or zero value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8521343c35049ca6f0b3dea469c8bcf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MVariant::StaticIsObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> *&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the pointer to variant is an object reference.</p>
<p>Different from just var-&gt;IsObject, this call checks if the variable is not NULL. The call that mentions reference avoids a problem when newer C++ compilers assume that object reference is never NULL. </p>

</div>
</div>
<a class="anchor" id="ae47bf59ef6c8ae153239b240308798d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MVariant::StaticIsObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_variant.html">MVariant</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the pointer to variant is an object reference.</p>
<p>Different from just var-&gt;IsObject, this call checks if the variable is not NULL. The call that mentions reference avoids a problem when newer C++ compilers assume that object reference is never NULL. </p>

</div>
</div>
<a class="anchor" id="adc03c44754452635e8c22569e7faa76a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MVariant::SwapItems </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two indexed items in the array or collection. </p>
<p>As the result of the operation, this variant will have two items with such indexes swapped. Index adjustments are performed according to standard rules, such as -1 will mean the last element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index1</td><td>Index of the first item with which to perform a swap.</td></tr>
    <tr><td class="paramname">index2</td><td>Index of the second item with which to perform a swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type should allow integer subscripting, such as VAR_STRING, VAR_BYTE_STRING or VAR_STRING_COLLECTION. Otherwise the conversion exception is thrown. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_variant.html">MVariant</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
