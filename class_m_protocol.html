<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C12Adapter Opensource C++ Interface: MProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C12Adapter Opensource C++ Interface
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_m_protocol.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_m_protocol-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MProtocol Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___m_c_o_m.html">MCOM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstraction of a communication protocol.  
 <a href="class_m_protocol.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MProtocol:</div>
<div class="dyncontent">
<div class="center"><img src="class_m_protocol__inherit__graph.png" border="0" usemap="#_m_protocol_inherit__map" alt="Inheritance graph"/></div>
<map name="_m_protocol_inherit__map" id="_m_protocol_inherit__map">
<area shape="rect" id="node4" href="class_m_protocol_c12.html" title="Generic ANSI C12 abstract protocol, base for C12.18, C12.21, and C12.22. " alt="" coords="83,229,187,256"/>
<area shape="rect" id="node2" href="class_m_c_o_m_object.html" title="Root communication object that defines default property handling and configuration location..." alt="" coords="85,80,186,107"/>
<area shape="rect" id="node3" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars..." alt="" coords="100,5,171,32"/>
<area shape="rect" id="node5" href="class_m_protocol_c1218.html" title="ANSI C12 18 protocol implementation, a further specialization of C12 set of protocols. " alt="" coords="5,304,124,331"/>
<area shape="rect" id="node7" href="class_m_protocol_c1222.html" title="ANSI C12.22 protocol implementation. " alt="" coords="148,304,267,331"/>
<area shape="rect" id="node6" href="class_m_protocol_c1221.html" title="ANSI C12.21 protocol implementation. " alt="" coords="5,379,124,405"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_protocol_1_1_table_raw_data.html">TableRawData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table raw data associated with the table number.  <a href="struct_m_protocol_1_1_table_raw_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acb2efd86856570ae339320ade2841e70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a7df75f2423de285046975aa2c250fa06">MAXIMUM_NUMBER_STRING_SIZE</a> = 64, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70acd2b89f18226e2b07f46691300abae70">MAXIMUM_SERVICE_NAME_STRING_SIZE</a> = MAXIMUM_NUMBER_STRING_SIZE + 64, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a> = 0x1000, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a7a2476e18495e7f0be160468bfea5d73">MAXIMUM_POSSIBLE_TABLE_OFFSET</a> = 0xFFFFFF, 
<br />
&#160;&#160;<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70a955afe7a1975e8484755ee30010fa6a1">MAXIMUM_POSSIBLE_TABLE_LENGTH</a> = 0xFFFFFF
<br />
 }</td></tr>
<tr class="separator:acb2efd86856570ae339320ade2841e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48fb8eb277613de30019f264fdeb271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad48fb8eb277613de30019f264fdeb271"></a>
typedef std::vector&lt; <a class="el" href="struct_m_protocol_1_1_table_raw_data.html">TableRawData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a></td></tr>
<tr class="memdesc:ad48fb8eb277613de30019f264fdeb271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of table raw data. <br /></td></tr>
<tr class="separator:ad48fb8eb277613de30019f264fdeb271"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c41fddbb0e3418dc453981c6136028a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_protocol.html">MProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2c41fddbb0e3418dc453981c6136028a">CreateClone</a> () const </td></tr>
<tr class="memdesc:a2c41fddbb0e3418dc453981c6136028a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual copy constructor, creates the protocol which is a clone of current.  <a href="#a2c41fddbb0e3418dc453981c6136028a">More...</a><br /></td></tr>
<tr class="separator:a2c41fddbb0e3418dc453981c6136028a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86685e09ca825849a21b6818c0d2115e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a86685e09ca825849a21b6818c0d2115e">~MProtocol</a> ()=0</td></tr>
<tr class="memdesc:a86685e09ca825849a21b6818c0d2115e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the protocol object.  <a href="#a86685e09ca825849a21b6818c0d2115e">More...</a><br /></td></tr>
<tr class="separator:a86685e09ca825849a21b6818c0d2115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6479689e3e13a1a11a34b64da99f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a3a6479689e3e13a1a11a34b64da99f51">Finalize</a> ()</td></tr>
<tr class="memdesc:a3a6479689e3e13a1a11a34b64da99f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute this method as first action in the destructor of any child protocol.  <a href="#a3a6479689e3e13a1a11a34b64da99f51">More...</a><br /></td></tr>
<tr class="separator:a3a6479689e3e13a1a11a34b64da99f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367a451ecf3e98ef7363fa98e53e6add"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a367a451ecf3e98ef7363fa98e53e6add">GetCountApplicationLayerServicesSuccessful</a> () const </td></tr>
<tr class="memdesc:a367a451ecf3e98ef7363fa98e53e6add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have been successfully processed.  <a href="#a367a451ecf3e98ef7363fa98e53e6add">More...</a><br /></td></tr>
<tr class="separator:a367a451ecf3e98ef7363fa98e53e6add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25fc291953561e4eb248174bc07856e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af25fc291953561e4eb248174bc07856e">IncrementCountApplicationLayerServicesSuccessful</a> ()</td></tr>
<tr class="memdesc:af25fc291953561e4eb248174bc07856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services successfully processed.  <a href="#af25fc291953561e4eb248174bc07856e">More...</a><br /></td></tr>
<tr class="separator:af25fc291953561e4eb248174bc07856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab290272e66fd881e1d67010d44451376"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab290272e66fd881e1d67010d44451376">GetCountApplicationLayerServicesRetried</a> () const </td></tr>
<tr class="memdesc:ab290272e66fd881e1d67010d44451376"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have been retried.  <a href="#ab290272e66fd881e1d67010d44451376">More...</a><br /></td></tr>
<tr class="separator:ab290272e66fd881e1d67010d44451376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c110d281bbb7779b7bbbfc12b5b1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae57c110d281bbb7779b7bbbfc12b5b1d">IncrementCountApplicationLayerServicesRetried</a> ()</td></tr>
<tr class="memdesc:ae57c110d281bbb7779b7bbbfc12b5b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services retried.  <a href="#ae57c110d281bbb7779b7bbbfc12b5b1d">More...</a><br /></td></tr>
<tr class="separator:ae57c110d281bbb7779b7bbbfc12b5b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ad7accc31c929f4a4b8ff4fbc13549"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a17ad7accc31c929f4a4b8ff4fbc13549">GetCountApplicationLayerServicesFailed</a> () const </td></tr>
<tr class="memdesc:a17ad7accc31c929f4a4b8ff4fbc13549"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Application Layer services that have failed.  <a href="#a17ad7accc31c929f4a4b8ff4fbc13549">More...</a><br /></td></tr>
<tr class="separator:a17ad7accc31c929f4a4b8ff4fbc13549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bffec5063153017e67fdd4d667f5cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a60bffec5063153017e67fdd4d667f5cb">IncrementCountApplicationLayerServicesFailed</a> ()</td></tr>
<tr class="memdesc:a60bffec5063153017e67fdd4d667f5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of application layer services failed.  <a href="#a60bffec5063153017e67fdd4d667f5cb">More...</a><br /></td></tr>
<tr class="separator:a60bffec5063153017e67fdd4d667f5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ba7737c1a7033a784e732539fd442"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a425ba7737c1a7033a784e732539fd442">GetCountLinkLayerPacketsSuccessful</a> () const </td></tr>
<tr class="memdesc:a425ba7737c1a7033a784e732539fd442"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Link Layer packets that have been successfully processed.  <a href="#a425ba7737c1a7033a784e732539fd442">More...</a><br /></td></tr>
<tr class="separator:a425ba7737c1a7033a784e732539fd442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735e02e29d2dd177059a8cdc15eb6a71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a735e02e29d2dd177059a8cdc15eb6a71">IncrementCountLinkLayerPacketsSuccessful</a> ()</td></tr>
<tr class="memdesc:a735e02e29d2dd177059a8cdc15eb6a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets successfully processed.  <a href="#a735e02e29d2dd177059a8cdc15eb6a71">More...</a><br /></td></tr>
<tr class="separator:a735e02e29d2dd177059a8cdc15eb6a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab563dd4909235f42bf80bd5a7d77e05b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab563dd4909235f42bf80bd5a7d77e05b">GetCountLinkLayerPacketsRetried</a> () const </td></tr>
<tr class="memdesc:ab563dd4909235f42bf80bd5a7d77e05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Link Layer packets that have been retried.  <a href="#ab563dd4909235f42bf80bd5a7d77e05b">More...</a><br /></td></tr>
<tr class="separator:ab563dd4909235f42bf80bd5a7d77e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970a90af9476866a8e6b39dbef89c627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a970a90af9476866a8e6b39dbef89c627">IncrementCountLinkLayerPacketsRetried</a> ()</td></tr>
<tr class="memdesc:a970a90af9476866a8e6b39dbef89c627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets retried.  <a href="#a970a90af9476866a8e6b39dbef89c627">More...</a><br /></td></tr>
<tr class="separator:a970a90af9476866a8e6b39dbef89c627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d9dd2722b89549334dbf3ea785052a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80d9dd2722b89549334dbf3ea785052a">GetCountLinkLayerPacketsFailed</a> () const </td></tr>
<tr class="memdesc:a80d9dd2722b89549334dbf3ea785052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of data link layer packets failed.  <a href="#a80d9dd2722b89549334dbf3ea785052a">More...</a><br /></td></tr>
<tr class="separator:a80d9dd2722b89549334dbf3ea785052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c162f21b2b82300532288a630238cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0c162f21b2b82300532288a630238cbd">IncrementCountLinkLayerPacketsFailed</a> ()</td></tr>
<tr class="memdesc:a0c162f21b2b82300532288a630238cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of data link layer packets failed.  <a href="#a0c162f21b2b82300532288a630238cbd">More...</a><br /></td></tr>
<tr class="separator:a0c162f21b2b82300532288a630238cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86283365bd46d047e5dbc0048b7b00cd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a> () const </td></tr>
<tr class="memdesc:a86283365bd46d047e5dbc0048b7b00cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum measured approximate packet round trip time over the link layer.  <a href="#a86283365bd46d047e5dbc0048b7b00cd">More...</a><br /></td></tr>
<tr class="separator:a86283365bd46d047e5dbc0048b7b00cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d1d46c353f5e4f8cac3bf8ed8dc7a2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a> () const </td></tr>
<tr class="memdesc:af1d1d46c353f5e4f8cac3bf8ed8dc7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum measured approximate packet round trip time over the link layer.  <a href="#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">More...</a><br /></td></tr>
<tr class="separator:af1d1d46c353f5e4f8cac3bf8ed8dc7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45ec72043fe42c32b414d1448fab12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a> () const </td></tr>
<tr class="memdesc:a9b45ec72043fe42c32b414d1448fab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the average measured approximate packet round trip time over the link layer.  <a href="#a9b45ec72043fe42c32b414d1448fab12">More...</a><br /></td></tr>
<tr class="separator:a9b45ec72043fe42c32b414d1448fab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d5080403580f3317fc9eade19882d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a02d5080403580f3317fc9eade19882d4">ClearPasswordList</a> ()</td></tr>
<tr class="memdesc:a02d5080403580f3317fc9eade19882d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the password list for the protocol to none, so the <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> property is used.  <a href="#a02d5080403580f3317fc9eade19882d4">More...</a><br /></td></tr>
<tr class="separator:a02d5080403580f3317fc9eade19882d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5483f327ca2dcb745fdb14494848fa01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5483f327ca2dcb745fdb14494848fa01">AddToPasswordList</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;password)</td></tr>
<tr class="memdesc:a5483f327ca2dcb745fdb14494848fa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a password to the password list.  <a href="#a5483f327ca2dcb745fdb14494848fa01">More...</a><br /></td></tr>
<tr class="separator:a5483f327ca2dcb745fdb14494848fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b038b23f879820284d27f3ecc3768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a699b038b23f879820284d27f3ecc3768">GetPasswordListSuccessfulEntry</a> () const </td></tr>
<tr class="memdesc:a699b038b23f879820284d27f3ecc3768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry, which was successfully tried with the meter.  <a href="#a699b038b23f879820284d27f3ecc3768">More...</a><br /></td></tr>
<tr class="separator:a699b038b23f879820284d27f3ecc3768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb502e0b67a62153f70d818e0fec138a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> ()</td></tr>
<tr class="memdesc:adb502e0b67a62153f70d818e0fec138a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the statistical data for the channel.  <a href="#adb502e0b67a62153f70d818e0fec138a">More...</a><br /></td></tr>
<tr class="separator:adb502e0b67a62153f70d818e0fec138a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5624fcd28fbc1d199dab3202220f75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0e5624fcd28fbc1d199dab3202220f75">ApplyChannelParameters</a> ()</td></tr>
<tr class="memdesc:a0e5624fcd28fbc1d199dab3202220f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the configuration of the channel in a way compatible with the protocol handshake sequence.  <a href="#a0e5624fcd28fbc1d199dab3202220f75">More...</a><br /></td></tr>
<tr class="separator:a0e5624fcd28fbc1d199dab3202220f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb24a5372b721c343add6ae803287e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94">Connect</a> ()</td></tr>
<tr class="memdesc:adb24a5372b721c343add6ae803287e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the channel and establishes the connection with the peer.  <a href="#adb24a5372b721c343add6ae803287e94">More...</a><br /></td></tr>
<tr class="separator:adb24a5372b721c343add6ae803287e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c328afee944e7e977092b8da2887f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8">Disconnect</a> ()</td></tr>
<tr class="memdesc:a72c328afee944e7e977092b8da2887f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Severs the connection between the computer and the end device.  <a href="#a72c328afee944e7e977092b8da2887f8">More...</a><br /></td></tr>
<tr class="separator:a72c328afee944e7e977092b8da2887f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c53c968bd097ffaddee8fb679a3f9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a26c53c968bd097ffaddee8fb679a3f9d">IsConnected</a> () const </td></tr>
<tr class="memdesc:a26c53c968bd097ffaddee8fb679a3f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the protocol is currently connected.  <a href="#a26c53c968bd097ffaddee8fb679a3f9d">More...</a><br /></td></tr>
<tr class="separator:a26c53c968bd097ffaddee8fb679a3f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290983a74af9495c1a5f66d7e1d4b823"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a> () const </td></tr>
<tr class="memdesc:a290983a74af9495c1a5f66d7e1d4b823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the protocol is in session.  <a href="#a290983a74af9495c1a5f66d7e1d4b823">More...</a><br /></td></tr>
<tr class="separator:a290983a74af9495c1a5f66d7e1d4b823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1a1eeb1e19a54b2061e276d7248556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_action.html">MProgressAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5f1a1eeb1e19a54b2061e276d7248556">CreateRootProgressAction</a> ()</td></tr>
<tr class="memdesc:a5f1a1eeb1e19a54b2061e276d7248556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create root of the progress actions hierarchy.  <a href="#a5f1a1eeb1e19a54b2061e276d7248556">More...</a><br /></td></tr>
<tr class="separator:a5f1a1eeb1e19a54b2061e276d7248556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace692f1af6dbb0a33512f5582adec430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_action.html">MProgressAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ace692f1af6dbb0a33512f5582adec430">GetLocalProgressAction</a> ()</td></tr>
<tr class="memdesc:ace692f1af6dbb0a33512f5582adec430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the currently preset local action in progress monitor.  <a href="#ace692f1af6dbb0a33512f5582adec430">More...</a><br /></td></tr>
<tr class="separator:ace692f1af6dbb0a33512f5582adec430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73d91a5b3aeec57221ca2ee0cdbef00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> () const </td></tr>
<tr class="memdesc:ac73d91a5b3aeec57221ca2ee0cdbef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not it is time to call QCommit(true) in order to sync with the background thread.  <a href="#ac73d91a5b3aeec57221ca2ee0cdbef00">More...</a><br /></td></tr>
<tr class="separator:ac73d91a5b3aeec57221ca2ee0cdbef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002f961375678606b6e281a624db996"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6002f961375678606b6e281a624db996">QIsBackgroundCommunicationProgressing</a> () const </td></tr>
<tr class="memdesc:a6002f961375678606b6e281a624db996"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the background communication is still progressing.  <a href="#a6002f961375678606b6e281a624db996">More...</a><br /></td></tr>
<tr class="separator:a6002f961375678606b6e281a624db996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35ae0e64619dfc237c154a44ec578c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> ()</td></tr>
<tr class="memdesc:ac35ae0e64619dfc237c154a44ec578c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines <a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> with the following <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> in case all commands in the queue have been sent.  <a href="#ac35ae0e64619dfc237c154a44ec578c1">More...</a><br /></td></tr>
<tr class="separator:ac35ae0e64619dfc237c154a44ec578c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918229482eba7cf7a7901dae6c3796cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> ()</td></tr>
<tr class="memdesc:a918229482eba7cf7a7901dae6c3796cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the commands in the queue, or cancel the ongoing background communication.  <a href="#a918229482eba7cf7a7901dae6c3796cb">More...</a><br /></td></tr>
<tr class="separator:a918229482eba7cf7a7901dae6c3796cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7480f82e6934a8535760cf325af5bb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7480f82e6934a8535760cf325af5bb35">QWriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a7480f82e6934a8535760cf325af5bb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the message to write to the Monitor log file to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a7480f82e6934a8535760cf325af5bb35">More...</a><br /></td></tr>
<tr class="separator:a7480f82e6934a8535760cf325af5bb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ade785b2e4da0b69c4aadeffc82942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">QConnect</a> ()</td></tr>
<tr class="memdesc:a68ade785b2e4da0b69c4aadeffc82942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a Connect command in the queue.  <a href="#a68ade785b2e4da0b69c4aadeffc82942">More...</a><br /></td></tr>
<tr class="separator:a68ade785b2e4da0b69c4aadeffc82942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474d3857824f0fa028644556d0a09ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a474d3857824f0fa028644556d0a09ca0">QDisconnect</a> ()</td></tr>
<tr class="memdesc:a474d3857824f0fa028644556d0a09ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a Disconnect command in the queue.  <a href="#a474d3857824f0fa028644556d0a09ca0">More...</a><br /></td></tr>
<tr class="separator:a474d3857824f0fa028644556d0a09ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c0c4e13e1a1a616be8ad1e4793290"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ace4c0c4e13e1a1a616be8ad1e4793290">QIdentifyMeter</a> ()</td></tr>
<tr class="memdesc:ace4c0c4e13e1a1a616be8ad1e4793290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an IdentifyMeter task in the queue.  <a href="#ace4c0c4e13e1a1a616be8ad1e4793290">More...</a><br /></td></tr>
<tr class="separator:ace4c0c4e13e1a1a616be8ad1e4793290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc217114a8b4928f6d62e13ebf826e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afc217114a8b4928f6d62e13ebf826e7f">QStartSession</a> ()</td></tr>
<tr class="memdesc:afc217114a8b4928f6d62e13ebf826e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a start session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#afc217114a8b4928f6d62e13ebf826e7f">More...</a><br /></td></tr>
<tr class="separator:afc217114a8b4928f6d62e13ebf826e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fc80e08ae3337deac67b5503ae7b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a> ()</td></tr>
<tr class="memdesc:aa1fc80e08ae3337deac67b5503ae7b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an end session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#aa1fc80e08ae3337deac67b5503ae7b77">More...</a><br /></td></tr>
<tr class="separator:aa1fc80e08ae3337deac67b5503ae7b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99c12375946ef53645de3b3807aa24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9b99c12375946ef53645de3b3807aa24">QEndSessionNoThrow</a> ()</td></tr>
<tr class="memdesc:a9b99c12375946ef53645de3b3807aa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">EndSessionNoThrow request is queued.  <a href="#a9b99c12375946ef53645de3b3807aa24">More...</a><br /></td></tr>
<tr class="separator:a9b99c12375946ef53645de3b3807aa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08880e3f2b73a5b0a099514b0a71c93f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a08880e3f2b73a5b0a099514b0a71c93f">QTableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, unsigned expectedSize, int id)</td></tr>
<tr class="memdesc:a08880e3f2b73a5b0a099514b0a71c93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a ReadTable command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a08880e3f2b73a5b0a099514b0a71c93f">More...</a><br /></td></tr>
<tr class="separator:a08880e3f2b73a5b0a099514b0a71c93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71251f6cbda5a70e1072e4cf78fcea5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a71251f6cbda5a70e1072e4cf78fcea5c">QTableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:a71251f6cbda5a70e1072e4cf78fcea5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a71251f6cbda5a70e1072e4cf78fcea5c">More...</a><br /></td></tr>
<tr class="separator:a71251f6cbda5a70e1072e4cf78fcea5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a88700905af18de1934453c800ae9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a36a88700905af18de1934453c800ae9d">QTableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, int size, int id)</td></tr>
<tr class="memdesc:a36a88700905af18de1934453c800ae9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a partial table read command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a36a88700905af18de1934453c800ae9d">More...</a><br /></td></tr>
<tr class="separator:a36a88700905af18de1934453c800ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1568dcd0e0af9c30043f9179fc527632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1568dcd0e0af9c30043f9179fc527632">QTableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a1568dcd0e0af9c30043f9179fc527632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a partial table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a1568dcd0e0af9c30043f9179fc527632">More...</a><br /></td></tr>
<tr class="separator:a1568dcd0e0af9c30043f9179fc527632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63adc1ca9487420d0f0d4f397892a6c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a63adc1ca9487420d0f0d4f397892a6c0">QFunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a63adc1ca9487420d0f0d4f397892a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function without data request in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a> command queue.  <a href="#a63adc1ca9487420d0f0d4f397892a6c0">More...</a><br /></td></tr>
<tr class="separator:a63adc1ca9487420d0f0d4f397892a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ccc940c3f27964397d8fb2072a4cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a144ccc940c3f27964397d8fb2072a4cf">QFunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:a144ccc940c3f27964397d8fb2072a4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with request data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#a144ccc940c3f27964397d8fb2072a4cf">More...</a><br /></td></tr>
<tr class="separator:a144ccc940c3f27964397d8fb2072a4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8df65accadd116253feed8a730c8664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac8df65accadd116253feed8a730c8664">QFunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id, unsigned estimatedResponseSize=<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a>)</td></tr>
<tr class="memdesc:ac8df65accadd116253feed8a730c8664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#ac8df65accadd116253feed8a730c8664">More...</a><br /></td></tr>
<tr class="separator:ac8df65accadd116253feed8a730c8664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0c9d99fb75dc21283a5d3fcdabb68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af4a0c9d99fb75dc21283a5d3fcdabb68">QFunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request, int id, unsigned estimatedResponseSize=<a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a>)</td></tr>
<tr class="memdesc:af4a0c9d99fb75dc21283a5d3fcdabb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a function with request and response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#af4a0c9d99fb75dc21283a5d3fcdabb68">More...</a><br /></td></tr>
<tr class="separator:af4a0c9d99fb75dc21283a5d3fcdabb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad16d887101c1e2ef14894201aa75a17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> (bool asynchronously=false)</td></tr>
<tr class="memdesc:aad16d887101c1e2ef14894201aa75a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all operations in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue.  <a href="#aad16d887101c1e2ef14894201aa75a17">More...</a><br /></td></tr>
<tr class="separator:aad16d887101c1e2ef14894201aa75a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4db8b1de02405df260fbeea22f22d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aeb4db8b1de02405df260fbeea22f22d9">QGetTableData</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id=-1)</td></tr>
<tr class="memdesc:aeb4db8b1de02405df260fbeea22f22d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the table data after the table read has been successfully performed by QCommit.  <a href="#aeb4db8b1de02405df260fbeea22f22d9">More...</a><br /></td></tr>
<tr class="separator:aeb4db8b1de02405df260fbeea22f22d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bdb2f1cfd7ec87d68a588dfeaa58a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">QGetFunctionData</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int id=-1)</td></tr>
<tr class="memdesc:ac5bdb2f1cfd7ec87d68a588dfeaa58a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the function response data after the function has been successfully executed in QCommit.  <a href="#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">More...</a><br /></td></tr>
<tr class="separator:ac5bdb2f1cfd7ec87d68a588dfeaa58a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cb0e39b25f7450228ce092b358bf55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a81cb0e39b25f7450228ce092b358bf55">QGetIdentifyMeterData</a> ()</td></tr>
<tr class="memdesc:a81cb0e39b25f7450228ce092b358bf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the identify meter string after the QIdentifyMeter has been successfully performed in QCommit.  <a href="#a81cb0e39b25f7450228ce092b358bf55">More...</a><br /></td></tr>
<tr class="separator:a81cb0e39b25f7450228ce092b358bf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4ac84c215dbf8aa29be17a897b2e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a9fb4ac84c215dbf8aa29be17a897b2e4">WriteToMonitor</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;message)</td></tr>
<tr class="memdesc:a9fb4ac84c215dbf8aa29be17a897b2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write a message to the monitor, if it is connected.  <a href="#a9fb4ac84c215dbf8aa29be17a897b2e4">More...</a><br /></td></tr>
<tr class="separator:a9fb4ac84c215dbf8aa29be17a897b2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1c1a9ec69a7b146af846d0b4555cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aad1c1a9ec69a7b146af846d0b4555cc3">WriteCountsToMonitor</a> ()</td></tr>
<tr class="memdesc:aad1c1a9ec69a7b146af846d0b4555cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write running values of communication quality counters to monitor.  <a href="#aad1c1a9ec69a7b146af846d0b4555cc3">More...</a><br /></td></tr>
<tr class="separator:aad1c1a9ec69a7b146af846d0b4555cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c0bf42b3e983e64f0d47856d9e10d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac9c0bf42b3e983e64f0d47856d9e10d8">StartSession</a> ()</td></tr>
<tr class="memdesc:ac9c0bf42b3e983e64f0d47856d9e10d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously start the session.  <a href="#ac9c0bf42b3e983e64f0d47856d9e10d8">More...</a><br /></td></tr>
<tr class="separator:ac9c0bf42b3e983e64f0d47856d9e10d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c406f96f58b3c72411924f085e0f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a614c406f96f58b3c72411924f085e0f1">EndSession</a> ()</td></tr>
<tr class="memdesc:a614c406f96f58b3c72411924f085e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously end the session.  <a href="#a614c406f96f58b3c72411924f085e0f1">More...</a><br /></td></tr>
<tr class="separator:a614c406f96f58b3c72411924f085e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061f6255815a1b2bc982bbcb28ac4df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a061f6255815a1b2bc982bbcb28ac4df4">EndSessionNoThrow</a> ()</td></tr>
<tr class="memdesc:a061f6255815a1b2bc982bbcb28ac4df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the session, but do not throw errors.  <a href="#a061f6255815a1b2bc982bbcb28ac4df4">More...</a><br /></td></tr>
<tr class="separator:a061f6255815a1b2bc982bbcb28ac4df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54b21cfb84791a8e1d9132b33b8a64"><td class="memItemLeft" align="right" valign="top">Muint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afc54b21cfb84791a8e1d9132b33b8a64">ReadStartByte</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;setOfValidStartBytes, unsigned trafficTimeout)</td></tr>
<tr class="memdesc:afc54b21cfb84791a8e1d9132b33b8a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the start byte of the packet in a proper way, taking into consideration timeouts and ignoring garbage.  <a href="#afc54b21cfb84791a8e1d9132b33b8a64">More...</a><br /></td></tr>
<tr class="separator:afc54b21cfb84791a8e1d9132b33b8a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9f1af7c99107d64f498f4b2b3a04cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0b9f1af7c99107d64f498f4b2b3a04cb">TableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:a0b9f1af7c99107d64f498f4b2b3a04cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter.  <a href="#a0b9f1af7c99107d64f498f4b2b3a04cb">More...</a><br /></td></tr>
<tr class="separator:a0b9f1af7c99107d64f498f4b2b3a04cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ceef5e13fc8328e914f3a85fa3a4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a97ceef5e13fc8328e914f3a85fa3a4b6">TableReadBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, void *buff, unsigned size)</td></tr>
<tr class="memdesc:a97ceef5e13fc8328e914f3a85fa3a4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadTable, but instead of returning a byte string, read table into a given buffer.  <a href="#a97ceef5e13fc8328e914f3a85fa3a4b6">More...</a><br /></td></tr>
<tr class="separator:a97ceef5e13fc8328e914f3a85fa3a4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626edc816da38de4579137d15088420"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac626edc816da38de4579137d15088420"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ac626edc816da38de4579137d15088420">TableReadBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, T &amp;table)</td></tr>
<tr class="memdesc:ac626edc816da38de4579137d15088420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadTable, but instead of returning a byte string, read table into a given template variable.  <a href="#ac626edc816da38de4579137d15088420">More...</a><br /></td></tr>
<tr class="separator:ac626edc816da38de4579137d15088420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6e3cb40e08cc7a1928f424235e12a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad5b6e3cb40e08cc7a1928f424235e12a">TableReadNoThrow</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="class_m_exception.html">MException</a> **exception, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:ad5b6e3cb40e08cc7a1928f424235e12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter, do not throw an exception, but rather return it.  <a href="#ad5b6e3cb40e08cc7a1928f424235e12a">More...</a><br /></td></tr>
<tr class="separator:ad5b6e3cb40e08cc7a1928f424235e12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40474bd501a7a79eaa8a858db378818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae40474bd501a7a79eaa8a858db378818">TableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:ae40474bd501a7a79eaa8a858db378818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write the whole table with number given as parameter.  <a href="#ae40474bd501a7a79eaa8a858db378818">More...</a><br /></td></tr>
<tr class="separator:ae40474bd501a7a79eaa8a858db378818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25225dab2e96159a2e87ccf4a3f98ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a25225dab2e96159a2e87ccf4a3f98ff5">TableWriteBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const void *data, unsigned size)</td></tr>
<tr class="memdesc:a25225dab2e96159a2e87ccf4a3f98ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWrite, but uses buffer, given as data and size parameters.  <a href="#a25225dab2e96159a2e87ccf4a3f98ff5">More...</a><br /></td></tr>
<tr class="separator:a25225dab2e96159a2e87ccf4a3f98ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c91ea9cb634f292ba182dfad1eb67c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70c91ea9cb634f292ba182dfad1eb67c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a70c91ea9cb634f292ba182dfad1eb67c">TableWriteBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const T &amp;table)</td></tr>
<tr class="memdesc:a70c91ea9cb634f292ba182dfad1eb67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as WriteTable, but uses variable of some specific template class or structure.  <a href="#a70c91ea9cb634f292ba182dfad1eb67c">More...</a><br /></td></tr>
<tr class="separator:a70c91ea9cb634f292ba182dfad1eb67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07064801f4387790bc0aa0ec8a4fbb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a07064801f4387790bc0aa0ec8a4fbb21">TableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, int size)</td></tr>
<tr class="memdesc:a07064801f4387790bc0aa0ec8a4fbb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read part of the table with number given as parameter.  <a href="#a07064801f4387790bc0aa0ec8a4fbb21">More...</a><br /></td></tr>
<tr class="separator:a07064801f4387790bc0aa0ec8a4fbb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7d366d9d1f297b52e7baf2bc7ac24b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#acf7d366d9d1f297b52e7baf2bc7ac24b">TableReadPartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, void *buff, unsigned size)</td></tr>
<tr class="memdesc:acf7d366d9d1f297b52e7baf2bc7ac24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableReadPartial, but instead of returning a byte string, read table into a given buffer.  <a href="#acf7d366d9d1f297b52e7baf2bc7ac24b">More...</a><br /></td></tr>
<tr class="separator:acf7d366d9d1f297b52e7baf2bc7ac24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f275facac5ad95bb8ce4e6df7044008"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f275facac5ad95bb8ce4e6df7044008"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2f275facac5ad95bb8ce4e6df7044008">TableReadPartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, T &amp;table, int offset)</td></tr>
<tr class="memdesc:a2f275facac5ad95bb8ce4e6df7044008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableReadPartial, but instead of returning a byte string, partially read table into a given template variable.  <a href="#a2f275facac5ad95bb8ce4e6df7044008">More...</a><br /></td></tr>
<tr class="separator:a2f275facac5ad95bb8ce4e6df7044008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d15c7e39f18cc7d77067ecb5aa0d020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7d15c7e39f18cc7d77067ecb5aa0d020">TableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a7d15c7e39f18cc7d77067ecb5aa0d020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write part of the table with number given as parameter.  <a href="#a7d15c7e39f18cc7d77067ecb5aa0d020">More...</a><br /></td></tr>
<tr class="separator:a7d15c7e39f18cc7d77067ecb5aa0d020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582cc6901f859085d97ae69aca60ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1582cc6901f859085d97ae69aca60ac7">TableWritePartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int offset, const void *buff, unsigned size)</td></tr>
<tr class="memdesc:a1582cc6901f859085d97ae69aca60ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWritePartial, but instead of using a byte string, write table using a given buffer.  <a href="#a1582cc6901f859085d97ae69aca60ac7">More...</a><br /></td></tr>
<tr class="separator:a1582cc6901f859085d97ae69aca60ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8010cabbebd86ff8775a5f7d82711d3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8010cabbebd86ff8775a5f7d82711d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#af8010cabbebd86ff8775a5f7d82711d3">TableWritePartialBuffer</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const T &amp;table, int offset)</td></tr>
<tr class="memdesc:af8010cabbebd86ff8775a5f7d82711d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as TableWritePartial, but instead of using a byte string, write table using a given template class contents.  <a href="#af8010cabbebd86ff8775a5f7d82711d3">More...</a><br /></td></tr>
<tr class="separator:af8010cabbebd86ff8775a5f7d82711d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a528fb6f70b4baba1485062c74f3523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7a528fb6f70b4baba1485062c74f3523">FunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a7a528fb6f70b4baba1485062c74f3523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with no parameters, the number of the function is given as parameter.  <a href="#a7a528fb6f70b4baba1485062c74f3523">More...</a><br /></td></tr>
<tr class="separator:a7a528fb6f70b4baba1485062c74f3523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12a2ba50f66f04f0d509b95be684e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad12a2ba50f66f04f0d509b95be684e14">FunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:ad12a2ba50f66f04f0d509b95be684e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request data, the number of the function is given as parameter.  <a href="#ad12a2ba50f66f04f0d509b95be684e14">More...</a><br /></td></tr>
<tr class="separator:ad12a2ba50f66f04f0d509b95be684e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b90e2cd8076ffa77c7c3684fb3b580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a24b90e2cd8076ffa77c7c3684fb3b580">FunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a24b90e2cd8076ffa77c7c3684fb3b580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with response data, the number of the function is given as parameter.  <a href="#a24b90e2cd8076ffa77c7c3684fb3b580">More...</a><br /></td></tr>
<tr class="separator:a24b90e2cd8076ffa77c7c3684fb3b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda3777c6b76d297bcde7e97ea960623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#afda3777c6b76d297bcde7e97ea960623">FunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:afda3777c6b76d297bcde7e97ea960623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request and response data, the number of the function is given as parameter.  <a href="#afda3777c6b76d297bcde7e97ea960623">More...</a><br /></td></tr>
<tr class="separator:afda3777c6b76d297bcde7e97ea960623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1fa960c9550b02aa815a4cc2ec1f5a"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6a1fa960c9550b02aa815a4cc2ec1f5a">GetNumberOfDataLinkPackets</a> (MCommunicationCommand::CommandType typeOfRequest, unsigned applicationLayerDataSize=0)</td></tr>
<tr class="memdesc:a6a1fa960c9550b02aa815a4cc2ec1f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of data link packets that are required for a given request, provided an optional size of the application data.  <a href="#a6a1fa960c9550b02aa815a4cc2ec1f5a">More...</a><br /></td></tr>
<tr class="separator:a6a1fa960c9550b02aa815a4cc2ec1f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153d408f472c69796e0653a3d6aa8a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a153d408f472c69796e0653a3d6aa8a88">IdentifyMeterWithContext</a> (bool sessionIsStarted=false, <a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *tablesRead=NULL)</td></tr>
<tr class="memdesc:a153d408f472c69796e0653a3d6aa8a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command).  <a href="#a153d408f472c69796e0653a3d6aa8a88">More...</a><br /></td></tr>
<tr class="separator:a153d408f472c69796e0653a3d6aa8a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f41d7ea056c7487378a942b7013cd61"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a1f41d7ea056c7487378a942b7013cd61">CalculateChecksumFromBuffer</a> (const char *buff, unsigned size) const </td></tr>
<tr class="memdesc:a1f41d7ea056c7487378a942b7013cd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent one-byte checksum calculation procedure that uses buffer and its size.  <a href="#a1f41d7ea056c7487378a942b7013cd61">More...</a><br /></td></tr>
<tr class="separator:a1f41d7ea056c7487378a942b7013cd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133e349c1e8797a95c6adacfe1aa763"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa133e349c1e8797a95c6adacfe1aa763">CalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer) const </td></tr>
<tr class="memdesc:aa133e349c1e8797a95c6adacfe1aa763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent one-byte checksum calculation procedure that uses byte string.  <a href="#aa133e349c1e8797a95c6adacfe1aa763">More...</a><br /></td></tr>
<tr class="separator:aa133e349c1e8797a95c6adacfe1aa763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ec86e1cc6b8fb4a1b3ecb812d0ba35"><td class="memItemLeft" align="right" valign="top">virtual Muint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a02ec86e1cc6b8fb4a1b3ecb812d0ba35">CalculateCRC16FromBuffer</a> (const char *buff, unsigned size) const </td></tr>
<tr class="memdesc:a02ec86e1cc6b8fb4a1b3ecb812d0ba35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract protocol dependent two-byte CRC calculation procedure, takes buffer chunk with the size.  <a href="#a02ec86e1cc6b8fb4a1b3ecb812d0ba35">More...</a><br /></td></tr>
<tr class="separator:a02ec86e1cc6b8fb4a1b3ecb812d0ba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb755fa8d912240ffd69553930ea114"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6bb755fa8d912240ffd69553930ea114">CalculateCRC16</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer) const </td></tr>
<tr class="memdesc:a6bb755fa8d912240ffd69553930ea114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol dependent two-byte CRC calculation procedure that accepts the byte string.  <a href="#a6bb755fa8d912240ffd69553930ea114">More...</a><br /></td></tr>
<tr class="separator:a6bb755fa8d912240ffd69553930ea114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f966b2e9889aa5111130cc2a96ce27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a3f966b2e9889aa5111130cc2a96ce27f">Sleep</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:a3f966b2e9889aa5111130cc2a96ce27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls channel's Sleep method if the channel is present.  <a href="#a3f966b2e9889aa5111130cc2a96ce27f">More...</a><br /></td></tr>
<tr class="separator:a3f966b2e9889aa5111130cc2a96ce27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a85938b8449e0ec4f2d8ccbe0b07e6d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a85938b8449e0ec4f2d8ccbe0b07e6d07">GetMeterIsLittleEndian</a> () const </td></tr>
<tr class="separator:a85938b8449e0ec4f2d8ccbe0b07e6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a903d399462a1c758ee69a409ca0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#acf7a903d399462a1c758ee69a409ca0a">SetMeterIsLittleEndian</a> (bool isLittleEndian)</td></tr>
<tr class="separator:acf7a903d399462a1c758ee69a409ca0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7c1f3716f3a56c3d652dcd856d4b2afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a7c1f3716f3a56c3d652dcd856d4b2afb">GetChannel</a> () const </td></tr>
<tr class="separator:a7c1f3716f3a56c3d652dcd856d4b2afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742a84d23ad0eb514b1438877caaf546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a742a84d23ad0eb514b1438877caaf546">SetChannel</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel)</td></tr>
<tr class="separator:a742a84d23ad0eb514b1438877caaf546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a159f02566ad282534dca1cc48ca6a9be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a159f02566ad282534dca1cc48ca6a9be">IsChannelOwned</a> () const </td></tr>
<tr class="separator:a159f02566ad282534dca1cc48ca6a9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4244ee4024965a0ccdc5e374a4f4ce4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a4244ee4024965a0ccdc5e374a4f4ce4b">SetIsChannelOwned</a> (bool yes)</td></tr>
<tr class="separator:a4244ee4024965a0ccdc5e374a4f4ce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ada79d1deee2f2b2c57f4c0733f9c5670"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ada79d1deee2f2b2c57f4c0733f9c5670">GetKeepSessionAlive</a> () const </td></tr>
<tr class="separator:ada79d1deee2f2b2c57f4c0733f9c5670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17855be033587c380defb411ca4a169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab17855be033587c380defb411ca4a169">SetKeepSessionAlive</a> (bool alive)</td></tr>
<tr class="separator:ab17855be033587c380defb411ca4a169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7eb073d8a88ba1a5f741e5ba5ef35e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ab7eb073d8a88ba1a5f741e5ba5ef35e3">GetPassword</a> () const </td></tr>
<tr class="separator:ab7eb073d8a88ba1a5f741e5ba5ef35e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad711cb25a0c60e1789391e8398d670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;password)</td></tr>
<tr class="separator:abad711cb25a0c60e1789391e8398d670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff5d6a64af11464ea5e932188affd950"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aff5d6a64af11464ea5e932188affd950">GetPasswordList</a> () const </td></tr>
<tr class="separator:aff5d6a64af11464ea5e932188affd950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbfdbdb3cbeb2809e0aa18de682decd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5fbfdbdb3cbeb2809e0aa18de682decd">SetPasswordList</a> (const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;passwordList)</td></tr>
<tr class="separator:a5fbfdbdb3cbeb2809e0aa18de682decd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a04125b705921153a4bde750649a9ecc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a04125b705921153a4bde750649a9ecc3">GetProgressMonitor</a> () const </td></tr>
<tr class="separator:a04125b705921153a4bde750649a9ecc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc702f61befdd1b58b7186d457e3789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2cc702f61befdd1b58b7186d457e3789">SetProgressMonitor</a> (<a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *p)</td></tr>
<tr class="separator:a2cc702f61befdd1b58b7186d457e3789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a80c81486925491e60e7c6beb86e603b7"><td class="memItemLeft" align="right" valign="top">MCommunicationQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80c81486925491e60e7c6beb86e603b7">GetCommandQueue</a> ()</td></tr>
<tr class="memdesc:a80c81486925491e60e7c6beb86e603b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">M_NO_PROGRESS_MONITOR.  <a href="#a80c81486925491e60e7c6beb86e603b7">More...</a><br /></td></tr>
<tr class="separator:a80c81486925491e60e7c6beb86e603b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850a893c89d0336264c7a67c0a6cdf2f"><td class="memItemLeft" align="right" valign="top">const MCommunicationQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a850a893c89d0336264c7a67c0a6cdf2f">GetCommandQueue</a> () const </td></tr>
<tr class="memdesc:a850a893c89d0336264c7a67c0a6cdf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">M_NO_PROGRESS_MONITOR.  <a href="#a850a893c89d0336264c7a67c0a6cdf2f">More...</a><br /></td></tr>
<tr class="separator:a850a893c89d0336264c7a67c0a6cdf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abb127ad977cc65921c71f65c56bc427d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abb127ad977cc65921c71f65c56bc427d">IdentifyMeter</a> (bool sessionIsStarted=false)</td></tr>
<tr class="separator:abb127ad977cc65921c71f65c56bc427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78587773f355c611188b78b6fd1be3e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a78587773f355c611188b78b6fd1be3e4">DoIdentifyMeter0</a> ()</td></tr>
<tr class="separator:a78587773f355c611188b78b6fd1be3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d9454ddf99ec17a57e738b7a4c9924"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a21d9454ddf99ec17a57e738b7a4c9924">~MCOMObject</a> ()</td></tr>
<tr class="memdesc:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a21d9454ddf99ec17a57e738b7a4c9924 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a035721a745792a3acf0d4b274f1357f7">GetAllPropertyNames</a> () const </td></tr>
<tr class="memdesc:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available properties in MCOM syntax.  <a href="#a035721a745792a3acf0d4b274f1357f7">More...</a><br /></td></tr>
<tr class="separator:a035721a745792a3acf0d4b274f1357f7 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#ga2202c52a837005ec0fe2f116748d37ff">MStdStringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a49655583da819ff86d7798a28537c6a8">GetAllPersistentPropertyNames</a> () const </td></tr>
<tr class="memdesc:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of publicly available persistent properties in MCOM syntax.  <a href="#a49655583da819ff86d7798a28537c6a8">More...</a><br /></td></tr>
<tr class="separator:a49655583da819ff86d7798a28537c6a8 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ae29a16d367eb0adb13332f8ac5fb888c">GetPersistentPropertyValues</a> (bool onlyNondefaults=false, bool excludeSecurityRelated=false) const </td></tr>
<tr class="memdesc:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#ae29a16d367eb0adb13332f8ac5fb888c">More...</a><br /></td></tr>
<tr class="separator:ae29a16d367eb0adb13332f8ac5fb888c inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#acc4469513dd44b58e00cec24dbb6d8a3">SetPersistentPropertyValues</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;values)</td></tr>
<tr class="memdesc:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties for the object using the string with the following format:  <a href="#acc4469513dd44b58e00cec24dbb6d8a3">More...</a><br /></td></tr>
<tr class="separator:acc4469513dd44b58e00cec24dbb6d8a3 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#ac1d0975664316b3009c6f4f1822cfa75">SetPropertyValues</a> (const <a class="el" href="class_m_dictionary.html">MDictionary</a> &amp;values)</td></tr>
<tr class="memdesc:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the properties for the object using the property list object.  <a href="#ac1d0975664316b3009c6f4f1822cfa75">More...</a><br /></td></tr>
<tr class="separator:ac1d0975664316b3009c6f4f1822cfa75 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a7f7d1bbe083159dca4bd92e5d8268ad2">WritePropertiesToMonitor</a> ()</td></tr>
<tr class="memdesc:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all non-default values of protocol properties into monitor.  <a href="#a7f7d1bbe083159dca4bd92e5d8268ad2">More...</a><br /></td></tr>
<tr class="separator:a7f7d1bbe083159dca4bd92e5d8268ad2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a74dc8ffe0afce73e590f2206c890a0f2">DoGetPersistentPropertyValues0</a> () const </td></tr>
<tr class="memdesc:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the whole list of persistent property names and their values.  <a href="#a74dc8ffe0afce73e590f2206c890a0f2">More...</a><br /></td></tr>
<tr class="separator:a74dc8ffe0afce73e590f2206c890a0f2 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a68f6f34b5bf5ad5b6cba05aae222bf58">DoGetPersistentPropertyValues1</a> (bool onlyNondefaults) const </td></tr>
<tr class="memdesc:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string with the list of persistent property names and their values.  <a href="#a68f6f34b5bf5ad5b6cba05aae222bf58">More...</a><br /></td></tr>
<tr class="separator:a68f6f34b5bf5ad5b6cba05aae222bf58 inherit pub_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44959297f429d05d4408c88d7596afc4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a44959297f429d05d4408c88d7596afc4">~MObject</a> ()</td></tr>
<tr class="memdesc:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor. <br /></td></tr>
<tr class="separator:a44959297f429d05d4408c88d7596afc4 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a297127a242f90a602d4ba24243591b52">GetClass</a> () const  =0</td></tr>
<tr class="memdesc:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the final class of the object.  <a href="#a297127a242f90a602d4ba24243591b52">More...</a><br /></td></tr>
<tr class="separator:a297127a242f90a602d4ba24243591b52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a87705dec46a625badd4ceda29547b338">GetEmbeddedSizeof</a> () const </td></tr>
<tr class="memdesc:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">For embedded object types, return the size of the class.  <a href="#a87705dec46a625badd4ceda29547b338">More...</a><br /></td></tr>
<tr class="separator:a87705dec46a625badd4ceda29547b338 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a203c3127403741b20df02335c1015532">IsEmbeddedObject</a> () const </td></tr>
<tr class="memdesc:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the object is of embedded kind.  <a href="#a203c3127403741b20df02335c1015532">More...</a><br /></td></tr>
<tr class="separator:a203c3127403741b20df02335c1015532 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">SHOW_INTERNAL <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad752a5e3b6800212e453481287e28067">Call</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;params)</td></tr>
<tr class="memdesc:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant.  <a href="#ad752a5e3b6800212e453481287e28067">More...</a><br /></td></tr>
<tr class="separator:ad752a5e3b6800212e453481287e28067 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a62a3a6bb2e0e64a644b0be916a502492">Call0</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with no parameters.  <a href="#a62a3a6bb2e0e64a644b0be916a502492">More...</a><br /></td></tr>
<tr class="separator:a62a3a6bb2e0e64a644b0be916a502492 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3dafe0a11416dd435a4384678f9fe010">Call1</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1)</td></tr>
<tr class="memdesc:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with one parameter.  <a href="#a3dafe0a11416dd435a4384678f9fe010">More...</a><br /></td></tr>
<tr class="separator:a3dafe0a11416dd435a4384678f9fe010 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a47cced5e73d0558ac761367380efde52">Call2</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2)</td></tr>
<tr class="memdesc:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with two parameter.  <a href="#a47cced5e73d0558ac761367380efde52">More...</a><br /></td></tr>
<tr class="separator:a47cced5e73d0558ac761367380efde52 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ad5b38fa7d1eedf7640183ce1bf750479">Call3</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3)</td></tr>
<tr class="memdesc:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with three parameter.  <a href="#ad5b38fa7d1eedf7640183ce1bf750479">More...</a><br /></td></tr>
<tr class="separator:ad5b38fa7d1eedf7640183ce1bf750479 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#abac65416662f68d208674270c4fc2a95">Call4</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4)</td></tr>
<tr class="memdesc:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with four parameter.  <a href="#abac65416662f68d208674270c4fc2a95">More...</a><br /></td></tr>
<tr class="separator:abac65416662f68d208674270c4fc2a95 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a72636f3f379105f9b98eb4644464c96c">Call5</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5)</td></tr>
<tr class="memdesc:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with five parameter.  <a href="#a72636f3f379105f9b98eb4644464c96c">More...</a><br /></td></tr>
<tr class="separator:a72636f3f379105f9b98eb4644464c96c inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a3634a9b8b7927122ec3b7e9f08f15be9">Call6</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p1, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p2, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p3, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p4, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p5, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;p6)</td></tr>
<tr class="memdesc:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with six parameter.  <a href="#a3634a9b8b7927122ec3b7e9f08f15be9">More...</a><br /></td></tr>
<tr class="separator:a3634a9b8b7927122ec3b7e9f08f15be9 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae7a3f18267d3af7513242e7247c8c40e">CallV</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html#ac98faca84b5c7da406105995fedbe1c3">MVariant::VariantVector</a> &amp;params)</td></tr>
<tr class="memdesc:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the object service with parameters, given as variant vector.  <a href="#ae7a3f18267d3af7513242e7247c8c40e">More...</a><br /></td></tr>
<tr class="separator:ae7a3f18267d3af7513242e7247c8c40e inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99063368f3e5fb4189bcbd13339e47c0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a99063368f3e5fb4189bcbd13339e47c0">IsPropertyPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the property with the given name exists. <br /></td></tr>
<tr class="separator:a99063368f3e5fb4189bcbd13339e47c0 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d10a068500c82809fcb6d97ea9611da"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a6d10a068500c82809fcb6d97ea9611da">IsServicePresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the service with the given name exists. <br /></td></tr>
<tr class="separator:a6d10a068500c82809fcb6d97ea9611da inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a0e84b79fc7c435e2b338f0f9a6239b45">GetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property value using name of the property.  <a href="#a0e84b79fc7c435e2b338f0f9a6239b45">More...</a><br /></td></tr>
<tr class="separator:a0e84b79fc7c435e2b338f0f9a6239b45 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a4c04b41d6114e57b12447bd0e07e6af5">SetProperty</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name, const <a class="el" href="class_m_variant.html">MVariant</a> &amp;value)</td></tr>
<tr class="memdesc:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property using name of the property, and value.  <a href="#a4c04b41d6114e57b12447bd0e07e6af5">More...</a><br /></td></tr>
<tr class="separator:a4c04b41d6114e57b12447bd0e07e6af5 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a65eb2f14c14157a7aeead3d68550092f">SetPersistentPropertiesToDefault</a> ()</td></tr>
<tr class="memdesc:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties of the object to their default values.  <a href="#a65eb2f14c14157a7aeead3d68550092f">More...</a><br /></td></tr>
<tr class="separator:a65eb2f14c14157a7aeead3d68550092f inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_m_variant.html">MVariant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a14384d8101f49cb7616bddd06fe6ecbd">GetPersistentPropertyDefaultValue</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name) const </td></tr>
<tr class="memdesc:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default value of persistent property with the name given.  <a href="#a14384d8101f49cb7616bddd06fe6ecbd">More...</a><br /></td></tr>
<tr class="separator:a14384d8101f49cb7616bddd06fe6ecbd inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a76f62e685cf1f638da5aef8c41ca8586">SetPersistentPropertyToDefault</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent property with the name given to default value.  <a href="#a76f62e685cf1f638da5aef8c41ca8586">More...</a><br /></td></tr>
<tr class="separator:a76f62e685cf1f638da5aef8c41ca8586 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03324a7bc9b626fe2860beb4b84b6bcc"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a03324a7bc9b626fe2860beb4b84b6bcc">GetType</a> () const </td></tr>
<tr class="memdesc:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the type for the object (could be the same as class name). <br /></td></tr>
<tr class="separator:a03324a7bc9b626fe2860beb4b84b6bcc inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a164dbf0ffa4e8c65b9ceffbf1d6fb391">SetType</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;)</td></tr>
<tr class="memdesc:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intentionally, it will set the name of the type for the object, but the service will not allow setting the name to anything other than the current name.  <a href="#a164dbf0ffa4e8c65b9ceffbf1d6fb391">More...</a><br /></td></tr>
<tr class="separator:a164dbf0ffa4e8c65b9ceffbf1d6fb391 inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#af929f6afc9295557a8c5ead74c6c0b6a">Validate</a> ()</td></tr>
<tr class="memdesc:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate internal structures of the object.  <a href="#af929f6afc9295557a8c5ead74c6c0b6a">More...</a><br /></td></tr>
<tr class="separator:af929f6afc9295557a8c5ead74c6c0b6a inherit pub_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa87779c70f4bc9e1208066509d618203"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa87779c70f4bc9e1208066509d618203">StaticCalculateChecksumFromBuffer</a> (const char *buff, unsigned size)</td></tr>
<tr class="memdesc:aa87779c70f4bc9e1208066509d618203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most popular one-byte checksum calculation procedure, a sum of all bytes.  <a href="#aa87779c70f4bc9e1208066509d618203">More...</a><br /></td></tr>
<tr class="separator:aa87779c70f4bc9e1208066509d618203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a677751b4d8150a1b6236d3f699adf2"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6a677751b4d8150a1b6236d3f699adf2">StaticCalculateChecksum</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;buffer)</td></tr>
<tr class="memdesc:a6a677751b4d8150a1b6236d3f699adf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute checksum of the byte string given as parameters.  <a href="#a6a677751b4d8150a1b6236d3f699adf2">More...</a><br /></td></tr>
<tr class="separator:a6a677751b4d8150a1b6236d3f699adf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_class.html">MClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#aeba892081e500e981d22a2c54b6a0100">GetStaticClass</a> ()</td></tr>
<tr class="memdesc:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the declared class of this particular object.  <a href="#aeba892081e500e981d22a2c54b6a0100">More...</a><br /></td></tr>
<tr class="separator:aeba892081e500e981d22a2c54b6a0100 inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a89f92d51d036637db84d57290616e98b">IsClassPresent</a> (const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;name)</td></tr>
<tr class="memdesc:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the given class name is available.  <a href="#a89f92d51d036637db84d57290616e98b">More...</a><br /></td></tr>
<tr class="separator:a89f92d51d036637db84d57290616e98b inherit pub_static_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a84c83febc048cf02cb62cd89c30d933f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a84c83febc048cf02cb62cd89c30d933f">MProtocol</a> (<a class="el" href="class_m_channel.html">MChannel</a> *channel, bool channelIsOwned=true)</td></tr>
<tr class="memdesc:a84c83febc048cf02cb62cd89c30d933f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new abstract protocol with the channel given.  <a href="#a84c83febc048cf02cb62cd89c30d933f">More...</a><br /></td></tr>
<tr class="separator:a84c83febc048cf02cb62cd89c30d933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c2fcb6ca3c640a2fab27161c17b336"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ae7c2fcb6ca3c640a2fab27161c17b336">DoStartSession</a> ()</td></tr>
<tr class="memdesc:ae7c2fcb6ca3c640a2fab27161c17b336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously start the session, don't do service count.  <a href="#ae7c2fcb6ca3c640a2fab27161c17b336">More...</a><br /></td></tr>
<tr class="separator:ae7c2fcb6ca3c640a2fab27161c17b336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6362a4ce7b3e94cfb464f9f393cebe4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#aa6362a4ce7b3e94cfb464f9f393cebe4">DoEndSession</a> ()</td></tr>
<tr class="memdesc:aa6362a4ce7b3e94cfb464f9f393cebe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously end the session, don't do service count.  <a href="#aa6362a4ce7b3e94cfb464f9f393cebe4">More...</a><br /></td></tr>
<tr class="separator:aa6362a4ce7b3e94cfb464f9f393cebe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5713023f78fa29cef7dd4d447c46c13c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a5713023f78fa29cef7dd4d447c46c13c">DoTableRead</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, unsigned expectedSize=0)</td></tr>
<tr class="memdesc:a5713023f78fa29cef7dd4d447c46c13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read the whole table with number given as parameter, don't do service count.  <a href="#a5713023f78fa29cef7dd4d447c46c13c">More...</a><br /></td></tr>
<tr class="separator:a5713023f78fa29cef7dd4d447c46c13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed51debc39d8bbf7f2ca1b5327f7bfc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#abed51debc39d8bbf7f2ca1b5327f7bfc">DoTableWrite</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data)</td></tr>
<tr class="memdesc:abed51debc39d8bbf7f2ca1b5327f7bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write the whole table with number given as parameter, don't do service count.  <a href="#abed51debc39d8bbf7f2ca1b5327f7bfc">More...</a><br /></td></tr>
<tr class="separator:abed51debc39d8bbf7f2ca1b5327f7bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df82b4dfb44ebf518616fa27d4feef7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0df82b4dfb44ebf518616fa27d4feef7">DoTableReadPartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset, int size)</td></tr>
<tr class="memdesc:a0df82b4dfb44ebf518616fa27d4feef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously read part of the table with number given as parameter, don't do service count.  <a href="#a0df82b4dfb44ebf518616fa27d4feef7">More...</a><br /></td></tr>
<tr class="separator:a0df82b4dfb44ebf518616fa27d4feef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1679a8d7a6ffc68b79aceddb89165d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a6f1679a8d7a6ffc68b79aceddb89165d">DoTableWritePartial</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;data, int offset)</td></tr>
<tr class="memdesc:a6f1679a8d7a6ffc68b79aceddb89165d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously write part of the table with number given as parameter, don't do service count.  <a href="#a6f1679a8d7a6ffc68b79aceddb89165d">More...</a><br /></td></tr>
<tr class="separator:a6f1679a8d7a6ffc68b79aceddb89165d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac4a0d11d9d0a767103abf7da4db49a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a0ac4a0d11d9d0a767103abf7da4db49a">DoFunctionExecute</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number)</td></tr>
<tr class="memdesc:a0ac4a0d11d9d0a767103abf7da4db49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with no parameters, the number of the function is given as parameter, don't do service count.  <a href="#a0ac4a0d11d9d0a767103abf7da4db49a">More...</a><br /></td></tr>
<tr class="separator:a0ac4a0d11d9d0a767103abf7da4db49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498d5dc0aecad07ce33fad05a051dffc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a498d5dc0aecad07ce33fad05a051dffc">DoFunctionExecuteRequest</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request)</td></tr>
<tr class="memdesc:a498d5dc0aecad07ce33fad05a051dffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request data, the number of the function is given as parameter, don't do service count.  <a href="#a498d5dc0aecad07ce33fad05a051dffc">More...</a><br /></td></tr>
<tr class="separator:a498d5dc0aecad07ce33fad05a051dffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2765259b51fb263615753e0354284c4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a2765259b51fb263615753e0354284c4d">DoFunctionExecuteResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;response)</td></tr>
<tr class="memdesc:a2765259b51fb263615753e0354284c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with response data, the number of the function is given as parameter, don't do service count.  <a href="#a2765259b51fb263615753e0354284c4d">More...</a><br /></td></tr>
<tr class="separator:a2765259b51fb263615753e0354284c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638ffb840d26add215f782dedf9253a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a638ffb840d26add215f782dedf9253a0">DoFunctionExecuteRequestResponse</a> (<a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;request, <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;response)</td></tr>
<tr class="memdesc:a638ffb840d26add215f782dedf9253a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously execute the function with request and response data, the number of the function is given as parameter, don't do service count.  <a href="#a638ffb840d26add215f782dedf9253a0">More...</a><br /></td></tr>
<tr class="separator:a638ffb840d26add215f782dedf9253a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99437b4f61294658ca525ebaf46b6c3b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a99437b4f61294658ca525ebaf46b6c3b">DoIdentifyMeter</a> (bool sessionIsStarted, <a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *tablesRead)</td></tr>
<tr class="memdesc:a99437b4f61294658ca525ebaf46b6c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command).  <a href="#a99437b4f61294658ca525ebaf46b6c3b">More...</a><br /></td></tr>
<tr class="separator:a99437b4f61294658ca525ebaf46b6c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0daefaa99d91762fbf5da71033d87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a80a0daefaa99d91762fbf5da71033d87">DoTryPasswordOrPasswordList</a> ()</td></tr>
<tr class="memdesc:a80a0daefaa99d91762fbf5da71033d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try password or passwords for the protocol according to the PASSWORD and PasswordList settings.  <a href="#a80a0daefaa99d91762fbf5da71033d87">More...</a><br /></td></tr>
<tr class="separator:a80a0daefaa99d91762fbf5da71033d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab55c37d116010b499c3cb153c64781"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a8ab55c37d116010b499c3cb153c64781">DoTryPasswordEntry</a> (const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;entry)</td></tr>
<tr class="memdesc:a8ab55c37d116010b499c3cb153c64781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try one password, throw if error.  <a href="#a8ab55c37d116010b499c3cb153c64781">More...</a><br /></td></tr>
<tr class="separator:a8ab55c37d116010b499c3cb153c64781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e1791d3e8f1439f0e4ba228cb50a24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#ad5e1791d3e8f1439f0e4ba228cb50a24">DoBuildComplexServiceName</a> (<a class="el" href="group___m_c_o_r_e.html#ga0cb232e7db5da70b9864e90ccdf41a1a">MChars</a> fullServiceName, <a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> serviceName, <a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, int par1=-1, int par2=-1)</td></tr>
<tr class="memdesc:ad5e1791d3e8f1439f0e4ba228cb50a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build service name with a number and given parameters.  <a href="#ad5e1791d3e8f1439f0e4ba228cb50a24">More...</a><br /></td></tr>
<tr class="separator:ad5e1791d3e8f1439f0e4ba228cb50a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171f571dc3c1a2f1e8f04f54d352c8c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_protocol.html#a171f571dc3c1a2f1e8f04f54d352c8c6">DoBuildPossiblyNumericComplexServiceName</a> (<a class="el" href="group___m_c_o_r_e.html#ga0cb232e7db5da70b9864e90ccdf41a1a">MChars</a> fullServiceName, <a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a> serviceName, <a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a> number, bool isHex, int par1=-1, int par2=-1)</td></tr>
<tr class="memdesc:a171f571dc3c1a2f1e8f04f54d352c8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper service name builder that can interpret numeric values either as hex or as decimal.  <a href="#a171f571dc3c1a2f1e8f04f54d352c8c6">More...</a><br /></td></tr>
<tr class="separator:a171f571dc3c1a2f1e8f04f54d352c8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_c_o_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_c_o_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_c_o_m_object.html">MCOMObject</a></td></tr>
<tr class="memitem:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1387ff56bed4d3ce4ed3d7526ffb0eb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_o_m_object.html#a1387ff56bed4d3ce4ed3d7526ffb0eb5">MCOMObject</a> ()</td></tr>
<tr class="memdesc:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a1387ff56bed4d3ce4ed3d7526ffb0eb5 inherit pro_methods_class_m_c_o_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fd4059be176487607315d88d715a97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a48fd4059be176487607315d88d715a97">MObject</a> ()</td></tr>
<tr class="memdesc:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object constructor, protected as the class is abstract. <br /></td></tr>
<tr class="separator:a48fd4059be176487607315d88d715a97 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#a9160d5a51f8d3b85ace23e83f967f269">DoSetPersistentPropertiesToDefault</a> (const <a class="el" href="class_m_class.html">MClass</a> *staticClass)</td></tr>
<tr class="memdesc:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the persistent properties to their default values for one object provided the class for that object.  <a href="#a9160d5a51f8d3b85ace23e83f967f269">More...</a><br /></td></tr>
<tr class="separator:a9160d5a51f8d3b85ace23e83f967f269 inherit pro_methods_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_class_m_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_m_object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_m_object.html">MObject</a></td></tr>
<tr class="memitem:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae930847fb891a40c903b0e5c0ac5bcf0"></a>
static const <a class="el" href="class_m_class.html">MClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_object.html#ae930847fb891a40c903b0e5c0ac5bcf0">s_class</a></td></tr>
<tr class="memdesc:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of <a class="el" href="class_m_object.html" title="Root object that establishes dynamic class information, dynamic property and method handling and mars...">MObject</a>. <br /></td></tr>
<tr class="separator:ae930847fb891a40c903b0e5c0ac5bcf0 inherit pub_static_attribs_class_m_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction of a communication protocol. </p>
<p>The protocol is able to execute application level commands directly, or through the command queue interface. The concrete instances of protocol will implement the abstractions defined by this class, plus some extra services and attributes specific to those protocols.</p>
<p>Preferred way of creating a protocol is through <a class="el" href="class_m_c_o_m_factory.html" title="Factory that is capable of creating MCOM objects. ">MCOMFactory</a>, and typically, the protocol will be created together with <a class="el" href="class_m_channel.html" title="Abstraction of all channel-level communication media. ">MChannel</a> object using <a class="el" href="class_m_c_o_m_factory.html#acb4d8207c87c2ae7e7eaf4d178aff302">MCOMFactory::CreateProtocol()</a> </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="acb2efd86856570ae339320ade2841e70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="acb2efd86856570ae339320ade2841e70a7df75f2423de285046975aa2c250fa06"></a>MAXIMUM_NUMBER_STRING_SIZE&#160;</td><td class="fielddoc">
<p>Maximum string size allowed for a Number, used in representing a number by the monitoring and error reporting facilities. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb2efd86856570ae339320ade2841e70acd2b89f18226e2b07f46691300abae70"></a>MAXIMUM_SERVICE_NAME_STRING_SIZE&#160;</td><td class="fielddoc">
<p>Maximum string size for the service name. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0"></a>DEFAULT_ESTIMATED_RESPONSE_SIZE&#160;</td><td class="fielddoc">
<p>Size that a response to a function can allocate when its actual size is not known. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb2efd86856570ae339320ade2841e70a7a2476e18495e7f0be160468bfea5d73"></a>MAXIMUM_POSSIBLE_TABLE_OFFSET&#160;</td><td class="fielddoc">
<p>Maximum value for abstract table offset. </p>
<p>This value is protocol dependent, however this value implies a high level check that is not smaller than any protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb2efd86856570ae339320ade2841e70a955afe7a1975e8484755ee30010fa6a1"></a>MAXIMUM_POSSIBLE_TABLE_LENGTH&#160;</td><td class="fielddoc">
<p>Maximum value for abstract table length. </p>
<p>This value is protocol dependent, however this value implies a high level check that is not smaller than any protocol. Also, when the length is bigger than the physical length supported by the protocol, many consecutive application layer requests are done. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a84c83febc048cf02cb62cd89c30d933f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MProtocol::MProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>channelIsOwned</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new abstract protocol with the channel given. </p>
<p>The service is protected because the class is abstract.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel object of the protocol. It will be a rare case when a protocol can be created without a channel, in which case this parameter can be NULL. </td></tr>
    <tr><td class="paramname">channelIsOwned</td><td>Whether the channel has to be owned by the protocol, deleted in protocol destructor or at channel reassignment. By default the protocol owns its channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86685e09ca825849a21b6818c0d2115e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MProtocol::~MProtocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the protocol object. </p>
<p>If the channel is owned, <a class="el" href="class_m_protocol.html#a159f02566ad282534dca1cc48ca6a9be">IsChannelOwned</a> is true, the channel is also destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5483f327ca2dcb745fdb14494848fa01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::AddToPasswordList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a password to the password list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>Shall be valid for this protocol, or an error is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#aff5d6a64af11464ea5e932188affd950">GetPasswordList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e5624fcd28fbc1d199dab3202220f75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::ApplyChannelParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup the configuration of the channel in a way compatible with the protocol handshake sequence. </p>
<p>The action depends on the channel and protocol. Implementations ensure that the service behaves gracefully no matter whether the channel is connected or not. </p>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1222.html#aa61f5f142ad235f5d96991f83f09e700">MProtocolC1222</a>, <a class="el" href="class_m_protocol_c12.html#a84f2ed24daaec391fb5d71bed3f7c372">MProtocolC12</a>, <a class="el" href="class_m_protocol_c1218.html#a5445a7b8ac2e17b4a5227cb58724440a">MProtocolC1218</a>, and <a class="el" href="class_m_protocol_c1221.html#a16611f1db87bbe66d6576a0259858702">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="aa133e349c1e8797a95c6adacfe1aa763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::CalculateChecksum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protocol dependent one-byte checksum calculation procedure that uses byte string. </p>
<p>This implementation uses a protocol-dependent virtual call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer for which to calculate one-byte checksum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the checksum, one byte returned within the low part of four bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f41d7ea056c7487378a942b7013cd61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned MProtocol::CalculateChecksumFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protocol dependent one-byte checksum calculation procedure that uses buffer and its size. </p>
<p>This particular implementation of the checksum calculation fits the majority of the protocols, override if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>The pointer to the buffer for which to calculate the checksum. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the checksum, one byte as lower part of four bytes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#aa87779c70f4bc9e1208066509d618203">StaticCalculateChecksumFromBuffer</a> Static variant of this method that implements the most common sum of bytes algorithm. </dd>
<dd>
<a class="el" href="class_m_protocol.html#aa133e349c1e8797a95c6adacfe1aa763">CalculateChecksum</a> Works on byte string and returns a checksum value as unsigned integer. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c12.html#a00383e3d04e77b0f4331efd1e1a7bc51">MProtocolC12</a>.</p>

</div>
</div>
<a class="anchor" id="a6bb755fa8d912240ffd69553930ea114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::CalculateCRC16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protocol dependent two-byte CRC calculation procedure that accepts the byte string. </p>
<p>This implementation uses a protocol-dependent virtual call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer for which to calculate CRC16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of CRC16, two bytes returned within the low part of four bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a02ec86e1cc6b8fb4a1b3ecb812d0ba35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Muint16 MProtocol::CalculateCRC16FromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract protocol dependent two-byte CRC calculation procedure, takes buffer chunk with the size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>The pointer to the buffer for which to calculate CRC16. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of CRC16, two bytes. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c12.html#ad781dfc93f91866eb9ac2865ce9c0e1c">MProtocolC12</a>.</p>

</div>
</div>
<a class="anchor" id="a02d5080403580f3317fc9eade19882d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::ClearPasswordList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the password list for the protocol to none, so the <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> property is used. </p>
<p>When the password list is not clear, property <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> will not apply.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#aff5d6a64af11464ea5e932188affd950">GetPasswordList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb24a5372b721c343add6ae803287e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::Connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the channel and establishes the connection with the peer. </p>
<p>Prior to calling <a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f">MChannel::Connect()</a>, this protocol method does extra checks, and calls <a class="el" href="class_m_protocol.html#a0e5624fcd28fbc1d199dab3202220f75">ApplyChannelParameters()</a>. Unless <a class="el" href="class_m_channel.html">MChannel</a> is used without <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>, it is recommended to use protocol's <a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94" title="Initializes the channel and establishes the connection with the peer. ">Connect()</a> method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#acb9ead36be06025ce8cd6292824bf59f" title="Initializes channel and establishes connection between the computer and the end device. ">MChannel.Connect()</a> - this is where per-channel specifics of <a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94" title="Initializes the channel and establishes the connection with the peer. ">Connect</a> are exhaustively described. </dd>
<dd>
<a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8" title="Severs the connection between the computer and the end device. ">Disconnect()</a> - operation that undoes the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c41fddbb0e3418dc453981c6136028a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_m_protocol.html">MProtocol</a>* MProtocol::CreateClone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual copy constructor, creates the protocol which is a clone of current. </p>
<p>All persistent properties get copied, all other properties have initial values. If channel is owned, channel is duplicated. If channel is not owned, it is made shared. </p>

<p>Reimplemented from <a class="el" href="class_m_c_o_m_object.html#aabf9b98757e6ae0b1939879f04ca9bfe">MCOMObject</a>.</p>

</div>
</div>
<a class="anchor" id="a5f1a1eeb1e19a54b2061e276d7248556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_progress_action.html">MProgressAction</a>* MProtocol::CreateRootProgressAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create root of the progress actions hierarchy. </p>
<p>Any existing hierarchy is destroyed. If progress monitor is not set, dummy action is returned. A dummy action implements all action's properties and services as no-ops </p>

</div>
</div>
<a class="anchor" id="a72c328afee944e7e977092b8da2887f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::Disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Severs the connection between the computer and the end device. </p>
<p>Unless <a class="el" href="class_m_channel.html">MChannel</a> is used without <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>, it is recommended to use protocol's Disconnect method.</p>
<p>Include Disconnect in error handling routines, otherwise, other applications may not be able to connect to the end device.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a330d82a247925e1550a4563e2e09550d" title="Disconnect brings down the data link, hangs up the phone, powers down the probe, etc. ">MChannel.Disconnect()</a> - this is where per-channel specifics of <a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8" title="Severs the connection between the computer and the end device. ">Disconnect</a> are exhaustively described. </dd>
<dd>
<a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94" title="Initializes the channel and establishes the connection with the peer. ">Connect()</a> - operation that sets up the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5e1791d3e8f1439f0e4ba228cb50a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoBuildComplexServiceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga0cb232e7db5da70b9864e90ccdf41a1a">MChars</a>&#160;</td>
          <td class="paramname"><em>fullServiceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a>&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par2</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build service name with a number and given parameters. </p>
<p>If parameters are not present they are not in the name. The particular protocols can fill in their own implementations for full service name.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given chars pointer shall point to a buffer at least MAXIMUM_SERVICE_NAME_STRING_SIZE long. Otherwise the behavior is undefined. Under no circumstance shall this method shall throw an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a171f571dc3c1a2f1e8f04f54d352c8c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::DoBuildPossiblyNumericComplexServiceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga0cb232e7db5da70b9864e90ccdf41a1a">MChars</a>&#160;</td>
          <td class="paramname"><em>fullServiceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga3a1550bdff57eb46be5e61d23a76c79b">MConstChars</a>&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par2</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper service name builder that can interpret numeric values either as hex or as decimal. </p>
<p>If parameters are not present they are not in the name. The particular protocols can fill in their own implementations for full service name.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given chars pointer shall point to a buffer at least MAXIMUM_SERVICE_NAME_STRING_SIZE long. Otherwise the behavior is undefined. Under no circumstance shall this method shall throw an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6362a4ce7b3e94cfb464f9f393cebe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoEndSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously end the session, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol. Depending on the particular protocol this leads to sequence of logoff and terminate commands.</p>
<p>See EndSession, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the protocol state allows ending the session. Otherwise exceptions can be thrown. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1218.html#aa9f12222a06488962da5768fc970a83d">MProtocolC1218</a>.</p>

</div>
</div>
<a class="anchor" id="a0ac4a0d11d9d0a767103abf7da4db49a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoFunctionExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously execute the function with no parameters, the number of the function is given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See FunctionExecute, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a498d5dc0aecad07ce33fad05a051dffc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoFunctionExecuteRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously execute the function with request data, the number of the function is given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See FunctionExecuteRequest, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a638ffb840d26add215f782dedf9253a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoFunctionExecuteRequestResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously execute the function with request and response data, the number of the function is given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See FunctionExecuteRequestResponse, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a2765259b51fb263615753e0354284c4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoFunctionExecuteResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously execute the function with response data, the number of the function is given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See FunctionExecuteResponse, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a99437b4f61294658ca525ebaf46b6c3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MProtocol::DoIdentifyMeter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sessionIsStarted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *&#160;</td>
          <td class="paramname"><em>tablesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command). </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>If the first parameter is true, the service assumes the session is open, and it will not start the session, or close it. The second parameter, if it is not NULL, is filled with the data from tables, which DoIdentifyMeter had to read from the meter during its attempts to fetch the necessary information from the meter. This table vector can be used in order to minimize the communication with the meter, if this task has its place.</p>
<p>See IdentifyMeter, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is connected. Otherwise a channel-related exception is thrown that tells about the failure. The meter is indeed the one which is able to talk the specific protocol. Otherwise the protocol-specific exception is thrown that signals the failure of communicating through the channel. If the session is started already, the first parameter has to be true, or the behavior is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a78587773f355c611188b78b6fd1be3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MProtocol::DoIdentifyMeter0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identify the meter version and other information if the protocol is known.</p>
<p>Note that this is not an ANSI Identify protocol command. Typically, IdentifyMeter would be used when creating a meter of a known type, but an unknown version.</p>
<p>The IdentifyMeter service wraps the start and end session around the identification task. To call IdentifyMeter, one has to connect to the meter, but the session should not be started. This differs from QIdentifyMeter which does NOT wrap start and end session around the identification task.</p>
<p>Typically, IdentifyMeter returns only one identify string that identifies the meter. However, identify strings can be created for the option boards installed on a meter. In this case, the returned string can contain multiple identify strings, where the the meter's identify string is listed first and identify strings are separated by a semi- colon. Use GetIdentifyStrings to separate multiple identify strings.</p>
<p>The identify string is formatted as a J command and may not be suitable for showing to the user as it can contain non-printable characters. Instead, it is formatted for easy processing by a script or a program. A typical identify string returned for an A3 meter with LANOB option board follows (wrapped for clarity):</p>
<p>Example of A3 Identify string followed by LANOB's identify string, spaces and new lines used for clarity: </p><div class="fragment"><div class="line">J00[MANUFACTURER:EE ]</div><div class="line">   [ED_MODEL:A3R ]</div><div class="line">   [HW_VERSION_REVISION:1.2]</div><div class="line">   [SW_VERSION_REVISION:2.3]</div><div class="line">   [MFG_SERIAL_NUMBER: ]</div><div class="line">   [NUMBER_OF_OPTION_BOARDS:2]</div><div class="line">   [OB1_Type:0M]</div><div class="line">   [OB1_SSPEC:000237]</div><div class="line">   [OB1_REVISION:1.0]</div><div class="line">   [OB1_POSITION:1]</div><div class="line">   [OB2_Type:0K]</div><div class="line">   [OB2_SSPEC:000239]</div><div class="line">   [OB2_REVISION:1.3]</div><div class="line">   [OB2_POSITION:2];</div><div class="line">J00[MANUFACTURER:EE ]</div><div class="line">   [ED_MODEL:REXILC ]</div><div class="line">   [HW_VERSION_REVISION:1.0]</div><div class="line">   [SW_VERSION_REVISION:1.3]</div><div class="line">   [MFG_SERIAL_NUMBER:LANOB ]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae7c2fcb6ca3c640a2fab27161c17b336"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoStartSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously start the session, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol. Depending on the particular protocol this leads to sequence of handshake and logon commands.</p>
<p>See StartSession, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the protocol state allows starting the session. Otherwise exceptions can be thrown. </dd></dl>

<p>Reimplemented in <a class="el" href="class_m_protocol_c1218.html#a1b249ae1c535217e1bcaa523ef01ac36">MProtocolC1218</a>, and <a class="el" href="class_m_protocol_c1221.html#a14fdee822d3c9cef03a969c0a10e16dc">MProtocolC1221</a>.</p>

</div>
</div>
<a class="anchor" id="a5713023f78fa29cef7dd4d447c46c13c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoTableRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously read the whole table with number given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See TableRead, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<p>The third argument is introduced to handle a special case where the table size is bigger than what the protocol allows, such as configuring an ANSI meter to have more load profile data than the 64K that can be transmitted with ANSI C12.18. In this case the table is read with multiple partial reads, where each partial read is sized to fit within the protocol constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a0df82b4dfb44ebf518616fa27d4feef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoTableReadPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously read part of the table with number given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See TableReadPartial, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="abed51debc39d8bbf7f2ca1b5327f7bfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoTableWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously write the whole table with number given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See TableWrite, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f1679a8d7a6ffc68b79aceddb89165d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoTableWritePartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously write part of the table with number given as parameter, don't do service count. </p>
<p>This protected service is indeed the one, which needs overwriting by a particular protocol.</p>
<p>See TableWritePartial, which is public. That one does necessary statistics, monitor handling and error message formatting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab55c37d116010b499c3cb153c64781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::DoTryPasswordEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try one password, throw if error. </p>
<p>This service has to be overloaded by every final protocol to attempt applying a given password.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The security should be cleared with the meter using the password entry given, otherwise an exception should be thrown by the concrete implementation. </dd></dl>

</div>
</div>
<a class="anchor" id="a80a0daefaa99d91762fbf5da71033d87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::DoTryPasswordOrPasswordList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try password or passwords for the protocol according to the PASSWORD and PasswordList settings. </p>
<p>In case the password list is specified, only the password list is tried, if there is no password list, PASSWORD property is used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The security should be cleared with the meter using one of the passwords in the password list, or the password property. Otherwise a security error is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a614c406f96f58b3c72411924f085e0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::EndSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously end the session. </p>
<p>Depending on the particular protocol this leads to sequence of logoff and terminate commands.</p>
<p>See <a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a> for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the protocol state allows ending the session. Otherwise exceptions can be thrown.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a061f6255815a1b2bc982bbcb28ac4df4" title="End the session, but do not throw errors. ">EndSessionNoThrow</a> for the variant that does not throw errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a061f6255815a1b2bc982bbcb28ac4df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::EndSessionNoThrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End the session, but do not throw errors. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a614c406f96f58b3c72411924f085e0f1" title="Synchronously end the session. ">EndSession</a> for the variant that throws errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a6479689e3e13a1a11a34b64da99f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute this method as first action in the destructor of any child protocol. </p>
<p>It is okay to call this method many times from a hierarchy of destructors, however nothing else shall be called after. </p>

</div>
</div>
<a class="anchor" id="a7a528fb6f70b4baba1485062c74f3523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::FunctionExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously execute the function with no parameters, the number of the function is given as parameter. </p>
<p>See QFunctionExecute for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Function number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad12a2ba50f66f04f0d509b95be684e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::FunctionExecuteRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously execute the function with request data, the number of the function is given as parameter. </p>
<p>See QFunctionExecuteRequest for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Function number. </td></tr>
    <tr><td class="paramname">request</td><td>Request data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afda3777c6b76d297bcde7e97ea960623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::FunctionExecuteRequestResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously execute the function with request and response data, the number of the function is given as parameter. </p>
<p>See QFunctionExecuteRequestResponse for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Function number. </td></tr>
    <tr><td class="paramname">request</td><td>Request data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Response data. </dd></dl>

</div>
</div>
<a class="anchor" id="a24b90e2cd8076ffa77c7c3684fb3b580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::FunctionExecuteResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously execute the function with response data, the number of the function is given as parameter. </p>
<p>See QFunctionExecuteResponse for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Function number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Response data. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b45ec72043fe42c32b414d1448fab12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetAverageRoundTripTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the average measured approximate packet round trip time over the link layer. </p>
<p>A 'round trip' is defined as the amount of time elapsed from the last byte sent to the first byte received back. Each trip is monitored, and the following properties updated accordingly: <a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a>, <a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a>, and <a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a>.</p>
<p>The round trip times are not updated when there is a timeout, even if there were garbage characters on the line. The round trip times are nullified when the connection is created or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 4.0.43.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7c1f3716f3a56c3d652dcd856d4b2afb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_channel.html">MChannel</a>* MProtocol::GetChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Channel associated with this protocol.</p>
<p>When the channel is owned, and a new one is reassigned to the protocol, the previous channel will be deleted. </p>

</div>
</div>
<a class="anchor" id="a80c81486925491e60e7c6beb86e603b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCommunicationQueue&amp; MProtocol::GetCommandQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>M_NO_PROGRESS_MONITOR. </p>
<p>Get the command queue of the protocol.</p>
<p>If the items were added to the queue by Q services, and no QCommit is performed yet, the queue is not empty. </p>

</div>
</div>
<a class="anchor" id="a850a893c89d0336264c7a67c0a6cdf2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MCommunicationQueue&amp; MProtocol::GetCommandQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>M_NO_PROGRESS_MONITOR. </p>
<p>Get the command queue of the protocol.</p>
<p>If the items were added to the queue by Q services, and no QCommit is performed yet, the queue is not empty. </p>

</div>
</div>
<a class="anchor" id="a17ad7accc31c929f4a4b8ff4fbc13549"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetCountApplicationLayerServicesFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of Application Layer services that have failed. </p>
<p>The count is nullified when the connection is created, or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab290272e66fd881e1d67010d44451376"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetCountApplicationLayerServicesRetried </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of Application Layer services that have been retried. </p>
<p>The count is nullified when the connection is created, or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued. For some protocols the application layer retries never take place, in which case this property will remain at zero.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a367a451ecf3e98ef7363fa98e53e6add"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetCountApplicationLayerServicesSuccessful </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of Application Layer services that have been successfully processed. </p>
<p>The count is nullified when the protocol is created, and when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is called.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a80d9dd2722b89549334dbf3ea785052a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetCountLinkLayerPacketsFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of data link layer packets failed. </p>
<p>The count is nullified when the connection is created, or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued. Some protocols, such as <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, do not have a link layer, therefore, they will not increment this counter.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab563dd4909235f42bf80bd5a7d77e05b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetCountLinkLayerPacketsRetried </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of Link Layer packets that have been retried. </p>
<p>The count is nullified when the connection is created, or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued. Some protocols, such as <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, do not have a link layer, therefore, they will not increment this counter.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a425ba7737c1a7033a784e732539fd442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetCountLinkLayerPacketsSuccessful </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of Link Layer packets that have been successfully processed. </p>
<p>The count is nullified when the connection is created, or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued. Some protocols, such as <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, do not have a link layer, therefore, they will not increment this counter.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.2.17.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ada79d1deee2f2b2c57f4c0733f9c5670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::GetKeepSessionAlive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the protocol should keep session alive in case of long inactivity.</p>
<p>When KeepSessionAlive is true, the session is kept from timing out. The feature can also be used to prevent an idling connection from being closed. What is done to keep the session alive is protocol dependent, but usually involves repeatedly sending some type of communication request to the meter. For some sessionless protocols this property has no effect.</p>
<p>The session is being kept alive by a background thread that is watching for the current value of property <a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a>. When <a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a> is true, the background communication is performed. Errors raised on the background can be silenced if <a class="el" href="class_m_protocol.html#a26c53c968bd097ffaddee8fb679a3f9d">IsConnected</a> value was false. Otherwise, the session keeping errors will be thrown to the foreground thread at the next communication event, such as <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>. Another place that checks and throws an error collected by the background thread is the assignment to KeepSessionAlive property itself. Therefore, the following will check for an error, and throw it if it was present: </p><div class="fragment"><div class="line">protocol.SetKeepSessionAlive(protocol.GetKeepSessionAlive()); <span class="comment">// C++</span></div></div><!-- fragment --><p>When KeepSessionAlive is false, the session will time out or the connection will be closed according to the protocol rules.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.2.6.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The session will not time out.</li>
<li>False [0] : The session will time out according to the protocol rules.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823" title="Whether the protocol is in session. ">IsInSession</a> - whether the session keeping is active. </dd></dl>

</div>
</div>
<a class="anchor" id="ace692f1af6dbb0a33512f5582adec430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_progress_action.html">MProgressAction</a>* MProtocol::GetLocalProgressAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to the currently preset local action in progress monitor. </p>
<p>If progress monitor is not set, or if it does not have local action, dummy action is returned. </p>

</div>
</div>
<a class="anchor" id="a86283365bd46d047e5dbc0048b7b00cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetMaximumRoundTripTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum measured approximate packet round trip time over the link layer. </p>
<p>A 'round trip' is defined as the amount of time elapsed from the last byte sent to the first byte received back. Each trip is monitored, and the following properties updated accordingly: <a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a>, <a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a>, and <a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a>.</p>
<p>The round trip times are not updated when there is a timeout, even if there were garbage characters on the line. The round trip times are nullified when the connection is created or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 4.0.43.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a85938b8449e0ec4f2d8ccbe0b07e6d07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::GetMeterIsLittleEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Primary data order of the device, whether it is little endian.</p>
<p>This information is used by some protocol implementations, for example, for ANSI procedures/functions implementation. Such protocols have application-level fields that depend on the protocol byte order.</p>
<p>It is only necessary to set this property when communicating to a device of different endianity as the protocol default. When communicating through the upper library levels this property can be set automatically.</p>
<dl class="section user"><dt>Default value:</dt><dd>Depends on the protocol type. Most of the protocols are little endian, while some legacy ones are big endian.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : Little Endian</li>
<li>False [0] : Big Endian </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af1d1d46c353f5e4f8cac3bf8ed8dc7a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MProtocol::GetMinimumRoundTripTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the minimum measured approximate packet round trip time over the link layer. </p>
<p>A 'round trip' is defined as the amount of time elapsed from the last byte sent to the first byte received back. Each trip is monitored, and the following properties updated accordingly: <a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a>, <a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a>, and <a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a>.</p>
<p>The round trip times are not updated when there is a timeout, even if there were garbage characters on the line. The round trip times are nullified when the connection is created or when <a class="el" href="class_m_protocol.html#adb502e0b67a62153f70d818e0fec138a">ResetCounts</a> is issued.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 4.0.43.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>0 .. UINT32 </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6a1fa960c9550b02aa815a4cc2ec1f5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned MProtocol::GetNumberOfDataLinkPackets </td>
          <td>(</td>
          <td class="paramtype">MCommunicationCommand::CommandType&#160;</td>
          <td class="paramname"><em>typeOfRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>applicationLayerDataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of data link packets that are required for a given request, provided an optional size of the application data. </p>
<p>Like for table read, this will be the expected size of the table to read, and for the table write this is the size of the table to be written. For function execution this is the sum of request and response sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeOfRequest</td><td>The type of the request, the value within the enumeration range. There is a debug check for the value. </td></tr>
    <tr><td class="paramname">applicationLayerDataSize</td><td>Table size or the sum of function request and response size, whatever comprises the application layer of the given command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated number of link layer packets to process the request. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7eb073d8a88ba1a5f741e5ba5ef35e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::GetPassword </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Application level password of the protocol.</p>
<p>The Password property is the binary value that is used to gain access to the device. No interpretation of C escape character sequences is performed on this string.</p>
<p>Many protocols will typically use password in the StartSession sequence, while some, such as sessionless mode of <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, will send password at every request.</p>
<p>The password can have less characters than the maximum number of characters allowed. In this case, during the communication, the password will be padded with a fill character (different for each protocol). For example, if an 8 character password is set to "1111", then the password "1111 " is transmitted during communications, while Password property will continue to report "1111". The padded characters are significant, and the password stored in the meter must exactly match the password used during communications (including the fill characters) or an error is generated.</p>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>Twenty ASCII zero digits ("00000000000000000000") for the <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a>, <a class="el" href="class_m_protocol_c1221.html">MProtocolC1221</a>, and <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>"12345678901234567890" : Passwords for the <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a>, <a class="el" href="class_m_protocol_c1221.html">MProtocolC1221</a>, and <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a> protocols (A3, A1800 meters) can have a maximum of 20 characters. If the specified password is less than 20 characters, then the remaining characters are filled with blank spaces during communication. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aff5d6a64af11464ea5e932188affd950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a>&amp; MProtocol::GetPasswordList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Password list for the protocol.</p>
<p>The password lists, when not empty, overwrite the <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> property. In such case, passwords from the password list are applied in the ascending order until a successful entry is found. If none exists, the last error received during list processing is thrown.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#ab7eb073d8a88ba1a5f741e5ba5ef35e3">GetPassword</a> </dd>
<dd>
<a class="el" href="class_m_protocol.html#a02d5080403580f3317fc9eade19882d4" title="Set the password list for the protocol to none, so the SetPassword property is used. ">ClearPasswordList</a> - clear the password list </dd>
<dd>
<a class="el" href="class_m_protocol.html#a5483f327ca2dcb745fdb14494848fa01" title="Add a password to the password list. ">AddToPasswordList</a> - add entry to password list </dd>
<dd>
<a class="el" href="class_m_protocol.html#a699b038b23f879820284d27f3ecc3768" title="Return the entry, which was successfully tried with the meter. ">GetPasswordListSuccessfulEntry</a> - shall be called after successful start session to know which password list worked. </dd></dl>

</div>
</div>
<a class="anchor" id="a699b038b23f879820284d27f3ecc3768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MProtocol::GetPasswordListSuccessfulEntry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the entry, which was successfully tried with the meter. </p>
<p>If there was no attempt to try the password list, or when none of the entries were successful, this property will be equal to -1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#aff5d6a64af11464ea5e932188affd950">GetPasswordList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04125b705921153a4bde750649a9ecc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a>* MProtocol::GetProgressMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the progress monitor, if exists </p>

</div>
</div>
<a class="anchor" id="abb127ad977cc65921c71f65c56bc427d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MProtocol::IdentifyMeter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sessionIsStarted</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identify the meter version and other information if the protocol is known.</p>
<p>Note that this is not an ANSI Identify protocol command. Typically, IdentifyMeter would be used when creating a meter of a known type, but an unknown version.</p>
<p>The IdentifyMeter service wraps the start and end session around the identification task. To call IdentifyMeter, one has to connect to the meter, but the session should not be started. This differs from QIdentifyMeter which does NOT wrap start and end session around the identification task.</p>
<p>Typically, IdentifyMeter returns only one identify string that identifies the meter. However, identify strings can be created for the option boards installed on a meter. In this case, the returned string can contain multiple identify strings, where the the meter's identify string is listed first and identify strings are separated by a semi- colon. Use GetIdentifyStrings to separate multiple identify strings.</p>
<p>The identify string is formatted as a J command and may not be suitable for showing to the user as it can contain non-printable characters. Instead, it is formatted for easy processing by a script or a program. A typical identify string returned for an A3 meter with LANOB option board follows (wrapped for clarity):</p>
<p>Example of A3 Identify string followed by LANOB's identify string, spaces and new lines used for clarity: </p><div class="fragment"><div class="line">J00[MANUFACTURER:EE ]</div><div class="line">   [ED_MODEL:A3R ]</div><div class="line">   [HW_VERSION_REVISION:1.2]</div><div class="line">   [SW_VERSION_REVISION:2.3]</div><div class="line">   [MFG_SERIAL_NUMBER: ]</div><div class="line">   [NUMBER_OF_OPTION_BOARDS:2]</div><div class="line">   [OB1_Type:0M]</div><div class="line">   [OB1_SSPEC:000237]</div><div class="line">   [OB1_REVISION:1.0]</div><div class="line">   [OB1_POSITION:1]</div><div class="line">   [OB2_Type:0K]</div><div class="line">   [OB2_SSPEC:000239]</div><div class="line">   [OB2_REVISION:1.3]</div><div class="line">   [OB2_POSITION:2];</div><div class="line">J00[MANUFACTURER:EE ]</div><div class="line">   [ED_MODEL:REXILC ]</div><div class="line">   [HW_VERSION_REVISION:1.0]</div><div class="line">   [SW_VERSION_REVISION:1.3]</div><div class="line">   [MFG_SERIAL_NUMBER:LANOB ]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a153d408f472c69796e0653a3d6aa8a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MProtocol::IdentifyMeterWithContext </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sessionIsStarted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_protocol.html#ad48fb8eb277613de30019f264fdeb271">TableRawDataVector</a> *&#160;</td>
          <td class="paramname"><em>tablesRead</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the meter if the protocol is known (note this is not an ANSI Identify protocol command). </p>
<p>If the first parameter is true, the service assumes the session is open, and it will not start the session, or close it. The second parameter, if it is not NULL, is filled with the data from tables, which IdentifyMeter had to read from the meter during its attempts to fetch the necessary information from the meter. This table vector can be used in order to minimize the communication with the meter, if this task has its place.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is connected. Otherwise a channel-related exception is thrown that tells about failure. The meter is indeed the one, which is able to talk the specific protocol. Otherwise the protocol-specific exception is thrown that signals the failure of communicating through the channel. If the session is started already, the first parameter has to be true, or the behavior is undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sessionIsStarted</td><td>True if the method should not start and end the session as part of identification. </td></tr>
    <tr><td class="paramname">tablesRead</td><td>Pointer of data vector for tables that were read as part of the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identify string </dd></dl>

</div>
</div>
<a class="anchor" id="a60bffec5063153017e67fdd4d667f5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::IncrementCountApplicationLayerServicesFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the number of application layer services failed. </p>
<p>This can be used by the outside application, which is willing to treat its actions as an application layer failure. </p>

</div>
</div>
<a class="anchor" id="ae57c110d281bbb7779b7bbbfc12b5b1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::IncrementCountApplicationLayerServicesRetried </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the number of application layer services retried. </p>
<p>This can be used by the outside application, which is willing to treat its actions as an application layer retry. </p>

</div>
</div>
<a class="anchor" id="af25fc291953561e4eb248174bc07856e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::IncrementCountApplicationLayerServicesSuccessful </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the number of application layer services successfully processed. </p>
<p>This can be used by the outside application, which is willing to treat its actions as an application layer service. </p>

</div>
</div>
<a class="anchor" id="a0c162f21b2b82300532288a630238cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::IncrementCountLinkLayerPacketsFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the number of data link layer packets failed. </p>
<p>This can be used by the outside application, which is willing to treat its actions as a link layer failure. </p>

</div>
</div>
<a class="anchor" id="a970a90af9476866a8e6b39dbef89c627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::IncrementCountLinkLayerPacketsRetried </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the number of data link layer packets retried. </p>
<p>This can be used by the outside application, which is willing to treat its actions as a link layer retry. </p>

</div>
</div>
<a class="anchor" id="a735e02e29d2dd177059a8cdc15eb6a71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::IncrementCountLinkLayerPacketsSuccessful </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the number of data link layer packets successfully processed. </p>
<p>This can be used by the outside application, which is willing to treat its actions as a link layer success. </p>

</div>
</div>
<a class="anchor" id="a159f02566ad282534dca1cc48ca6a9be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::IsChannelOwned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the channel is owned by this protocol.</p>
<p>When the channel is owned, it will be deleted by protocol destructor, or at the event of channel reassignment to the protocol. </p>

</div>
</div>
<a class="anchor" id="a26c53c968bd097ffaddee8fb679a3f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::IsConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the protocol is currently connected. </p>
<p>This method is a straightforward facade to <a class="el" href="class_m_channel.html#ae6738f1560bb852d71c53da9892575f9">MChannel::IsConnected</a>. It reflects the assumption the communication component has about the channel state, it does not guarantee that the next action with the channel will be successful. Issue the <a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94" title="Initializes the channel and establishes the connection with the peer. ">Connect()</a> service to establish the connection and the <a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8" title="Severs the connection between the computer and the end device. ">Disconnect()</a> service to terminate the connection.</p>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True : The connection has been established.</li>
<li>False : The connection has not been established.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823" title="Whether the protocol is in session. ">IsInSession</a> </dd>
<dd>
<a class="el" href="class_m_channel.html#ae6738f1560bb852d71c53da9892575f9" title="Returns the current connection state of the channel. ">MChannel.IsConnected</a> </dd>
<dd>
<a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94" title="Initializes the channel and establishes the connection with the peer. ">Connect</a> </dd>
<dd>
<a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8" title="Severs the connection between the computer and the end device. ">Disconnect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a290983a74af9495c1a5f66d7e1d4b823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::IsInSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the protocol is in session. </p>
<p>This is a generic method, and the meaning of 'session' depends on protocol type and mode. The notion of a session exists in most protocols, and for these protocols the property indicates whether MeteringSDK considers the device to be in session mode. The current implementation, however, does not respect session timeout, therefore, when the client protocol is in session, the device might have timed out already.</p>
<p>Some protocols such as <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a> do not have session state, however for them this property will behave as if the notion of a session is present, such as:</p><ul>
<li>Initially, IsInSession is false</li>
<li>StartSession, if successful, sets IsInSession to true even though it might not result in any communication</li>
<li>Any successful table or function operation sets IsInSession to true</li>
<li>EndSession, even a dummy one, sets IsInSession to false</li>
<li>Disconnect sets IsInSession to false</li>
</ul>
<p>When both this property and <a class="el" href="class_m_protocol.html#ada79d1deee2f2b2c57f4c0733f9c5670">GetKeepSessionAlive</a> are true, and session keeping is implemented for this protocol type or mode, the value of IsInSession will indicate whether the session keeping is being done. Session keeping sequence, however, can be interrupted by an error.</p>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True : The protocol is in session state.</li>
<li>False : The protocol is not in session.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a26c53c968bd097ffaddee8fb679a3f9d" title="Tells whether the protocol is currently connected. ">IsConnected</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a918229482eba7cf7a7901dae6c3796cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QAbort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the commands in the queue, or cancel the ongoing background communication. </p>
<p>If the queue is empty when the QAbort is issued, the queue remains empty and no error is generated. If the queue has commands, but they are not being processed (QCommit has not been issued), then the queue is cleared and no error is generated.</p>
<p>If the queue is being executed asynchronously (QCommit(true) then QAbort will tell MCOM to stop executing the commands in the queue and clear all remaining commands from the queue. If the abort is requested while a table is being written, the write request is completed before the abort request will be processed. No attempt is made to end (or clean up) the session. Note that QAbort returns immediately, it does not wait for the communications to stop. How long it takes for MCOM to respond to the QAbort request depends on the protocol and the tasks running on the PC. Typically, one could expect the time to be less than 500 mSec. To determine when communications have been terminated, <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> must be checked. For communications that have been stopped by a QAbort, <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> will raise an error. If <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> is not checked and allowed to raise the error, then the next Q Command (such as QStartSession), will raise an error. Most likely the error will indicate "Invalid operation during active background communication". This is because the asynchronous communication background thread can not terminate while there is an error to hand back to the foreground thread that started the asynchronous communications. Asynchronous communications should always check <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> until it is True or raises an error.</p>
<p>Note that QAbort and <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> are issued immediately, they do NOT require a <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>. </p>

</div>
</div>
<a class="anchor" id="aad16d887101c1e2ef14894201aa75a17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::QCommit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asynchronously</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes all operations in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>If no operations were queued then QCommit does nothing.</p>
<p>Protocol supports synchronous and asynchronous communications. When synchronous communications are initiated, QCommit will not return until all commands in the queue have been executed or an error occurs. This prevents the calling application from performing any other work on that thread. When asynchronous communications are initiated, the QCommit will return immediately while the commands in the queue are executed in the background. The calling application is free to perform other work while waiting for the communications to complete. The application will have to check QIsDone to determine when asynchronous communications have completed. The application can also call QAbort to stop and clear the commands from the queue.</p>
<p>Should an error occur during synchronous communications, it will be reported immediately on the QCommit. Should an error occur during asynchronous communications, the error is raised on QIsDone. In either case, no attempt is made to execute the remaining commands in the queue.</p>
<p>The command queue will always be cleared after a QCommit, regardless of success or failure of the operations that were queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asynchronously</td><td>Whether to perform the communication on the background, asynchronously.</td></tr>
  </table>
  </dd>
</dl>
<p>The following sequences are completely equivalent: </p><div class="fragment"><div class="line">protocol.Connect()             <span class="comment">// synchronously connect</span></div><div class="line">protocol.StartSession()        <span class="comment">// synchronously start the session</span></div><div class="line">table = protocol.TableRead(0)  <span class="comment">// read table zero</span></div><div class="line">protocol.EndSession()          <span class="comment">// here end the session</span></div><div class="line">protocol.Disconnect()          <span class="comment">// synchronously disconnect</span></div></div><!-- fragment --><p> or: </p><div class="fragment"><div class="line">protocol.QConnect();          <span class="comment">// declare we will be connecting</span></div><div class="line">protocol.QStartSession();     <span class="comment">// declare we will be starting session</span></div><div class="line">protocol.QTableRead(0, 0, 0)  <span class="comment">// queue table read, have no expectation about its size</span></div><div class="line">protocol.QEndSession()        <span class="comment">// after that we will be ending the session</span></div><div class="line">protocol.QDisconnect();       <span class="comment">// declare we will be disconnecting</span></div><div class="line">protocol.QCommit()            <span class="comment">// commit the will, the sequence is executed</span></div><div class="line">table = protocol.QGetTableData(0, 0); <span class="comment">// get the result data or table 0, id 0</span></div></div><!-- fragment --><p> Case of background communication in a separate thread: </p><div class="fragment"><div class="line">protocol.QConnect();          <span class="comment">// declare we will be connecting</span></div><div class="line">protocol.QStartSession();     <span class="comment">// declare we will be starting session</span></div><div class="line">protocol.QTableRead(0, 0, 0)  <span class="comment">// queue table read, have no expectation about its size</span></div><div class="line">protocol.QEndSession()        <span class="comment">// after that we will be ending the session</span></div><div class="line">protocol.QDisconnect();       <span class="comment">// declare we will be disconnecting</span></div><div class="line">protocol.QCommit(<span class="keyword">true</span>);       <span class="comment">// commit on the background</span></div><div class="line"><span class="keywordflow">while</span> ( !protocol-&gt;QIsDone() )</div><div class="line">{</div><div class="line">     .... <span class="keywordflow">do</span> anything</div><div class="line">}</div><div class="line">table = protocol.QGetTableData(0, 0); <span class="comment">// get the result data or table 0, id 0</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a68ade785b2e4da0b69c4aadeffc82942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QConnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a Connect command in the queue. </p>
<p>The QConnect can be paired with <a class="el" href="class_m_protocol.html#a474d3857824f0fa028644556d0a09ca0">QDisconnect</a> or <a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8">Disconnect</a>. Protocol supports synchronous and asynchronous communications.</p>
<p>When synchronous communications are initiated, <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> will not return until all commands in the queue have been executed or an error occurs. This prevents the calling application from performing any other work on that thread. When asynchronous communications are initiated, the <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> returns immediately while the commands in the queue are executed in the background. The calling application is free to perform other work while waiting for the communications to complete. The application will have to check <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> to determine when asynchronous communications have completed. The application can also call <a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> to stop and clear the commands from the queue. <a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> can be useful for Connect sequences that take a long time (such as the 30-60 seconds it takes to connect to a modem). </p>

</div>
</div>
<a class="anchor" id="a474d3857824f0fa028644556d0a09ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QDisconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a Disconnect command in the queue. </p>
<p>The QDisconnect can be paired with <a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">QConnect</a> or <a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94">Connect</a>. Note that an commands are cleared from the queue when an error occurs. If the QDisconnect is placed in the queue and an error occurs before it can be issued, it will be cleared from the queue along with the remaining unexecuted commands. Error handling routines must issue a <a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8">Disconnect</a> (or QDisconnect/<a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>), in order to disconnect from the channel. For this reason, it is recommended that users use <a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8">Disconnect</a> instead of <a class="el" href="class_m_protocol.html#a474d3857824f0fa028644556d0a09ca0">QDisconnect</a> for most cases.</p>
<p>Protocol supports synchronous and asynchronous communications. When synchronous communications are initiated, <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> will not return until all commands in the queue have been executed or an error occurs. This prevents the calling application from performing any other work on that thread. When asynchronous communications are initiated, the <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> returns immediately while the commands in the queue are executed in the background. The calling application is free to perform other work while waiting for the communications to complete. The application will have to check <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> to determine when asynchronous communications have completed. The application can also call <a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> to stop and clear the commands from the queue. </p>

</div>
</div>
<a class="anchor" id="aa1fc80e08ae3337deac67b5503ae7b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QEndSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an end session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>When QEndSession is executed by a <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>, the active session with the meter will be terminated. Typically, this is done using the protocol's logoff service. If the protocol does not support a start/end session, such as sessionless <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, then QEndSession does nothing and does not generate an error. This is so programs that support multiple meters and protocols can be written with the <a class="el" href="class_m_protocol.html#afc217114a8b4928f6d62e13ebf826e7f">QStartSession</a> and <a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a>.</p>
<p>For protocols that support start/end session, once an QEndSession command is executed, no other commands can be sent to the meter until after the next QStartSession. The communications link to the meter will not be severed by QEndSession. For instance, a modem channel will remain on-line after this operation. To sever the communications link to the meter requires using the <a class="el" href="class_m_protocol.html#a72c328afee944e7e977092b8da2887f8" title="Severs the connection between the computer and the end device. ">Disconnect()</a> method. The Disconnect method should only be used when no more communications to the meter are required. </p><div class="fragment"><div class="line">protocol.QStartSession()</div><div class="line">protocol.QTableWrite(tableNum, data)</div><div class="line">protocol.QEndSession()</div><div class="line">protocol.QCommit()</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a9b99c12375946ef53645de3b3807aa24" title="EndSessionNoThrow request is queued. ">QEndSessionNoThrow</a> - silences any errors if they appear </dd></dl>

</div>
</div>
<a class="anchor" id="a9b99c12375946ef53645de3b3807aa24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QEndSessionNoThrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EndSessionNoThrow request is queued. </p>
<p>This service is part of queue communication interface. In all ways it is similar to <a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a> except that it silently swallows any error, should it appear. Therefore, this variant is very convenient in error handlers that need to ensure that the session has ended.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77" title="Adds an end session command to MProtocol&#39;s command queue. ">QEndSession</a> - throws errors </dd></dl>

</div>
</div>
<a class="anchor" id="a63adc1ca9487420d0f0d4f397892a6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QFunctionExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a function without data request in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a> command queue. </p>
<p>This service is part of queue communication interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the function to be placed into the queue. Typically, this is an integer, but some protocols do allow it to be a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a144ccc940c3f27964397d8fb2072a4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QFunctionExecuteRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a function with request data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the function to be placed into the queue. Typically, this is an integer, but some protocols do allow it to be a string.</td></tr>
    <tr><td class="paramname">request</td><td>The function data to send to the meter. It must be in the form of a byte array and must have the number of bytes that corresponds to the specified function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4a0c9d99fb75dc21283a5d3fcdabb68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QFunctionExecuteRequestResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>estimatedResponseSize</em> = <code><a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a function with request and response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface. The response data will be available after the <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> method is issued. Use the <a class="el" href="class_m_protocol.html#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">QGetFunctionData</a> method to retrieve the bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the function to be placed into the queue. Typically, this is an integer, but some protocols do allow it to be a string.</td></tr>
    <tr><td class="paramname">request</td><td>The function data to send to the meter. It must be in the form of a byte array and must have the number of bytes that corresponds to the specified function.</td></tr>
    <tr><td class="paramname">id</td><td>Operation identifier to associate with the data returned from the device. When processing tables or functions with different numbers, this can be any value, as tables and functions can be identified by their numbers, however when using the same table or function number in the same queue, this ID should be unique, so the identification is possible.</td></tr>
    <tr><td class="paramname">estimatedResponseSize</td><td>optional parameter. If provided, this is the size of the response. If not provided, this is estimated to be large enough to fit any possible value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8df65accadd116253feed8a730c8664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QFunctionExecuteResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>estimatedResponseSize</em> = <code><a class="el" href="class_m_protocol.html#acb2efd86856570ae339320ade2841e70aaef9535b4db5850e5d4e61c61c2c7cd0">DEFAULT_ESTIMATED_RESPONSE_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a function with response data in <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface. The response data will be available after the <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> method is issued. Use the <a class="el" href="class_m_protocol.html#ac5bdb2f1cfd7ec87d68a588dfeaa58a2">QGetFunctionData</a> to retrieve the bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the function to be placed into the queue. Typically, this is an integer, but some protocols do allow it to be a string.</td></tr>
    <tr><td class="paramname">estimatedResponseSize</td><td>optional parameter. If provided, this is the size of the response. If not provided, this is estimated to be large enough to fit any possible value.</td></tr>
    <tr><td class="paramname">id</td><td>Operation identifier to associate with the data returned from the device. When processing tables or functions with different numbers, this can be any value, as tables and functions can be identified by their numbers, however when using the same table or function number in the same queue, this ID should be unique, so the identification is possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5bdb2f1cfd7ec87d68a588dfeaa58a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::QGetFunctionData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the function response data after the function has been successfully executed in QCommit. </p>
<p>The data remains available after commit has performed, but until the next queue starts to be built.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Number of the function that was executed, whatever is given to <a class="el" href="class_m_protocol.html#ac8df65accadd116253feed8a730c8664">QFunctionExecuteResponse</a> or <a class="el" href="class_m_protocol.html#af4a0c9d99fb75dc21283a5d3fcdabb68">QFunctionExecuteRequestResponse</a></td></tr>
    <tr><td class="paramname">id</td><td>If the same table was read several times in the same session, use this id to distinguish between individual calls of <a class="el" href="class_m_protocol.html#a08880e3f2b73a5b0a099514b0a71c93f">QTableRead</a> or <a class="el" href="class_m_protocol.html#a36a88700905af18de1934453c800ae9d">QTableReadPartial</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function data bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a81cb0e39b25f7450228ce092b358bf55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> MProtocol::QGetIdentifyMeterData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the identify meter string after the QIdentifyMeter has been successfully performed in QCommit. </p>
<p>Typically, QGetIdentifyMeterData returns only one identify string that identifies the meter. However, identify strings can be created for the option boards installed on a meter. In this case, the returned string can contain multiple identify strings, where the the meter's identify string is listed first and identify strings are separated by a semi- colon. Use GetIdentifyStrings to separate multiple identify strings.</p>
<p>The identify string is formatted as a J command and may not be suitable for showing to the user as it can contain non-printable characters. Instead, it is formatted for easy processing by a script or a program. A typical identify string returned for an A3 meter with LANOB option board follows (wrapped for clarity): </p><div class="fragment"><div class="line">J00[MANUFACTURER:EE ] <span class="comment">// A3&#39;s identify string //</span></div><div class="line">    [ED_MODEL:A3R ]</div><div class="line">    [HW_VERSION_REVISION:1.2]</div><div class="line">    [SW_VERSION_REVISION:2.3]</div><div class="line">    [MFG_SERIAL_NUMBER: ]</div><div class="line">    [NUMBER_OF_OPTION_BOARDS:2]</div><div class="line">    [OB1_Type:0M]</div><div class="line">    [OB1_SSPEC:000237]</div><div class="line">    [OB1_REVISION:1.0]</div><div class="line">    [OB1_POSITION:1]</div><div class="line">    [OB2_Type:0K]</div><div class="line">    [OB2_SSPEC:000239]</div><div class="line">    [OB2_REVISION:1.3]</div><div class="line">    [OB2_POSITION:2];</div><div class="line">J00[MANUFACTURER:EE ] <span class="comment">// LANOB&#39;s identify string //</span></div><div class="line">    [ED_MODEL:REXILC ]</div><div class="line">    [HW_VERSION_REVISION:1.0]</div><div class="line">    [SW_VERSION_REVISION:1.3]</div><div class="line">    [MFG_SERIAL_NUMBER:LANOB ]</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result identify string </dd></dl>

</div>
</div>
<a class="anchor" id="aeb4db8b1de02405df260fbeea22f22d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::QGetTableData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the table data after the table read has been successfully performed by QCommit. </p>
<p>The data remains available after commit has performed, but until the next queue starts to be built.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Number of the table that was read, whatever is given to <a class="el" href="class_m_protocol.html#a08880e3f2b73a5b0a099514b0a71c93f">QTableRead</a> or <a class="el" href="class_m_protocol.html#a36a88700905af18de1934453c800ae9d">QTableReadPartial</a></td></tr>
    <tr><td class="paramname">id</td><td>If the same table was read several times in the same session, use this id to distinguish between individual calls of <a class="el" href="class_m_protocol.html#a08880e3f2b73a5b0a099514b0a71c93f">QTableRead</a> or <a class="el" href="class_m_protocol.html#a36a88700905af18de1934453c800ae9d">QTableReadPartial</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Table data bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ace4c0c4e13e1a1a616be8ad1e4793290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QIdentifyMeter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an IdentifyMeter task in the queue. </p>
<p>The commands stored in the command queue will be sent to the meter when <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> is issued. The identify meter task identifies the meter version and other information if the protocol is known (note that this is not an ANSI Identify protocol command). Typically, QIdentifyMeter is used when creating a meter of a known type, but an unknown version.</p>
<p>The QIdentifyMeter service does NOT wrap the start and end session around the identification task. To use QIdentifyMeter, one has to connect to the meter and start the session. This differs from <a class="el" href="class_m_protocol.html#abb127ad977cc65921c71f65c56bc427d">IdentifyMeter</a> which wraps start and end session around the identification task.</p>
<p>The identification information is retrieved with <a class="el" href="class_m_protocol.html#a81cb0e39b25f7450228ce092b358bf55">QGetIdentifyMeterData</a> after QIdentifyMeter has been successfully QCommit-ted (all requests in queue sent to the meter). </p>

</div>
</div>
<a class="anchor" id="a6002f961375678606b6e281a624db996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::QIsBackgroundCommunicationProgressing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the background communication is still progressing. </p>
<p>This is different from <a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> in the sense that it will be true only if there is a background activity. </p><div class="fragment"><div class="line"><span class="comment">//             ... QNeedToCommit() == false, QIsBackgroundCommunicationProgressing() == false</span></div><div class="line">protocol.QConnect</div><div class="line">protocol.QStartSession</div><div class="line">protocol.QEndSession</div><div class="line">protocol.QDisconnect</div><div class="line"><span class="comment">//             ... QNeedToCommit() == false, QIsBackgroundCommunicationProgressing() == false</span></div><div class="line">protocol.QCommit(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//             ... QNeedToCommit() == false, QIsBackgroundCommunicationProgressing() == true</span></div><div class="line"><span class="comment">//             ...</span></div><div class="line"><span class="keywordflow">while</span> ( !protocol.QNeedToCommit() )</div><div class="line">    <a class="code" href="class_m_timer.html#a4d107df93fe5aef90a4f7f255075a2da">MUtilities::Sleep</a>(200);</div><div class="line"><span class="comment">//             ... QNeedToCommit() == true, QIsBackgroundCommunicationProgressing() == true</span></div><div class="line">protocol.QCommit(<span class="keyword">false</span>);</div><div class="line"><span class="comment">//             ... QNeedToCommit() == false, QIsBackgroundCommunicationProgressing() == false</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac35ae0e64619dfc237c154a44ec578c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::QIsDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines <a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> with the following <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> in case all commands in the queue have been sent. </p>
<p>The relationship of this property with <a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00">QNeedToCommit</a> is shown below: </p><div class="fragment"><div class="line"><span class="comment">//             ... QIsDone() == true, QNeedToCommit() == false</span></div><div class="line">protocol.QConnect</div><div class="line">protocol.QStartSession</div><div class="line">protocol.QEndSession</div><div class="line">protocol.QDisconnect</div><div class="line"><span class="comment">//             ... QIsDone() == true, QNeedToCommit() == false</span></div><div class="line">protocol.QCommit(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//             ... QIsDone() == false, QNeedToCommit() == true</span></div><div class="line"><span class="comment">//             ...</span></div><div class="line"><span class="keywordflow">while</span> ( !protocol.QIsDone() )</div><div class="line">    <a class="code" href="class_m_timer.html#a4d107df93fe5aef90a4f7f255075a2da">MUtilities::Sleep</a>(200);</div><div class="line"><span class="comment">//             ... QIsDone() == true, QNeedToCommit() == true</span></div><div class="line"><span class="comment">//             ... No need to call meter.QCommit(false)</span></div></div><!-- fragment --><p>This property is used when QCommit was issued asynchronously. During asynchronous communications, the application is free to perform other work while waiting for the communications to complete. The application can periodically check QIsDone to determine if MCOM has completed processing the commands in the queue. For asynchronous communications, QIsDone will raise any communication errors. (For synchronous communications, any errors will be raised on QCommit.)</p>
<p>Asynchronous communications should check QIsDone until it reports True or raises an error. The asynchronous communication background thread can not terminate until QIsDone has been checked and it reports True or raises an error. If QIsDone is not checked until one of these states occur, then the next Q Command (such as QStartSession), will raise an error, even if the communications have completed. Most likely the error will indicate "Invalid
operation during active background communication".</p>
<p>Note that QIsDone and <a class="el" href="class_m_protocol.html#a918229482eba7cf7a7901dae6c3796cb">QAbort</a> are issued immediately, they do NOT require a <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>. </p>

</div>
</div>
<a class="anchor" id="ac73d91a5b3aeec57221ca2ee0cdbef00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MProtocol::QNeedToCommit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not it is time to call QCommit(true) in order to sync with the background thread. </p>
<p>In case M_NO_MCOM_PROTOCOL_THREAD is nonzero during compilation, this service is not present. Asynchronous communication will not be supported in this case.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#ac35ae0e64619dfc237c154a44ec578c1">QIsDone</a> that combines <a class="el" href="class_m_protocol.html#ac73d91a5b3aeec57221ca2ee0cdbef00" title="Whether or not it is time to call QCommit(true) in order to sync with the background thread...">QNeedToCommit</a> with <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a> when the communication finishes. </dd></dl>

</div>
</div>
<a class="anchor" id="afc217114a8b4928f6d62e13ebf826e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QStartSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a start session command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>QStartSession performs the protocol services required to gain access to the meter, so that tables can be read and written and functions can be executed. Before committing the start session request, a connection with the meter must have been established using <a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94" title="Initializes the channel and establishes the connection with the peer. ">Connect()</a> or <a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">QConnect</a>.</p>
<p>When QStartSession is executed by <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>, an active session with the meter is initiated. The start session action is not a single protocol command but rather a sequence of commands that establish an active communication session with the meter. Generally this sequence of commands handles handshaking with the meter, presenting a password, receiving permission to proceed, and negotiating various protocol settings. The exact sequence of steps performed by this method depends on the <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a> Type. If the protocol does not support a start session, then QStartSession does nothing and does not generate an error. This is so programs that support multiple meters and protocols can be written with the QStartSession and <a class="el" href="class_m_protocol.html#aa1fc80e08ae3337deac67b5503ae7b77">QEndSession</a>.</p>
<div class="fragment"><div class="line">protocol.QStartSession()</div><div class="line">protocol.QTableWrite(tableNum, data)</div><div class="line">protocol.QEndSession()</div><div class="line">protocol.QCommit()</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a08880e3f2b73a5b0a099514b0a71c93f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QTableRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>expectedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a ReadTable command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface. The result table data can be retrieved by using the <a class="el" href="class_m_protocol.html#aeb4db8b1de02405df260fbeea22f22d9">QGetTableData</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the table to be placed into the queue. The format is protocol dependent. In can be a numeric value, as for the case of <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a> or <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, or even a string if the protocol supports strings.</td></tr>
    <tr><td class="paramname">expectedSize</td><td>Expected table size in bytes. If this is zero, then the entire table will be read. If the protocol does not support full table reads then specifying a size of zero will result in an error being generated.</td></tr>
    <tr><td class="paramname">id</td><td>Operation identifier to associate with the data returned from the device. When processing tables or functions with different numbers, this can be any value, as tables and functions can be identified by their numbers, however when using the same table or function number in the same queue, this ID should be unique, so the identification is possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36a88700905af18de1934453c800ae9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QTableReadPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a partial table read command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the table to be placed into the queue. The format is protocol dependent. In can be a numeric value, as for the case of <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a> or <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, or even a string if the protocol supports it.</td></tr>
    <tr><td class="paramname">offset</td><td>The number of bytes from the beginning of the table where the operation will begin.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read starting from offset.</td></tr>
    <tr><td class="paramname">id</td><td>Operation identifier to associate with the data returned from the device. When processing tables or functions with different numbers, this can be any value, as tables and functions can be identified by their numbers, however when using the same table or function number in the same queue, this ID should be unique, so the identification is possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71251f6cbda5a70e1072e4cf78fcea5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QTableWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the table to be placed into the queue. The format is protocol dependent. In can be a numeric value, as for the case of <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a> or <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, or even a string if the protocol supports it.</td></tr>
    <tr><td class="paramname">data</td><td>This buffer contains the data that will be written to the meter. The size of data determines the size of the buffer to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1568dcd0e0af9c30043f9179fc527632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QTableWritePartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a partial table write command to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>This service is part of queue communication interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Identifies the table to be placed into the queue. The format is protocol dependent. In can be a numeric value, as for the case of <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a> or <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, or even a string if the protocol supports it.</td></tr>
    <tr><td class="paramname">data</td><td>This buffer contains the data that will be written to the meter. The size of data determines the size of the buffer to be written.</td></tr>
    <tr><td class="paramname">offset</td><td>The number of bytes from the beginning of the table where the write operation will begin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7480f82e6934a8535760cf325af5bb35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::QWriteToMonitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the message to write to the Monitor log file to <a class="el" href="class_m_protocol.html" title="Abstraction of a communication protocol. ">MProtocol</a>'s command queue. </p>
<p>The QWriteToMonitor method can be used to make communication transactions more readable by marking key data transactions, such as the start/end of a test.</p>
<p>QWriteToMonitor must be issued after the connection is established with the end device (<a class="el" href="class_m_protocol.html#adb24a5372b721c343add6ae803287e94">Connect</a> or <a class="el" href="class_m_protocol.html#a68ade785b2e4da0b69c4aadeffc82942">QConnect</a>). QWriteToMonitor is different than <a class="el" href="class_m_monitor.html#a680a882357f5226f4264c42daa6f13e0">MMonitor::Write</a> in that Write sends the message to the monitor immediately, whereas QWriteToMonitor is executed as part of the command queue on <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>.</p>
<p>No error is thrown if the Monitor is not listening or the log file is not accumulating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to write to the Monitor log file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a9fb4ac84c215dbf8aa29be17a897b2e4" title="Synchronously write a message to the monitor, if it is connected. ">WriteToMonitor</a> - no-queue version of the method </dd></dl>

</div>
</div>
<a class="anchor" id="afc54b21cfb84791a8e1d9132b33b8a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Muint8 MProtocol::ReadStartByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>setOfValidStartBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>trafficTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the start byte of the packet in a proper way, taking into consideration timeouts and ignoring garbage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setOfValidStartBytes</td><td>- sequence of bytes that are valid start characters. </td></tr>
    <tr><td class="paramname">trafficTimeout</td><td>- how long to wait for arrival of start byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character that was successfully received, one among setOfValidStartBytes.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The start character among those in the set given should be present in the input stream within trafficTimeout period. Otherwise an exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="adb502e0b67a62153f70d818e0fec138a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::ResetCounts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the statistical data for the channel. </p>
<p>Zeroes Out the COUNT_* and *_ROUND_TRIP_TIME properties. The list of properties that are reset follows:</p><ul>
<li><a class="el" href="class_m_protocol.html#a17ad7accc31c929f4a4b8ff4fbc13549">GetCountApplicationLayerServicesFailed</a></li>
<li><a class="el" href="class_m_protocol.html#ab290272e66fd881e1d67010d44451376">GetCountApplicationLayerServicesRetried</a></li>
<li><a class="el" href="class_m_protocol.html#a367a451ecf3e98ef7363fa98e53e6add">GetCountApplicationLayerServicesSuccessful</a></li>
<li><a class="el" href="class_m_protocol.html#a80d9dd2722b89549334dbf3ea785052a">GetCountLinkLayerPacketsFailed</a></li>
<li><a class="el" href="class_m_protocol.html#ab563dd4909235f42bf80bd5a7d77e05b">GetCountLinkLayerPacketsRetried</a></li>
<li><a class="el" href="class_m_protocol.html#a425ba7737c1a7033a784e732539fd442">GetCountLinkLayerPacketsSuccessful</a></li>
<li><a class="el" href="class_m_protocol.html#a86283365bd46d047e5dbc0048b7b00cd">GetMaximumRoundTripTime</a></li>
<li><a class="el" href="class_m_protocol.html#af1d1d46c353f5e4f8cac3bf8ed8dc7a2">GetMinimumRoundTripTime</a></li>
<li><a class="el" href="class_m_protocol.html#a9b45ec72043fe42c32b414d1448fab12">GetAverageRoundTripTime</a></li>
</ul>
<p>If the channel is present, its own <a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b">MChannel::ResetCounts()</a> is called and channel's counts are reset.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_channel.html#a34d8ae5b8df9566ad5ea7762fcdbd51b" title="Reset channel statistical data, so the counters become zeros. ">MChannel::ResetCounts()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a742a84d23ad0eb514b1438877caaf546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_channel.html">MChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Channel associated with this protocol.</p>
<p>When the channel is owned, and a new one is reassigned to the protocol, the previous channel will be deleted. </p>

</div>
</div>
<a class="anchor" id="a4244ee4024965a0ccdc5e374a4f4ce4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetIsChannelOwned </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the channel is owned by this protocol.</p>
<p>When the channel is owned, it will be deleted by protocol destructor, or at the event of channel reassignment to the protocol. </p>

</div>
</div>
<a class="anchor" id="ab17855be033587c380defb411ca4a169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetKeepSessionAlive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the protocol should keep session alive in case of long inactivity.</p>
<p>When KeepSessionAlive is true, the session is kept from timing out. The feature can also be used to prevent an idling connection from being closed. What is done to keep the session alive is protocol dependent, but usually involves repeatedly sending some type of communication request to the meter. For some sessionless protocols this property has no effect.</p>
<p>The session is being kept alive by a background thread that is watching for the current value of property <a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a>. When <a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823">IsInSession</a> is true, the background communication is performed. Errors raised on the background can be silenced if <a class="el" href="class_m_protocol.html#a26c53c968bd097ffaddee8fb679a3f9d">IsConnected</a> value was false. Otherwise, the session keeping errors will be thrown to the foreground thread at the next communication event, such as <a class="el" href="class_m_protocol.html#aad16d887101c1e2ef14894201aa75a17">QCommit</a>. Another place that checks and throws an error collected by the background thread is the assignment to KeepSessionAlive property itself. Therefore, the following will check for an error, and throw it if it was present: </p><div class="fragment"><div class="line">protocol.SetKeepSessionAlive(protocol.GetKeepSessionAlive()); <span class="comment">// C++</span></div></div><!-- fragment --><p>When KeepSessionAlive is false, the session will time out or the connection will be closed according to the protocol rules.</p>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 3.2.6.</dd></dl>
<dl class="section user"><dt>Default value:</dt><dd>False</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : The session will not time out.</li>
<li>False [0] : The session will time out according to the protocol rules.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a290983a74af9495c1a5f66d7e1d4b823" title="Whether the protocol is in session. ">IsInSession</a> - whether the session keeping is active. </dd></dl>

</div>
</div>
<a class="anchor" id="acf7a903d399462a1c758ee69a409ca0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetMeterIsLittleEndian </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLittleEndian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Primary data order of the device, whether it is little endian.</p>
<p>This information is used by some protocol implementations, for example, for ANSI procedures/functions implementation. Such protocols have application-level fields that depend on the protocol byte order.</p>
<p>It is only necessary to set this property when communicating to a device of different endianity as the protocol default. When communicating through the upper library levels this property can be set automatically.</p>
<dl class="section user"><dt>Default value:</dt><dd>Depends on the protocol type. Most of the protocols are little endian, while some legacy ones are big endian.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>MeteringSDK Version 2.1.27.</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>True [1] : Little Endian</li>
<li>False [0] : Big Endian </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abad711cb25a0c60e1789391e8398d670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetPassword </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Application level password of the protocol.</p>
<p>The Password property is the binary value that is used to gain access to the device. No interpretation of C escape character sequences is performed on this string.</p>
<p>Many protocols will typically use password in the StartSession sequence, while some, such as sessionless mode of <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>, will send password at every request.</p>
<p>The password can have less characters than the maximum number of characters allowed. In this case, during the communication, the password will be padded with a fill character (different for each protocol). For example, if an 8 character password is set to "1111", then the password "1111 " is transmitted during communications, while Password property will continue to report "1111". The padded characters are significant, and the password stored in the meter must exactly match the password used during communications (including the fill characters) or an error is generated.</p>
<dl class="section user"><dt>Default value:</dt><dd><ul>
<li>Twenty ASCII zero digits ("00000000000000000000") for the <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a>, <a class="el" href="class_m_protocol_c1221.html">MProtocolC1221</a>, and <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Possible values:</dt><dd><ul>
<li>"12345678901234567890" : Passwords for the <a class="el" href="class_m_protocol_c1218.html">MProtocolC1218</a>, <a class="el" href="class_m_protocol_c1221.html">MProtocolC1221</a>, and <a class="el" href="class_m_protocol_c1222.html">MProtocolC1222</a> protocols (A3, A1800 meters) can have a maximum of 20 characters. If the specified password is less than 20 characters, then the remaining characters are filled with blank spaces during communication. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5fbfdbdb3cbeb2809e0aa18de682decd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetPasswordList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga5052ff1e8bef8913a0bd220a452c7e26">MByteStringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>passwordList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Password list for the protocol.</p>
<p>The password lists, when not empty, overwrite the <a class="el" href="class_m_protocol.html#abad711cb25a0c60e1789391e8398d670">SetPassword</a> property. In such case, passwords from the password list are applied in the ascending order until a successful entry is found. If none exists, the last error received during list processing is thrown.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#ab7eb073d8a88ba1a5f741e5ba5ef35e3">GetPassword</a> </dd>
<dd>
<a class="el" href="class_m_protocol.html#a02d5080403580f3317fc9eade19882d4" title="Set the password list for the protocol to none, so the SetPassword property is used. ">ClearPasswordList</a> - clear the password list </dd>
<dd>
<a class="el" href="class_m_protocol.html#a5483f327ca2dcb745fdb14494848fa01" title="Add a password to the password list. ">AddToPasswordList</a> - add entry to password list </dd>
<dd>
<a class="el" href="class_m_protocol.html#a699b038b23f879820284d27f3ecc3768" title="Return the entry, which was successfully tried with the meter. ">GetPasswordListSuccessfulEntry</a> - shall be called after successful start session to know which password list worked. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc702f61befdd1b58b7186d457e3789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::SetProgressMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_progress_monitor.html">MProgressMonitor</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the progress monitor, if exists </p>

</div>
</div>
<a class="anchor" id="a3f966b2e9889aa5111130cc2a96ce27f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::Sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls channel's Sleep method if the channel is present. </p>
<p>Channel's sleep is interruptible, and this is the difference of this method from plain <a class="el" href="class_m_timer.html#a4d107df93fe5aef90a4f7f255075a2da">MUtilities::Sleep</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>How many milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9c0bf42b3e983e64f0d47856d9e10d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::StartSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously start the session. </p>
<p>Depending on the particular protocol this leads to a sequence of handshake and logon commands.</p>
<p>See <a class="el" href="class_m_protocol.html#afc217114a8b4928f6d62e13ebf826e7f">QStartSession</a> for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the protocol state allows starting the session. Otherwise exceptions can be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a677751b4d8150a1b6236d3f699adf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned MProtocol::StaticCalculateChecksum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute checksum of the byte string given as parameters. </p>
<p>The checksum is calculated based on the C12 rules. Different protocols can have their own variants of this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer for which to calculate the checksum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the checksum, two bytes returned within the low part of four bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa87779c70f4bc9e1208066509d618203"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned MProtocol::StaticCalculateChecksumFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most popular one-byte checksum calculation procedure, a sum of all bytes. </p>
<p>The checksum is calculated based on the C12 rules. Different protocols can have their own variants of this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>The pointer to the buffer for which to calculate the checksum. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the checksum, one byte as lower part of four bytes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a1f41d7ea056c7487378a942b7013cd61">CalculateChecksumFromBuffer</a> Virtual protocol dependent variant of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b9f1af7c99107d64f498f4b2b3a04cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::TableRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously read the whole table with number given as parameter. </p>
<p>See QTableRead for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<p>The third argument is introduced to handle a special case where the table size is bigger than what the protocol allows, such as configuring an ANSI meter to have more load profile data than the 64K that can be transmitted with ANSI C12.18. In this case the table is read with multiple partial reads, where each partial read is sized to fit within the protocol constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>If given, should match exactly the size of the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Table data bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a97ceef5e13fc8328e914f3a85fa3a4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableReadBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as ReadTable, but instead of returning a byte string, read table into a given buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>In addition to all preconditions of ReadTable, the given buffer shall match the table size exactly, or a size mismatch exception is thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">buff</td><td>Where to return the table bytes. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the given buffer and size of the table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac626edc816da38de4579137d15088420"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableReadBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as ReadTable, but instead of returning a byte string, read table into a given template variable. </p>
<dl class="section pre"><dt>Precondition</dt><dd>In addition to all preconditions of ReadTable, the given buffer shall match the table size exactly, or a size mismatch exception is thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5b6e3cb40e08cc7a1928f424235e12a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::TableReadNoThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_exception.html">MException</a> **&#160;</td>
          <td class="paramname"><em>exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously read the whole table with number given as parameter, do not throw an exception, but rather return it. </p>
<p>See QTableRead for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<p>The second argument is introduced to handle exceptions internally and return the data that was successfully read before the exception was raised.</p>
<p>The third argument is introduced to handle a special case where the table size is bigger than what the protocol allows, such as configuring an ANSI meter to have more load profile data than the 64K that can be transmitted with ANSI C12.18. In this case the table is read with multiple partial reads, where each partial read is sized to fit within the protocol constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown. The exception is not NULL, there is a debug check.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">exception</td><td>Returned new object, exception, if it was thrown during the operation. If not NULL, it has to be deleted by the caller. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>If given, should match exactly the size of the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Table data bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a07064801f4387790bc0aa0ec8a4fbb21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> MProtocol::TableReadPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously read part of the table with number given as parameter. </p>
<p>See QTableReadPartial for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the table. </td></tr>
    <tr><td class="paramname">size</td><td>Size within the table starting from the offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Table data bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="acf7d366d9d1f297b52e7baf2bc7ac24b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableReadPartialBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as TableReadPartial, but instead of returning a byte string, read table into a given buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the table. </td></tr>
    <tr><td class="paramname">buff</td><td>Where to return the table bytes. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the partial chunk and size of buff. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Table data bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f275facac5ad95bb8ce4e6df7044008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableReadPartialBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as TableReadPartial, but instead of returning a byte string, partially read table into a given template variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">table</td><td>Table raw structure or class. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae40474bd501a7a79eaa8a858db378818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously write the whole table with number given as parameter. </p>
<p>See QTableWrite for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">data</td><td>Table data to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25225dab2e96159a2e87ccf4a3f98ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableWriteBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as TableWrite, but uses buffer, given as data and size parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to table data to be written. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the table data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#ae40474bd501a7a79eaa8a858db378818">TableWrite</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70c91ea9cb634f292ba182dfad1eb67c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableWriteBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as WriteTable, but uses variable of some specific template class or structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">table</td><td>Table raw structure or class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#ae40474bd501a7a79eaa8a858db378818">TableWrite</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d15c7e39f18cc7d77067ecb5aa0d020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableWritePartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#ga363125c7953be8fc668bee69228efe36">MByteString</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously write part of the table with number given as parameter. </p>
<p>See <a class="el" href="class_m_protocol.html#a1568dcd0e0af9c30043f9179fc527632">QTableWritePartial</a> for the queue version of this service. Q services would work faster for the queue based protocols, but slower for synchronous protocols like C12. Also, they are obviously less convenient for synchronous operations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The channel is open, the session is started. Otherwise exceptions can be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">data</td><td>Table data to be written at a given offset. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1582cc6901f859085d97ae69aca60ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableWritePartialBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as TableWritePartial, but instead of using a byte string, write table using a given buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the table. </td></tr>
    <tr><td class="paramname">buff</td><td>Pointer to table data to be written at a given offset. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8010cabbebd86ff8775a5f7d82711d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::TableWritePartialBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___m_c_o_m.html#gad5ff5eca01eecf9c6e16ef0760965789">MCOMNumberConstRef</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as TableWritePartial, but instead of using a byte string, write table using a given template class contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Table number. </td></tr>
    <tr><td class="paramname">table</td><td>Table raw structure or class. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad1c1a9ec69a7b146af846d0b4555cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MProtocol::WriteCountsToMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write running values of communication quality counters to monitor. </p>
<p>This is a convenience method for all types of troubleshooting. No errors are thrown. If there is no monitor connected, nothing is done. </p>

</div>
</div>
<a class="anchor" id="a9fb4ac84c215dbf8aa29be17a897b2e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MProtocol::WriteToMonitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___m_c_o_r_e.html#gae0f1a09eb8dfba6a5cf718419b3a0304">MStdString</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously write a message to the monitor, if it is connected. </p>
<p>No error is thrown if the Monitor is not listening or the log file is not accumulating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message to write to the Monitor log file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_m_protocol.html#a7480f82e6934a8535760cf325af5bb35" title="Add the message to write to the Monitor log file to MProtocol&#39;s command queue. ">QWriteToMonitor</a> - queue based version of this service. </dd></dl>

<p>Reimplemented from <a class="el" href="class_m_c_o_m_object.html#a99ed01aedf686356cf861d77a155088a">MCOMObject</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_m_protocol.html">MProtocol</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
